---
tags:
  - 操作系统
aliases:
  - IO管理
---

# 输入输出管理

IO 设备管理是操作系统设计中最为凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一致的设计方案。

## IO 设备

IO 设备指可以将数据输入计算机的外部设备，或者可以接收计算机输出数据的外部设备。IO 设备的类型繁多。

> [!tip] IO 即 Input/Output 设备，输入输出设备。

### IO 设备的分类

按照**信息交换的单位**分类，IO 设备可以分为：
1. **块设备**。信息交换以数据块为单位，例如磁盘、磁带等。块设备的基本特征为传输速率高，可寻址，可随机读写。
2. **字符设备**。信息交换以字符为单位，如交互式终端机、打印机。字符设备的基本特征为传输速率低，不可寻址，通常采用中断 IO 方式。

按照**设备的传输速率**分类，IO 设备可以分为：
1. **低速设备**。传输速率在 1B~1KB，例如键盘、鼠标等。
2. **中速设备**。传输速率为 1KB~10KB，例如激光打印机等。
3. **高速设备**。传输速率为 10KB~1000MB，例如磁盘机、光盘机等。

按照**设备的使用特性**分类，IO 设备可以分为：
1. **存储设备**。用于存储信息的外部设备，例如磁盘、磁带、光盘等。
2. **输出、输出设备**。又可以分为输入设备、输出设备和交互式设备。
	- 输入设备：用于向计算机输入外部信息，如键盘、鼠标、扫描仪等。
	- 输出设备：用于计算机向外部输出信息，如打印机等。
	- 交互式设备：集合了上面两种功能，如触控显示器等。

按照**设备的共享属性**分类，IO 设备可以分为：
1. **独占设备**。同一时刻只能由一个进程占用设备。一旦将这类设备分配给某个进程，便由该进程独占，直至用完释放。低速设备一般是独占设备，例如打印机。
	- 属于临界资源，可能导致死锁。
2. **共享设备**。同一==时间段==允许多个进程通过访问的设备。对于共享设备，可同时分配多个进程，通过分时的方式共享使用。典型的共享设备是磁盘。
	- 必须是可寻址、可随机访问的设备。
	- 可以并发访问，不一定可以并行访问。
	- 不属于临界资源，所以不会导致死锁。
3. **虚拟设备**。通过 SPOOLing 技术将独占设备改造为共享设备，将一个物理设备变为多个逻辑设备，从而将设备同时分配给多个进程。

### IO 接口

IO 接口 (设备管理器) 是 CPU 与设备之间的接口，以实现设备和计算机之间数据交换。它接收发自 CPU 的命令，进而控制设备工作，使 CPU 能从繁杂的设备控制事务中解脱出来。设备控制器主要由三个部分组成：
1. **设备控制器与 CPU 的接口**。用于实现 CPU 与设备控制器之间的通信。该接口有三类信号线，数据线、地址线和控制线。
	- 数据线传送的是读写数据、控制信息和状态信息。
	- 地址线传送的是要访问的 IO 接口中的寄存器编号。
	- 控制线传送的是读写等控制信号。
2. **设备控制器与设备的接口**。一个设备控制器可以连接一个或者多个设备，因此控制器中有一个或多个设备接口。每个接口都可以传输数据、控制和状态三种类型的信号。
2. **IO 逻辑**。用于实现对设备的控制。它通过一组控制线与 CPU 交互，对从 CPU 收到的 IO 命令进行译码。CPU 启动设备时，将启动命令送给控制器，同时通过地址线将地址发送给控制器，由控制器的 IO 逻辑对地址进行译码，并对所选设备进行控制。

> [!example] 设备管理器的组成
> ![[Excalidraw/操作系统-设备控制器.excalidraw|操作系统-设备控制器.excalidraw|center|600]]

> [!note] 设备控制器的主要功能
> 1. 接收和识别命令，如磁盘控制器能够接收 CPU 发来的读、写、查找等命令。*IO 控制器中会有相应的控制寄存器用于存放 CPU 的命令和参数*。
> 2. 进行数据交换，包括 CPU 和控制器之间的数据传输，以及控制器和设备之间的数据传输。*IO 控制器中会有相应的数据寄存器，用于缓冲数据*。
> 3. 标识和报告设备的状态，供 CPU 进行参考。*IO 控制器中会有相应的状态寄存器用于记录 IO 设备当前的状态，例如忙碌、空闲等*。
> 4. 地址识别。
> 5. 数据缓冲。
> 6. 差错控制。

> [!note] IO 接口的类型
> 从不同的角度，可以将 IO 接口分为不同的类型：
> 1. 从**数据传送方式**来看，可以分为：
> 	- 并行接口：一个字节或者一个字的所有位同时传送。
> 	- 串行接口：一位一位地有序传送。
> 2. 按**主机访问 IO 设备的控制方式**来看，可以分为程序查询接口、中断接口和 DMA 接口等。
> 3. 按**功能选择的灵活性**来看，可以分为可编程接口和不可编程接口。

### IO 端口

IO 端口是指设备控制器中可以被 CPU 直接访问的寄存器，主要有以下三类寄存器。
- 数据寄存器：用于缓存从设备送来的输入数据，或从 CPU 送来的输出数据。
- 状态寄存器：保存设备的执行结果或状态信息，以供 CPU 读取。
- 控制寄存器：由 CPU 写入，以便启动命令或者更改设备模式。

> [!note] 编址
> IO 端口想要能够被 CPU 访问，就要对各个端口进行编址。每个端口对应一个端口地址，而对 IO 端口编址方式有**独立编址**和**统一编址**两种方式。
> 1. **独立编址**指为每个端口分配一个 IO 端口号。IO 端口的地址空间与主存地址空间是两个独立的地址空间，它们的范围可以重叠，相同地址可能属于不同的地址空间。普通用户程序不能对端口进行访问，只有操作系统使用特殊的 IO 指令才能访问端口。
> 	- 优点：IO 端口数比主存少的多，只需要使用少量的地址线，就可以使得 IO 端口译码简单，寻址速度更快。此外，使用专门的 IO 指令，可以使得程序更加清晰，便于理解和检查。
> 	- 缺点：IO 指令少，指提供简单的传输操作，因此程序的设计灵活性较差。此外，CPU 需要提供两组独立的存储器和设备的读写控制信号，增加了控制的复杂性。
> 2. **统一编址**又称内存映射 IO，是指将主存地址空间分为一部分给 IO 端口进行编址，IO 端口和主存单元在同一地址空间的不同分段中，根据地址范围就可以区分访问的是 IO 端口还是主存单元，因此无需设置专门的 IO 指令，用统一的访存指令就可以访问 IO 端口。
> 	- 优点：不需要专门的 IO 指令，使得 CPU 访问 IO 的操作更加灵活和方便，还使得端口有较大的编址空间。IO 访问的保护机制可以由虚拟存储管理机制来实现，无须专门设置。
> 	- 缺点：端口地址占用了部分主存地址空间，使主存的可用容量变小。此外，由于在识别 IO 端口时全部地址线都要参与译码，使得译码电路更复杂，降低了寻址速度。

## IO 控制方式

IO 控制是指控制设备与主机之间的数据传送。在 IO 控制方式的发展过程中，始终贯穿着这样一个宗旨：尽量减少 CPU 对 IO 控制的干预，将 CPU 从繁杂的 IO 控制事务中解脱出来，以便其能更多地去执行运算任务。

IO 控制方式共有**程序直接控制方式**、**中断驱动方式**、**DMA 方式**与**通道控制方式**四种。

### 程序直接控制方式

CPU 对 IO 设备的控制采用轮询的 IO 方式，又称为**程序轮询方式**。
1. CPU 向设备控制器发出一条 IO 指令，启动从 IO 设备读取一个字。
2. 之后，CPU 不断循环测试设备的状态 (轮询)，直到确定该字已经在设备控制器的数据寄存器中。
3. CPU 将数据寄存器中的数据取出，送到内存的指定单元，这样便完成了一个字的 IO 操作。

> [!note] 程序直接控制方式的缺点
> CPU 的绝大部分时间处于等待 IO 设备状态的循环测试中，CPU 和 IO 设备只能串行工作。由于 CPU 和 IO 设备的速度差异很大，导致 CPU 的利用率很低。

### 中断驱动方式

**中断驱动方式**允许 IO 设备主动打断 CPU 的运行并请求服务，从而解放 CPU，使得 CPU 向设备控制器发出一条 IO 指令后可以继续做其他工作。

相比于程序轮询 IO 方式，在中断驱动 IO 方式中，设备控制器通过中断主动向 CPU 报告 IO 操作已完成，不再需要轮询，在设备准备数据期间，CPU 与设备并行工作，CPU 利用率得到明显提升。

> [!note] 从设备管理器的角度
> 设备管理器从 CPU 接收一个读命令后，从设备中读数据。一旦数据读入设备控制器的数据寄存器，便通过控制线给 CPU 发送中断信号，表示数据已经准备好，然后等待 CPU 请求该数据。
>
> 设备管理器收到 CPU 发出的取数据请求后，将数据放到数据总线上，传到 CPU 的寄存器中。至此，一次 IO 操作完毕。

> [!note] 从 CPU 的角度
> - 当前运行进程发出读命令，该进程将被阻塞，然后保存进程的上下文，转去执行其他程序。
> - 在每个指令周期的末尾，CPU 检查中断信号。当有来自设备控制器的中断信号时，CPU 保存当前运行进程的上下文，转去执行中断处理程序。
> - 在中断处理程序中，CPU 从设备控制器读一个字的数据传输到寄存器，并存入主存。中断处理完毕后解除等待 IO 命令的进程阻塞状态，将其加入就绪队列中。
> - 恢复当前运行进程的上下文，并继续运行。

> [!note] 中断驱动方式的缺点
> 1. 设备与内存之间的数据交换必须经过 CPU 中的寄存器。
> 2. CPU 是以字为单位进行干预的，若将这种方式用于块设备的 IO 操作，则效率较低。因此，中断驱动 IO 方式的速度有限。

### DMA 方式

**DMA** (直接存储器存取) 方式在 IO 设备和内存之间开辟了直接的数据交换通路，彻底解放 CPU。DMA 方式的特点如下：
1. 基本传送单位是数据块，而不再是字。
2. 所传送的数据，是从设备直接送入内存的 (或者内存直接送入设备)，不再经过 CPU。
3. 仅在传送一个或者多个数据块的开始和结束时，才需要 CPU 的干预。

为了实现主机与控制器之间直接交换成块的数据，必须在 DMA 控制器中设置如下 4 类寄存器：
1. **命令/状态寄存器**(CR)：接收从 CPU 发来的 IO 命令、有关控制信息，或设备的状态。
2. **内存地址寄存器**(MAR)：在输入时，它存放将数据从设备传送到内存的起始目标地址。在输出时，它存放由内存到设备的内存源地址。
3. **数据寄存器**(DR)：暂存从设备到内存或从内存到设备的数据。
4. **数据计数器**(DC)：存放本次要传送的字数。*在传输过程中，代表剩余要读/写的字节数*。

> [!note] DMA 的工作流程
> 1. CPU 接收到设备的 DMA 请求时，向 DMA 控制器发出一条命令，同时设置 MAR 和 DC 的初值，启动 DMA 控制器，然后继续其他工作。之后由 DMA 控制数据传送。
> 2. DMA 控制器直接与内存交互，每次传输一个字，这个过程不需要 CPU 的参与。
> 3. 整个数据传输结束后，DMA 控制器向 CPU 发送一个中断信号。

> [!note] DMA 方式的优点
> - 数据传输以块为单位，CPU 介入的频率进一步降低。
> - 数据传送不再经过 CPU 寄存器，CPU 和设备的并行操作程度得到进一步提升。

### 通道控制方式

IO 通道是一种特殊的处理机，它可以执行一系列通道指令。设置通道后，CPU 只需要向通道发送一条 IO 指令，指明通道程序在内存中的位置和要访问的 IO 设备，通道接收该指令后，执行通道程序，完成规定的 IO 任务后，向 CPU 发出中断请求。

通道方式可以实现 CPU、通道和 IO 设备三者的并行工作，从而更有效的提高整个系统的资源利用率。

> [!note] 通道与一般处理机的区别
> 1. 通道指令类型单一。
> 2. 通道没有自己的内存，所执行的通道程序是存放在主机的内存中的。也就是说通道与 CPU 共享内存。

> [!note] 通道与 DMA 方式的区别
> - DMA 方式需要 CPU 来控制传输的数据大小、传输的内存位置。而通道方式中这些信息由通道控制。
> - 每个 DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存交换数据。

## IO 软件层次结构

IO 软件涉及的面很宽，往下与硬件由密切关系，往上与虚拟存储器系统、文件系统和用户直接交互，它们都需要 IO 软件来实现 IO 操作。为了使得复杂的 IO 软件能够具有清晰的结构、良好的可移植性和易适应性，目前普遍采用 [[操作系统/操作系统基本原理概论#分层法|层次式结构]] 的 IO 软件。

将系统中的设备管理模块分为若干层次，每层都利用其下层提供的服务，完成输入输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。

在层次式结构的 IO 软件中，只要层次间的接口不变，对某一层次的软件的修改都不会引起其下层或高层代码的变更，仅最低层才涉及硬件的具体特性。整个 IO 软件可以视为具有 4 个层次的系统结构：
1. **用户层软件**：实现与用户交互的接口，用户可以直接调用在用户层提供的 IO 库函数，对设备进行操作。
	- 通常大部分的 IO 软件都在操作系统内核中，但是仍有一小部分在用户层，包括与用户程序链接在一起的库函数。
	- 用户层 IO 软件必须通过一组系统调用来获取操作系统服务。
2. **设备独立性软件**：又称为设备无关性软件，用于实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。
	- 设备独立软件向上层提供系统调用的接口，根据设备的类型选择对应的设备驱动程序。
3. **设备驱动程序**：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 IO 设备工作的驱动程序。*操作系统一般会规定一个通用的设备驱动程序接口，如果硬件想要运行在该操作系统上，就需要提供与操作系统对应的驱动程序*。
	- 通常，为每类设备配置一个设备驱动程序，它是 IO 进程与设备控制器之间的通信程序，通常以进程的形式存在，用于接收上层软件发来的抽象 IO 要求。
	- 设备驱动程序将上层的 IO 要求 (如 `read` 和 `write` 命令)，转换为具体的要求后，发送给设备控制器，控制 IO 设备工作。同时，将设备控制器发来的信号送给上层软件。
4. **中断处理程序**：用于包含被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程。
	- 中断处理程序负责实现进程的上下文切换、对处理中断信号源进行测试，读取设备状态和修改进程状态等。
	- 由于中断处理与硬件紧密相关，对用户而言，应该尽量屏蔽，因此应放在操作系统的底层，系统的其余部分应该尽可能少地与之发生联系。

> [!note]
> 在 IO 软件层次中，设备独立性软件、设备驱动程序、中断处理程序是运行在操作系统的内核态中，称为 **IO 核心子系统**，也称为 IO 系统。

> [!example] 一次磁盘 IO
> 1. 用户层：当用户要读取某设备的内容时，通过操作系统提供的 `read` 命令进行读取。
> 2. 设备独立层：操作系统提供的命令一般是通用接口，也就是几乎每个设备都可以响应的同一命令。用户在发出 `read` 命令后，经由设备独立层解析后，交往下层。
> 3. 设备驱动层：不同的设备对于 `read` 的行为是不同的，因此需要对应的设备驱动程序解析为该设备对应的指令。
> 4. 中断处理程序：命令解析完毕后，需要中断正在运行的进程，转而执行 `read` 命令，此时需要中断处理程序。
> 5. 硬件设备：命令真正抵达硬件设备，按照上层传递的控制指令操控硬件设备，完成相应的功能。

### 应用程序 IO 接口

在用户层中，还可以将 IO 接口类型根据设备类型进一步划分：
1. **字符设备接口**：与字符设备^[数据的存取与传输是以字符为单位的设备，如键盘、打印机等。见 [[#IO 设备的分类]]] 的接口。基本特征是传输速率较低、不可寻址，并且在输入、输出时采用中断驱动方式。
	- `get` 和 `put` 操作。由于字符设备==不可寻址==，只能采用顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过 `get` 操作从缓冲区获取字符，通过 `put` 操作将字符输出到缓冲区^[运作方式与 c 语言中的 `getc` 函数与 `putc` 函数类似]。
	- `in-control` 指令。字符设备类似繁多，差异甚大，因此在接口中提供一种通用的 `in-control` 指令来处理它们。该指令包含众多的参数，每个参数都表示一个与具体设备相关的功能。
	- 字符设备属于独占设备，为此接口中还需要提供打开和关闭操作，以实现共享互斥。
2. **块设备接口**：与块设备^[数据的存取和传输以数据块为单位的设备，典型的块设备是磁盘。见 [[#IO 设备的分类]]] 的接口。基本特征是传输速率较高、可寻址。磁盘设备的 IO 常采用 DMA 方式。
3. **网络设备接口**：现代操作系统都提供面向网络的功能，因此还需要提供相应的网络软件和网络通信接口，使计算机能够通过网络与网络上的其他计算机进行通信或上网浏览。
	- 许多操作系统提供的网络 IO 接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。
	- 常见的网络套接字接口有 Linux 系统中的 `socket`、`bind`、`connect`、`send` 和 `recv` 操作。

> [!note] 阻塞 IO 与非阻塞 IO
> - **阻塞 IO**：指当前用户进程调用 IO 操作时，进程将被阻塞，并移入阻塞队列，IO 操作完成后，进程才被唤醒，移到就绪队列。当进程恢复执行时，它收到系统调用的返回值，并继续处理数据。*大多数的操作系统提供的 IO 接口都是采用阻塞 IO*。
> 	- 优点：操作简单，实现难度低，适合并发量小的应用开发。
> 	- 缺点：IO 执行阶段进程会一直阻塞。
> - **非阻塞 IO**：指当前用户进程调用 IO 操作时，不阻塞该进程，但进程需要不断询问 IO 操作是否完成，在 IO 执行阶段，进程还可以做其他事情。当问到 IO 操作完成后，系统将数据从内核复制到用户空间，进程继续处理数据。*例如 `write` 操作*。
> 	- 优点：进程在等待 IO 期间不会阻塞，可以做其他事情，适合并发量大的应用开发。
> 	- 缺点：轮询方式询问 IO 结果，会占用 CPU 的时间。

## 设备独立性软件

也称为**设备无关的软件**，是 IO 系统的最高层软件，它的下层是设备驱动程序，其界限因操作系统和设备的不同而有所差异。一般而言，设备独立性软件包括执行所有设备公有操作的软件。

### 高速缓存和缓冲区

#### 磁盘高速缓存

磁盘高速缓存是操作系统用来提升磁盘 IO 速度的技术，主要通过将最近访问的磁盘块存储在内存中来减少对物理磁盘的访问次数。与通常的 CPU 高速缓存不同，磁盘高速缓存的作用是优化**磁盘读取**性能。

> [!note] 磁盘高速缓存的实现
> 1. 磁盘缓存逻辑上归属于磁盘，物理上使用内存的部分空间。
> 2. 它通常以磁盘块为单位，将磁盘读取的数据暂存在内存中。

> [!warning] 磁盘高速缓存技术
> 磁盘高速缓存技术不同于通常意义下的介于 CPU 与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上属于驻留在内存中的盘块。
>
> 高速缓存的实现方式有两种：
> - 对于一些速度要求较高的情景，适合采用硬件实现的高速缓冲区，例如页表机制中的 [[计算机组成原理/存储系统#快表 TLB|快表 TLB]]。这种实现方式速度快，但是成本高。
> - 对于一些速度要求不是非常高的情景，一般使用内存作为缓冲区。例如本节中介绍的磁盘缓冲区。

磁盘高速缓存在内存中有两种实现形式：
- **固定区域**：在内存中开辟一个单独的空间作为缓存区，大小固定。
- **未利用的内存空间**：将未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘 IO 时共享。

#### 缓冲区

缓冲区是操作系统中的一种机制，用于平衡 CPU 与 IO 设备间的速度差异。它既可以用于数据的输入，也可以用于输出。缓冲区的主要作用是：
1. 缓解设备间速度不匹配的矛盾。
2. 减少对 CPU 的中断频率。
3. 提高 CPU 与 IO 设备之间的并行性。
4. 适应不同设备间的数据粒度差异。

缓冲区可以用于各种设备和操作，而磁盘高速缓存则专门用于优化磁盘的读写性能。

> [!warning]
> 为了减少对缓冲区中数据的存取次数和保证缓冲区中的数据一致性，在实际中只有缓冲区满时才能取其中数据，缓冲区为空时才能向其中写入数据。

> [!tip]
> 在缓冲区管理中，实现进程访问的 [[操作系统/进程管理#实现进程同步|同步]] 是一个重要的问题。因为缓冲区是一种临界资源，所以在使用缓冲区时都有一个申请和释放的问题需要考虑。

##### 单缓冲

每当用户进程发出一个 IO 请求，操作系统便在内存中为之分配一个缓冲区。通常，一个缓冲区的大小就是一个块。
- 在输入数据时，IO 设备先将数据输入到被分配的缓冲区中。
- 在缓冲区填满后，CPU 从中取出数据，并进行处理。在数据被取走之后，IO 设备再次将之后的输入填入缓冲区。
- CPU 在处理之前数据的同时，IO 设备也在将输入填入缓冲区。

> [!note]- 单缓冲性能分析
> 在块设备输入时，假定从设备将一块数据输入到缓冲区的时间为 $T$，操作系统将该缓冲区中的数据传送到工作区的时间为 $M$，而 CPU 对这一块数据进行处理的时间为 $C$。**输入缓冲区和 CPU 处理数据是可以并行的**。
> 1. 当 $C>T$ 时，即 CPU 处理数据的时间大于输入缓冲区的时间，则缓冲区装满后，需要等待 CPU 处理完成之前的数据，才能进行传输数据。*由于缓冲区是共享资源，因此使用时必须互斥。若 CPU 尚未取走缓冲区中的数据，则即使设备又生产了新的数据，也无法将其送入缓冲区，此时设备需要等待*。此时的平均处理时间为 $C+M$。
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> dateFormat  x
> axisFormat  %L
> title 单缓冲技术处理时间 (C > T)
> section 输入缓冲区
> T 		:	a1, 0, 2
> T 		:	a2, 3, 5
> 
> section CPU 从缓冲区取数据
> M 		:	a2, 2, 3
> M 		:	a2, 5, 6
> 
> section CPU处理
> C 		:	a3, 0, 1
> C 		:	a3, 3, 4
> ```
> 1. 当 $C<T$ 时，即 CPU 处理数据的时间小于输入缓冲区的时间，则 CPU 处理完成数据之后，需要等待缓冲区再次装满才能从缓冲区取数据。此时的平均处理时间为 $T+M$。
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> dateFormat  x
> axisFormat  %L
> title 单缓冲技术处理时间 (T > C)
> section 输入缓冲区
> T 		:	a1, 0, 1
> T 		:	a2, 3, 4
> 
> section CPU 从缓冲区取数据
> M 		:	a2, 2, 3
> M 		:	a2, 5, 6
> 
> section CPU处理
> C 		:	a3, 0, 2
> C 		:	a3, 3, 5
> ```
> 因此，使用单缓冲区时，每块数据的平均处理时间为 $\max(C,T)+M$。

##### 双缓冲

为了加快输入和输出速度，提高设备的利用率，引入了双缓冲机制，也称为**缓冲对换**。双缓冲技术使用了两个缓冲区
1. 当设备输入数据时，先将数据送入缓冲区 1，装满后转向缓冲区 2 继续输入。
2. 缓冲区 1 被填满后，操作系统可以从缓冲区 1 中取出数据，送入用户进程，并由 CPU 对数据处理。此时缓冲区 1 又可以作为新的缓冲区被设备使用。
3. 当缓冲区 1 的数据被处理完毕后，若缓冲区 2 已经充满，则操作系统又可以从缓冲区 2 中取出数据送入用户进程。

> [!note]- 双缓冲性能分析
> 仍然假设设备输入数据到缓冲区、数据传送到用户进程和处理的时间分别为 $T$，$M$ 和 $C$。特别的，这里使用 $T_{1}$ 表示装填第一个缓冲区的过程，使用 $T_{2}$ 表示装填第二个缓冲区的过程。由于这两个缓冲区的实现是相同的，因此 $T_{1}=T_{2}$。
> 1. 当 $T>C+M$ 时，说明设备输入的时间比数据传送和处理的时间多，可以使得设备连续输入。
> 	- 假设在某个时刻，缓冲区 1 是空的，缓冲区 2 是满的，缓冲区 2 开始向工作区传送数据，缓冲区 1 开始装入数据。
> 	- 传送并处理数据的时间为 $C+M$，但是缓冲区 1 还没有装满，必须等待缓冲区 1 装满数据，才能将下一块数据从缓冲区 1 传送到工作区。
> 	- 此时的平均处理时间为 $T$。
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> dateFormat  x
> axisFormat  %L
> title 双缓冲技术处理时间 (T>C+M)
> section 输入缓冲区
> T1 		:	a1, 0, 3
> T2		:	a2, 3, 6
> T1 		:	a1, 6, 9
> T2		:	a2, 9, 12
> 
> section 取数据
> M2 		:	a1, 0, 1
> M1 		:	a2, 3, 4
> M2 		:	a1, 6, 7
> M1 		:	a2, 9, 10
> 
> section CPU处理
> C2 		:	a3, 1, 2
> C1 		:	a3, 4, 5
> C2 		:	a3, 7, 8
> C1 		:	a3, 10, 11
> ```
> 2. 当 $T<C+M$ 时，说明设备输入的时间比数据传送和处理的时间少，可以使得 CPU 不必等待设备输入。
> 	- 假设在某个时刻，缓冲区 1 是空的，缓冲区 2 是满的，缓冲区 2 开始向工作区传送数据，缓冲区 1 开始装入数据。
> 	- 缓冲区 1 装满的时间为 $T$，此时 CPU 还没有处理完成数据，必须等待缓冲区 2 中的数据被传送并处理完毕后，才能将下一块数据装入缓冲区 1 中。
> 	- 此时的平均处理时间为 $C+M$。
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> dateFormat  x
> axisFormat  %L
> title 双缓冲技术处理时间 (C+M>T)
> section 输入缓冲区
> T1 		:	a1, 0, 2
> T2		:	a2, 3, 5
> T1 		:	a1, 6, 8
> T2		:	a2, 9, 11
> 
> section 取数据
> M2 		:	a1, 0, 1
> M1 		:	a2, 3, 4
> M2 		:	a1, 6, 7
> M1 		:	a2, 9, 10
> 
> section CPU处理
> C2 		:	a3, 1, 3
> C1 		:	a3, 4, 6
> C2 		:	a3, 7, 9
> C1 		:	a3, 10, 12
> ```
>
> 因此，双缓冲区处理每块数据的平均时间为 $\max(C+M,T)$。

> [!tip]
> 若两台机器直接仅配置了单缓冲，则它们在任意时刻都只能实现单方向的数据传输，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲，另一个用作接收缓冲。

##### 循环缓冲

在双缓冲机制中，只有当输入与输出的速度相匹配时，能够取得较好的效果。但若两者的速度相差甚远，则双缓冲区的效果不会太理想。为此，引入多缓冲机制，让多个缓冲区组成循环缓冲区的形式。

循环缓冲区包含多个大小相等的缓冲区，每个缓冲区都有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区链接称一个 [[数据结构/栈、队列和数组#循环队列|循环队列]]。

循环队列中设置 `in` 与 `out` 指针，`in` 指向第一个可以输入数据的空缓冲区，`out` 指向第一个可以提取数据的满缓冲区。输入、输出时，`in` 和 `out` 指正沿链接方向循环移动。

##### 缓冲池

相比于缓冲区 (仅是一块内存空间)，缓冲池是包含一个用于管理自身的数据结构和一组操作函数的管理机制^[这里类似 [[操作系统/进程管理#管程 |管程]] 的概念]，用于管理多个缓冲区。缓冲池可供多个进程使用。

缓冲池由多个公用的缓冲区组成，缓冲区按照其使用情况可以分为：
1. 空缓冲队列，由空缓冲区链接而成。
2. 输入队列，由装满输入数据的缓冲区链接而成。
3. 输出队列，由装满输出数据的缓冲区链接而成。

此外，还包含四种工作缓冲区：
1. 用于收容输入数据的工作缓冲区 `hin`。
2. 用于提取输入数据的工作缓冲区 `sin`。
3. 用于收容输出数据的工作缓冲区 `hout`。
4. 用于提取输出数据的工作缓冲区 `sout`。

缓冲池中的缓冲区有以下四种工作方式：
1. 收容输入。进程需要输入数据时，从空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后将数据输入其中，装满后再将它挂到输入队列的队尾。
2. 提取输入。计算进程需要数据时，从输入队列的队首取得一个缓冲区，作为提取输入工作缓冲区，从中提取数据，用完该数据后将它挂到空缓冲队列的队尾。
3. 收容输出。计算进程需要输出数据时，从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满数据后，再将它挂到输出队列的队尾。
4. 提取输出。输出进程需要输出数据时，从输出队列的队首取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，在将它挂到空缓冲队列的队尾。

> [!tip] 这里的循环缓冲与缓冲池，只是定性的介绍了其概念，没有作深入的探讨。

> [!note] 高速缓存与缓冲区的对比
> 高速缓存是可以保存数据拷贝的高速存储器，访问高速缓存比访问原始数据更加高效，速度更快。它们的对比如下：
> 1. 相同点：高速缓存与缓冲区都介于高速设备与低速设备之间，用于平衡速度差异。
> 2. 不同点：
> 	- 存放的数据不同：高速缓存存放的是低速设备上某些数据的拷贝，**高速缓存上有的数据，低速设备上面必然有**。缓冲区存放的是低速设备传递给高速设备的数据 (或者反过来)，而这些数据在低速设备上不一定有备份。
> 	- 目的不同：高速缓存存放的是高速设备经常要访问的数据，若高速设备要访问的数据不在高速缓存中，那么就要访问低速设备。而缓冲区用于高速设备与低速设备的通信，高速设备永远都不会直接访问低速设备。

### 设备的分配与回收

设备分配是指根据用户的 IO 请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成的 [[操作系统/进程管理#死锁|进程死锁]]。

> [!note] 设备的分配需要考虑的因素
> 1. **设备的固有属性**：设备的固有属性可以分成三种，对它们应该分别采取不同的分配策略：
> 	- 独占设备：将它分配给某个进程后，便由该进程独占，直至进程完成或释放该设备。
> 	- 共享设备：可将它同时分配给多个进程，需要合理调度各个进程访问该设备的先后次序。
> 	- 虚拟设备：利用 [[操作系统/输入输出管理#SPOOLing 技术|SPOOLing 技术]] 技术将独占设备转换为的共享设备。
> 2. **设备分配算法**：通常采用 FCFS 算法或者高相应比优先算法^[同 [[操作系统/进程管理#调度算法|进程调度算法]]]。
> 3. **设备分配中的安全性**：指在设备的分配中应该防止死锁的发生。
> 	- 安全分配方式：每当进程提出 IO 请求后，便进入阻塞状态，直到其 IO 操作完成。安全分配方式破坏了死锁的 [[操作系统/进程管理#死锁产生的必要条件|请求和保持]] 条件，优点是设备分配安全，缺点是 CPU 和 IO 设备是串行工作的。
> 	- 不安全分配方式：进程在发出 IO 请求后仍然继续运行，此时进程可能会继续发出第二个、第三个 IO 请求。*仅当进程所请求的设备被另一个进程占用时，才进入阻塞态*。优点是一个进程可同时操作多个设备，使进程推进迅速，缺点是可能发生死锁。

在系统中，可能存在多个通道，每个通道可以连接多个控制器，每个控制器可以链接多个物理设备。设备分配的数据结构要能够体现这种从属关系，因此为每个层次都设置了对应的数据结构：
1. **设备控制表**(DCT)：系统为每个设备配备一张 DCT，表中的表项就是设备的各个属性。
	- 设备类型：表示设备的类型，如打印机、扫描仪、键盘等。
	- 设备标识符：即物理设备名，每个设备在系统中的物理设备名是唯一的。物理设备名也称为绝对号。
	- 设备状态：表示当前设备的状态 (忙碌、空闲)。
	- 指向控制器表的指针：每个设备由一个控制器控制，该指针指向对应的控制器表。
	- 重复执行次数或时间：重复执行次数到达规定值仍不成功时，才认为此次 IO 失败。
	- 设备队列的队首指针：指向正在等待该设备的进程队列的队首^[该队列即相应设备的阻塞队列，队列中的元素为阻塞进程的 PCB。在 [[操作系统/进程管理#进程的组织|进程的组织]] 中，操作系统会按照阻塞原因划分阻塞队列，这里就是一个例子]。
2. **控制器控制表**(COCT)：每个设备控制器都对应一张 COCT。操作系统根据 COCT 的信息对控制器进行操作和管理。
	- 控制器标识符。
	- 控制器状态：忙碌、空闲。
	- 指向通道表的指针：每个控制器由一个通道控制，通过表项可以找到相应的通道的信息。
	- 控制器队列的队首指针。
	- 控制器队列的队尾指针。
3. **通道控制表**(CHCT)：每个通道都对应一张 CHCT，操作系统根据 CHCT 的信息对通道进行操作和管理。
	- 通道标识符。
	- 通道状态。
	- 与通道连接的控制器表首址：一个通道为多个控制器服务，通过该表项可以找到该通道管理的所有控制器的信息。
	- 通道队列的队首指针。
	- 通道队列的队尾指针。
4. **系统设备表**(SDT)：整个系统只有一张 SDT，它记录已连接到系统中的所有物理设备情况，每个物理设备对应一个表目。

> [!note] 设备分配的步骤
> 下面以独占设备为例，介绍设备分配的步骤：
> 1. **分配设备**。首先根据 IO 请求中的物理设备名，查找 SDT，从中找出该设备的 DCT，再根据 DCT 中的设备状态字段，可知该设备的状态。
> 	- 若忙，则将进程的 PCB 挂到设备的等待队列中。
> 	- 若不忙，则根据一定的策略将设备分配给该进程。
> 2. **分配控制器**。设备分配后，根据 DCT 找到 COCT，查询控制器的状态。
> 	- 若忙，则将进程 PCB 挂到控制器等待队列中。
> 	- 若不忙，则将控制器分配给该进程。
> 3. **分配通道**。控制器分配后，根据 COCT 找到 CHCT，查询通道状态。
> 	- 若忙，则将进程 PCB 挂到通道等待队列中。
> 	- 若不忙，则将通道分配给该进程。
>
> 只有设备、控制器和通道都分配成功时，这次的设备分配才算成功，之后便可以启动设备进行数据传送。

> [!note] 逻辑设备名
> 在上面的例子中，进程是以物理设备名提出 IO 请求的，若指定的设备已经分配给了其他的进程，则该进程分配失败。换句话说，**上面的分配过程中不具有设备无关性**，因为需要在请求 IO 时指明使用的物理设备。
>
> 为了获得设备无关性，我们应当使用逻辑设备名，这样，系统首先根据逻辑设备名，从 SDT 中找出第一个符合要求的 DCT，若该设备忙，则查找下一个符合要求的设备，仅当所有该类设备都忙时，才将 PCB 挂到该类设备的等待队列上。而只要有一个设备可用，系统便进入分配操作。
>
> 逻辑设备使用一张**逻辑设备表**(LUT) 实现，用于将逻辑设备名映射为物理设备名。逻辑设备表中的每一个表项包含三个内容，逻辑设备名、物理设备名和设备驱动程序的入口地址。当进程用逻辑设备名来请求分配设备时，系统会为它分配一台相应的物理设备，并在 LUT 中建立一个表目，填上相应的信息。当以后进程再利用该逻辑设备名请求 IO 操作时，系统通过查找 LUT 来寻找对应物理设备及其驱动程序。
>
> 在系统中，可以采用两种方式设置 LUT：
> 1. 整个系统中只设置一张 LUT。所有进程的设备分配情况都记录在同一张 LUT 中，这样的方式要求所有用户不能使用相同的逻辑设备名，主要适用于单用户系统。
> 2. 为每个用户设置一张 LUT。系统为每个用户设置一张 LUT，同时在多用户系统中配置系统设备表。因此，不同用户可以使用相同的逻辑设备名。

### SPOOLing 技术

SPOOLing 技术又称为**假脱机技术**，是操作系统为了缓和 CPU 的告诉性和 IO 设备的低俗性之间的矛盾，采用的一项将独占设备改造成共享设备的技术。

SPOOLing 技术利用软件模拟外围控制机，先将低速 IO 设备上的数据传输到高速磁盘上，或者相反。当 CPU 需要输入数据时，便可直接从磁盘中读取数据；当 CPU 需要输出数据时，也能很快将数据先输出到磁盘上。
1. 输入井和输出井：在磁盘上开辟出的两个存储区域。
	- 输入井：用于模拟脱机输入时的磁盘，用于收容 IO 设备输入的数据。
	- 输出井：用于模拟脱机输出时的磁盘，用于收容用户程序的输出数据。
	- 一个进程的输入 (输出) 数据保存为一个文件，所有进程的输入 (输出) 文件链接成一个输入 (输出) 队列。
2. 输入缓冲区和输出缓冲区：在内存中开辟的两个缓冲区。
	- 输入缓冲区：用于暂存由输入设备送来的数据，以后再传输到输入井。
	- 输出缓冲区：用于暂存从输出井送来的数据，以后再传送到输出设备。
3. 输入进程和输出进程：
	- 输入进程用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传输到输入缓冲区，再放到输入井中。当 CPU 需要数据时，直接从输入井中读入内存。
	- 输入进程用于模拟脱机输出时的外围控制机，将用于要求输入的数据从内存传送到输出井，待输出设备空闲时，再将输出井中的数据经输出缓冲区输出至输出设备。
4. 井管理程序：用于控制作业和磁盘井之间的信息交换。

> [!warning]
> 在 SPOOLing 技术中，外围控制机一般使用软件实现。由于 SPOOLing 技术需要用到磁盘相关的设备独立性软件的接口，因此一般实现在用户层中。
>
> 从 SPOOLing 技术的原理可以看出，SPOOLing 技术只能在多道程序技术下才能实现。

> [!example]
> 打印机是经典的独占设备，利用 SPOOLing 技术可以将它改造为一台可供多个用户共享的打印设备。当多个用户进程发出打印输出请求时，SPOOLing 系统同意它们的请求，但是并不是立即将打印机分配给它们，而是由假脱机管理进程为每个进程做如下两项工作：
> 1. 在磁盘缓冲区中为进程申请一块空闲盘块，并将要打印的数据送入其中暂存。
> 2. 为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上。
>
> 对于每个用户进程而言，系统并非及时执行真实的打印操作，而只是即时将数据输出到缓冲区。真正的打印发生在打印机空闲时且该打印任务在等待队列的队首时。
>
> 但是以上过程用户是不可见的。因此，SPOOLing 技术让每个进程都觉得自己正在独占一台打印机，从而实现对打印机的共享。

> [!note] SPOOLing 系统的特点
> 1. 提高了 IO 速度，将对低速 IO 设备执行的操作演变为对磁盘缓冲区中数据的存取操作，如同脱机输入、输出一样，缓和了 CPU 和低速 IO 设备之间速度不匹配的矛盾。
> 2. 将独占设备改造为共享设备。
> 3. 实现了虚拟设备功能，对于每个进程而言，它们都认为自己独占了一台设备。
>
> SPOOLing 技术是一种典型的**空间换时间**的技术。

## 设备驱动程序接口

设备驱动程序是 IO 系统的上层与设备控制器之间的通信程序，其主要任务为接收上层应用发来的抽象 IO 请求，如 `read` 或 `write` 命令，将它们转换为具体要求后发送给设备控制器，进而启动设备去执行任务。反之，它也将设备控制器发来的信号传送给上层。

为了实现上层应用与设备控制器之间的通信，设备驱动程序应具有以下功能：
1. 接收由上层软件发来的命令和参数，并将抽象要求转换为与设备相关的具体要求。*例如，将抽象要求中的盘块号转换为磁盘的盘面号、磁道号及扇区号*。
2. 检查用户 IO 请求的合法性，了解设备的工作状态，传递与设备操作有关的参数，设置设备的工作方式。
3. 发出 IO 命令，若设备空闲，则立即启动它，并完成执行的 IO 操作。若设备忙，则将请求者的 PCB 挂到设备的等待队列上。
4. 及时相应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。

> [!note] 设备驱动程序的特点
>　相比于普通的应用程序和系统程序，设备驱动程序具有以下特点：
> 1. 设备驱动程序将抽象的 IO 请求翻译为具体的 IO 操作后，传送给设备控制器，并将设备控制器中记录的设备状态和 IO 操作的完成情况及时地反馈给请求进程。
> 2. 设备驱动程序与设备采用的 IO 控制方式紧密相关，常用的 IO 控制方式是中断驱动方式和 DMA 方式。
> 3. 设备驱动程序与硬件密切相关，对于不同类型的设备，应配置不同的设备驱动程序。目前很多的设备驱动程序都固化在了 ROM 中。
> 4. 设备驱动程序应允许同时多次调用执行。

> [!tip]
> 为了使得所有的设备驱动程序都有同一的接口，要求：
> 1. 每个设备驱动程序与操作系统之间有相同或相近的接口，以便更容易地添加一个新的设备驱动程序，同时更加容易地编制设备驱动程序。
> 2. 要将抽象的设备名转换为具体的物理设备名，并且进一步找到相应的设备驱动程序入口。
> 3. 还应对设备进行保护，方式无权访问的用户使用设备。

## 磁盘和固态硬盘

本章内容与 [[计算机组成原理/存储系统#外部存储器|外部存储器]] 内容相近，主要介绍磁盘。

### 磁盘

磁盘 (Disk) 是表面涂有磁性物质的物理盘片，通过一个称为磁头的导体线圈从磁盘存取数据。在读写期间，磁头固定，磁盘在下面高速旋转。磁盘盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽，一个盘面上有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小，一个扇区称为一个盘块。相邻磁道及相邻扇区通过一定的间隙分隔开，以避免精度错误。

> [!warning]
> 扇区是按照固定圆心角度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。
>
> 为了提高磁盘的存储容量，现代磁盘不再将内外磁道划分为系统数目的扇区，而是将盘面划分为若干环带，同一环带内的所有磁道具有相同的扇区数。在考研中，除非专门提出，否则按照固定圆心角的方式划分扇区。

磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的转轴和用于数据输入、输出的电子设备组成。
- 多个盘片垂直堆叠，组成磁盘组。
- 每个盘片对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同。
- 所有盘片上相对位置相同的磁道组成柱面。
- 扇区是磁盘可寻址的最小单位，磁盘上能存储的物理块数目由扇区数、磁道数及盘片数决定。
- 磁盘的物理地址使用“柱面号-盘片号-扇区号”表示。

> [!example]-
> ![[image/输入输出管理-1.png#center|600]]

> [!note] 磁盘的类型
> 磁盘按不同方式可以分为若干类型：
> - 磁头相对于盘片的径向方向固定的称为固定头磁盘，这种磁盘中的每个磁道有一个磁头。
> - 磁头可移动的称为活动头磁盘，磁头臂可以来回伸缩定位磁道。
> - 盘片永久固定在磁盘驱动器内的称为固定盘磁盘。
> - 盘片可移动和替换的称为可换盘磁盘。

> [!warning] 有一些磁盘中，每个盘片包含上下两个盘面。

#### 磁盘管理

##### 磁盘初始化

一个新的磁盘只是一个记录材料的空白盘。在磁盘可以存储数据之前，必须先将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为**低级格式化**(物理格式化)。每个扇区通常由头部、数据区域和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息，其中利用磁道号、磁头号和扇区号来标识一个扇区，利用 CRC 字段对扇区进行校验。

大多数磁盘在工厂时作为制造过程的一部分就已经低级格式化了，这种格式化能让厂商测试磁盘，并且初始化逻辑块号到无损磁盘扇区的映射。对于许多的磁盘，当磁盘控制器低级格式化时，还能指定在头部和尾部留下多长的数据区，通常选择 256 或者 512 字节。

##### 分区

在可以使用磁盘存储文件之前，还要完成两个步骤：
- 第一步是，将磁盘分区，每个分区由一个或者多个柱面组成，每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。
- 第二步是，对物理分区进行**逻辑格式化**(也称高级格式化)，将初始文件系统数据结构存储到磁盘上，这些数据结构包含空闲空间和已分配空间，以及一个初始为空的目录，建立根目录、对保存空闲磁盘块信息的数据结构进行初始化。

> [!note]
> 因为扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一个簇 (Linux 中也称为块)。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍。如果文件大小小于一簇，也要占用一簇的空间。

##### 引导块

计算机启动时需要运行一个初始化程序，它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存，并转到起始地址，从而开始操作系统的运行。

自举程序通过存放在 ROM 中，为了避免改变自举代码而需要改变 ROM 硬件的情况，通常只在 ROM 中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。

> [!note] 引导块的工作流程
> 引导 ROM 中的代码指示磁盘控制器将引导块读入内存，然后开始执行，它可以从非固定的磁盘位置加载整个操作系统，并且开始运行操作系统。下面以 Windows 为例来分析引导过程：
> 1. Windows 运行将磁盘分为多个区，有一个分区为引导分区，它包含操作系统和设备驱动程序。Windows 将引导代码存储在第 0 号扇区，称为主引导记录 (MBR)。
> 2. 引导程序首先运行 ROM 中的代码，这个代码指示系统从 MBR 中读取引导代码。除了引导代码，MBR 还包含一个磁盘分区表和一个标识 (指示操作系统从哪个分区引导系统)。
> 3. 当系统找到引导分区表时，读取分区的第一个扇区，称为引导扇区，并进行余下的引导过程。

##### 坏块

由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。部分磁盘甚至在出厂时就有坏块。根据所用的磁盘和控制器，对这些块有多重处理方式。
- 对于简单磁盘，例如 IDE 控制器的磁盘，坏块可以手动处理，如 MS-DOS 的 Format 命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在 FAT 表上会标明，因此程序不会使用它们。
- 对于复杂磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已经初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。

#### 磁盘调度算法

> [!note] [[计算机组成原理/存储系统#外部存储器#磁盘的性能指标|磁盘的存储时间]] 分析
> 一次磁盘读写操作的时间由寻道时间、旋转延迟时间和传输时间决定。
> 1. **寻道时间** $T_{s}$。活动头磁盘在读写信息前，将磁头移动到目的磁道需要的时间。这个时间除跨越 $n$ 条磁道的时间外，还包括启动磁头臂的时间 $s$，即 $T_{s}=m\times n+s$，其中 $m$ 是磁盘驱动器速度有关的常数，约为 0.2ms，磁头臂的启动延迟约为 2ms。
> 2. **旋转延迟时间** $T_{r}$。磁头定位到要读写扇区所需的时间，设磁盘的旋转速度为 $r$，则
> $$
> T_{r}=\dfrac{1}{2r}
> $$
> 对于硬盘，典型的旋转速度为 5400 转/分，相当于一周 11.1ms，则 $T_{r}$ 为 5.55ms，对于软盘，其旋转速度为 300~600 转/分，则 $T_{r}$ 为 50~100ms。
> 3. **传输时间** $T_{t}$。从磁盘读出或向磁盘写入数据所需的时间，这个时间取决于每次所读、写的字节数 $b$ 和磁盘的旋转速度 $r$，则
> $$
> T_{t}=\dfrac{b}{rN}
> $$
> 其中 $r$ 为磁盘每秒的转数，$N$ 为一个磁道上的字节数。
>
> 总平均存储时间数 $T_{a}$ 可以表示为
> $$
> T_{a}=T_{s}+\dfrac{1}{2r}+\dfrac{b}{rN}
> $$
>
> 在磁盘的存取时间中，寻道时间占大头，它与磁盘调度算法密切相关。而延迟时间和传输时间磁盘旋转速度线性相关，所以转速是磁盘性能的一个非常重要的硬件参数，也很难从操作系统层面优化。因此，磁盘调度的主要目标是减少磁盘平均寻道时间。

> [!note] 提高磁盘 IO 速度方法
> 文件的访问速度是衡量文件系统性能最重要的因素，可以从以下三个方面来优化：
> 1. 改进文件的目录结构以及检索目录的方法，以减少对目录的查找时间。
> 2. 选取好的文件存储结构，以提高对文件的访问速度。
> 3. 提高磁盘 IO 速度，以实现文件中的数据在磁盘和内存之间快速传送。

目前常用的磁盘调度算法有 4 种。

##### FCFS

FCFS 算法根据进程请求访问磁盘的先后进行调度，这是一种最简单的调度算法。

> [!note] FCFS 算法特点
> - 优点：该算法的优点是具有公平性。
> - 缺点：若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能；若有大量进程竞争使用磁盘，则这种算法在性能上接近随机调度算法。

##### SSIF

最短寻道时间优先算法 (Shortest Seek Time First, SSTF) 算法每次选择调度的是与当前磁头最近的磁道，使每次的寻道时间最短。

> [!note] SSTF 算法特点
> - 优点：SSTF 算法虽然不能保证平均寻道时间最小，但是能够提供比 FCFS 算法更好的性能。
> - 缺点：这种算法会产生饥饿现象。

##### SCAN

扫描算法 (SCAN) 规定，只有磁头移动到最外侧磁道时才能向内移动，移动到最内侧磁道时才能向外移动。它是在 SSTF 算法的基础上规定了磁头的移动方向。由于磁头移动规律与电梯运行相似，因此又称为电梯调度算法。

> [!note] SCAN 算法的特点
> SCAN 算法对最近扫描过的区域不公平，因此它在访问局部性方面不如 FCFS 算法和 SSTF 算法。

##### CSCAN

循环扫描算法 (Circular SCAN, C-SCAN) 算法在 SCAN 算法的基础上规定磁头单向移动来提供服务，返回是直接快速移动至起始端而不服务任何请求。

> [!note] C-SCAN 算法特点
> 由于 SCAN 偏向于处理那些接近最里和最外的磁道的访问请求，因此使用改进的 C-SCAN 算法来避免这个问题。

> [!tip] 在考研中，CSCAN 默认是 LOOK 的，即不需要移动到最边缘。

##### LOOK 与 C-LOOK 算法

基于 SCAN 与 C-SCAN 算法时，磁头总是严格地遵循从盘面的一端到另一端，LOOK 算法与 C-LOOK 算法对其进行改进，磁头只需要移动到最远端的一个请求即可返回，不需要到达磁盘端点。

> [!note] 减少延迟时间的方法
> 除了减少寻道时间外，减少延迟时间也是提高磁盘传输效率的一个重要因素。由于磁盘是连续自转设备，磁头读入一个扇区后，需要经过短暂的处理时间，才能开始读入下一个扇区。若逻辑上相邻的块再物理上也相邻，则读入几个连续的逻辑块可能需要很长的延迟时间。为此，可以对一个盘面的扇区进行交替编号，即让相邻的块物理上保持一定的间隔，于是读入多个磁盘块时能够减少延迟时间。
> 此外，由于磁盘的所有盘面是同步转动的，逻辑块相同的柱面上也是按盘面号连续存放同样的问题，因此可以对不同盘面进行错位命名。

> [!note] 改善磁盘 IO 性能的方法
> 1. 采用磁盘高速缓存：即使用 [[#磁盘高速缓存]] 技术。
> 2. 调整磁盘请求顺序：即使用 [[#磁盘调度算法]]。
> 3. 提前读：在读磁盘当前块时，将下一个磁盘块也读入内存缓冲区。
> 4. 延迟写：仅在缓冲区首部设置延迟写标识，然后释放此缓冲区并将其链入空闲缓冲区链表的尾部，当其他进程申请到此缓冲区时，才真正将缓冲信息写入磁盘块。
> 5. 优化物理块的分布。包括上述的盘区编号优化，当文件采用链接方式和索引方式组织时，应尽量将同一个文件的盘块安排在同一个磁道上或者相邻的磁道上，以减少寻道时间。此外，还有将若干盘块组成簇，按簇对文件进行分配，也可以减少磁头的平均移动距离。
> 6. 采用磁盘阵列 RAID。见 [[计算机组成原理/存储系统#磁盘阵列|磁盘阵列]]，由于采用并行交叉存取，因此能够大幅度提高磁盘的 IO 速度。

### 固态硬盘

见 [[计算机组成原理/存储系统#固态硬盘|固态硬盘]]。

---
< [[操作系统/文件管理|文件管理]] |
