---
aliases:
  - operator system
  - os
tags:
  - 操作系统
  - 概述
cssclasses:
  - table-center
---

# 操作系统基本原理概论

计算机系统自上而下可以大致分为 4 部分；硬件、操作系统、应用程序和用户。操作系统管理各种硬件，为应用程序提供基础，并且充当计算机硬件与用户之间的中介。

**操作系统**(Operating System, OS) 是指控制和管理整个计算机系统的硬件和软件资源，合理地组织、调度计算机的工作和资源的分配，进而为用于和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。

## 操作系统的特征

操作系统是一种系统软件，但是与其他的系统软件和应用软件有很大的不同，具有自己的特殊性。操作系统的基本特征包括**并发、共享、虚拟和异步**。

> [!example] 操作系统的功能
> 为了给多道程序提供良好的运行环境，操作系统应该具有以下功能：处理机管理、存储器管理、设备管理和文件管理。同时，为了方便用户使用操作系统，还必须向用户提供接口。具体的，操作系统应该具有如下能力
> 1. 管理系统资源：
> 	- 处理机管理：即对进程进行管理，包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。
> 	- 存储器管理：为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，包括内存的回收与分配、地址映射、内存保护和共享、内存扩充等。
> 	- 文件管理：计算机中的信息都是以文件的形式存在的，操作系统负责文件管理的部分称为文件系统，包括文件存储空间的管理、目录管理、文件读写管理和保护等。
> 	- 设备管理：完成用户的 IO 请求，方便用户使用各种设备，提高设备的利用率，包括缓冲管理、设备分配、设备处理和虚拟设备等。
> 2. 作为用户与计算机硬件系统之间的接口：
> 	- 命令接口：用户利用这些操作系统命令来组织和控制作业的执行。主要方式有联机控制方式和脱机控制方式，按照作业控制方式的不同还可以将命令分为联机命令接口和脱机命令接口。
> 	- 程序接口：编程人员可以使用程序接口来请求操作系统服务。
> 3. 实现对计算机资源的扩充：
> 	- 没有任何软件支持的计算机称为裸机，它仅是构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。我们通常将覆盖软件的机器称为扩充机器或者虚拟机。

> [!note] 操作系统提供的接口
> - 联机命令接口，又称为交互式命令接口，适合用于分时或者实时系统的接口，由一组键盘操作命令组成。我们常见的终端就是一个使用联机命令接口的软件。
> - 脱机命令接口，又称为批处理命令接口，适合用于批处理系统，它由一组作业控制命令组成，脱机用户不能直接干预作业的运行，而是事先用相应的作业控制命令写成一份作业控制命令序列。我们常见的就是 bash 脚本。

### 并发

> [!definition|Definition] 并发
> 两个或者多个事件在同一时间间隔内发生。这些事件在*宏观上是同时发生的*，但是在*微观上是交替发生的*。

> [!note] 与并发相近的概念还有**并行**，是并行是指两个或者多个事件在同一时刻同时发生。

操作系统的并发性指计算机系统中同时运行着多个程序，这些程序在宏观上是同时运行着的，而微观上看是交替运行的。实现操作系统并发性的一个重要的方式是通过 [[进程管理]]。

> [!example] 从并行与并发的定义可以看出
> 1. 对于单核 cpu，同一时刻只能执行一个程序，多个程序只能并发的执行。
> 2. 对于多核的 cpu，同一时刻可以同时执行多个程序，即多个程序可以并行的执行。每个程序在不同的核心上同时执行。

### 共享

> [!definition|Definition] 共享
即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

资源共享可以分为互斥共享和同时共享两种方式：
- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源。
- 同时共享方式：系统中的某些资源，允许同一时间段内由多个进程同时对它们进行访问。

> [!note] 临界资源
> 我们将同一段时间只允许一个进程访问的资源称为**临界资源**。计算机系统中大多数的物理设备及某些软件使用的栈、变量和表格都属于临界资源。

> [!warning] 微观上的区别
> - 互斥共享要求一种资源在一段时间内 (哪怕是很短的一段时间) 只能满足一个请求，*例如打印机在开始打印一个文档后，直到这次打印完成都不能满足其他的请求*。
> - 同时共享方式允许多个进程并发的进行访问，而在微观上仍然是交替的访问资源。*例如，一个资源可以分为多个时间片间隔的进行访问，其效果与连续完成的效果相同*。

> [!note] 共享性和并发性
> 并发和共享是操作系统最基本的两个特征，两者之间互为存在的条件。
> 1. 资源共享是以程序的并发为条件的。
> 2. 若系统不能对资源进行有效的管理，则难以执行并发。

### 虚拟

> [!definition|Definition] 虚拟
把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

用于实现虚拟的技术称为**虚拟技术**，操作系统中的虚拟技术主要有两种：
- 时分复用技术：如虚拟处理器，通过多道程序设计技术，让多道程序并发执行，来分时使用一个处理器。
- 空分复用技术：如虚拟存储器，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。

> [!seealso] 虚拟设备技术
> 虚拟设备技术将一台物理 IO 设备虚拟为多台逻辑上的 IO 设备，并允许每个用户占用一台逻辑上的 IO 设备，使原来仅允许在一段时间内由一个用户访问的设备变为在一段时间内允许多个用户同时访问的共享设备。

### 异步

> [!definition|Definition] 异步
在多道程序环境下，运行多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，可能由于其他的进程被阻塞。

> [!note] 异步与并发的关系
> 进程以不可预知的速度向前推进。何时执行、何时暂停、何时完成都是未知的，这就造成了系统的异步性。同样，异步建立在并发的基础上的。

## 操作系统的发展

### 手工操作阶段

程序员通过在纸带上打孔的方式编写程序，计算机通过读取纸带的方式运行程序，并将输出结果也打印到纸带上得到运行的结果。*这个阶段没有形成操作系统*。

> [!note] 手工操作阶段的特点
> 1. 用户独占全机，资源利用率极低。
> 2. CPU 等待手工操作，CPU 利用不充分。

### 批处理系统

为了解决人机矛盾以及 CPU 和 IO 设备之间速度不匹配的问题，出现了处理系统。

#### 单道批处理系统

为了实现对作业的连续处理，需要先将一批作业以脱机的方式输入磁带，并在系统中配上*监督程序*(Monitor)，在监督程序的控制下，这批作业可以一个接一个的处理。

> [!note] 单道批处理系统的特点
> 1. 自动性：在顺利的情况下，磁带上的一批作业能够自动地逐个运行。
> 2. 顺序性：磁带上的各道作业顺序进入内存，先调入内存的作业先完成。
> 3. 单道性：内存中仅有一道程序运行，当程序完成或者发生异常时，才换入其后继程序进入内存运行。

相比于手工操作阶段，单道批处理系统缓解了一定程度的人机速度矛盾，资源利用率有所提升。但是内存中仅能有一道程序运行，只有该程序运行结束后才能调用下一道程序，CPU 有大量的时间是在等待 IO 完成，资源利用率仍然很低。

#### 多道批处理系统

用户提交的作业都先存放在外存上排成一个队列，作业调度程序按一定的算法从后备队列中选择若干作业调入内存，它们在管理程序的控制下相互穿插地运行，共享系统重的各种资源。

> [!tip] 
> 在多道批处理系统中，某个程序由于请求 IO 操作而暂停运行时，CPU 便立即转去处理另一道程序。具体的实现方式可以参考[[操作系统/进程管理#进程控制|进程管理]]。这种方式让系统的各个组成部分都尽可能的忙，因为切换任务所花费的时间很少，因此可以实现系统各个部件之间的并行工作。

> [!note] 多道批处理系统的特点
> 1. 多道：计算机内存中同时存放多道相互独立的程序。
> 2. 宏观上并行：同时进入系统的多道程序都处理运行过程中，但是都未运行完毕。
> 3. 微观上串行：内存中的多道程序轮流占用 CPU，交替执行。

> [!note] 多道批处理系统的优缺点
> - 优点：
> 	- 资源利用率高，多道程序共享计算机资源，从而使得各种资源充分利用。
> 	- 系统吞吐量大，CPU 和其他资源保持忙碌的状态。
> - 缺点：
> 	- 不提供人机交互的能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。

### 分时操作系统

在分时操作系统中，计算机以时间片为单位轮流为各个用户、作业服务，各个用户可以通过终端与计算机交互。若一个用户的作业在分配给它的时间片内不能完成其计算，则该作业暂停运行，将处理器让给其他作业使用，等待下一轮再继续运行。

在分时操作系统中，用户的请求可以被及时响应，解决了人机交互的问题，运行多个用户同时使用一台计算机，并且用户对计算机的操作独立，感受不到其他人的存在。

> [!note] 
> 分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以与主机进行交互操作而互不干扰。
> 
> 分时系统也是支持多道程序设计的系统，但是它与多道批处理系统不同，是实现人机交互的系统。

> [!note] 分时操作系统的特征
> 1. 同时性：也称为多路性，允许多个终端用户同时使用一台计算机。
> 2. 交互性：用户通过终端采用人机对话的方式直接控制程序运行，与程序进行交互。
> 3. 独立性：系统中多个用户可以彼此独立进行操作，互不干扰。
> 4. 及时性：用户请求可以在很短的时间内获得响应。

> [!note] 分时操作系统的缺点
> 分时操作系统的设计导致了不能优先处理一些紧急任务，操作系统对每个用户、作业都是完全公平的，循环地为每个用户、作业服务一个时间片，不区分任务的紧急性。

### 实时操作系统

在一些特定的情景下，需要优先响应一些紧急任务，因此提出了实时操作系统。实时操作系统能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。

在实时操作系统的控制下，计算机系统接受到外部信号后及时进行处理，并且要在严格的时限内处理完事件，实时操作系统的主要特点是及时性和可靠性。

实时操作系统有分为两种：
1. 硬实时系统：必须在绝对严格的规定时间内完成，如飞行棋的飞行自动控制系统。
2. 软实时系统：能接受偶尔违反时间，如飞机订票系统、银行管理系统。

> [!note] 实时操作系统的特点
> 实时操作系统的主要特点是及时性和可靠性。

### 其他操作系统

- 网络操作系统：将计算机网络中的各台计算机有机集合起来，提供一种统一、经济而有效的使用各台计算机的方式。
- 分布式计算机系统：由多台计算机组成，并且满足以下条件的系统称为分布式计算机系统
	- 系统中的每台计算机都具有同等的地位，没有主机与从机；
	- 每台计算机上的资源为所有用户共享；
	- 系统中的任意台计算机都可以构成一个子系统，并且还可以重构；
	- 任何工作都可以分布在几台计算机上，由它们并行工作、协同完成；
- 个人计算机操作系统：个人计算机操作系统是目前使用最广泛的操作系统，广泛用于文字处理、电子表格、游戏中，常见的有 Windows, Linux 和 MacOS 等。
- 此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。

> [!note] 网络操作系统与分布式计算机系统的区别
>- 网络操作系统的主要特点是网络中各种资源的共享和每台计算机之间的通信
>- 分布式计算机系统的主要特点：分布性和并行性

## 操作系统的运行环境

### 处理器运行模式

在计算机系统中，通常 CPU 执行两种不同性质的程序
- 操作系统内核程序：内核程序是用于实现操作系统的控制功能的程序，很多的内核程序组成了**操作系统内核**，简称为**内核**。内核是操作系统中最核心的部分，也是最接近硬件的部分，甚至可以说，一个操作系统只需要有内核就可以了。
- 应用程序：即用户自编的程序。

> [!note] 特权命令
> 操作系统的内核作为管理者，有时可以让 CPU 执行一些特权指令：
> - 特权命令：不允许用户直接使用的命令，如 IO 指令、关中断指令、内存清零指令等。
> - 非特权指令：允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间。

#### 内核态与用户态

CPU 的运行模式划分用户态 (目态) 和内核态 (管态、核心态)：
- 内核态：处于内核态，说明此时正在运行的是内核程序，此时可以执行特权指令。
- 用户态：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令。

> [!note] 在 CPU 中，有一个寄存器叫做程序状态字寄存器 (PSW)，其中有一个二进制位，1 表示内核态，0 表示用户态。用户态也称为目态，内核态也称为核心态或者管态。

内核态与用户态的切换过程一般如下：
- 在内核态切换为用户态时，执行一条特权指令，并修改 PSW 的标志位为用户态，这个动作意味着操作系统将主动让出 CPU 使用权。
- 用户态切换为内核态一般由中断信号触发，硬件自动完成变态过程，触发终端信号意味着操作系统将强行夺回 CPU 的使用权。

#### 操作系统内核的功能

1. 时钟管理：在计算机的各种部件中，时钟是关键设备，其功能包括：
	- 计时：通过时钟管理，向用户提供标准的系统时间
	- 进程切换：通过时钟中断的管理，可以实现进程的切换。*例如，在分时操作操作系统中采用时间片轮转调度、实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等*。
2. 中断机制：中断机制是操作系统中各项操作的基础，例如 IO 输入、进程管理调度、系统功能的调用、驱动设备、文件访问等。可以说，现代操作系统就是靠中断驱动的软件。
3. 原语：操作系统底层可以被调用的公用小程序，它们各自完成一个规定的操作。其定义方法是先关中断，让所有的动作不可分割地完成后，再打开中断。一个原语具有如下特点：
	- 处理操作系统的底层，是最接近硬件的部分；
	- 具有原子性，操作只能一气呵成；
	- 运行时间较短，调用频繁；
4. 系统控制的数据结构及处理：操作系统实现了登记了状态信息的数据结构，例如作业控制块、进程控制块 (PCB)，设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。

### 中断和异常

在合适的情况下，操作系统内核会将 CPU 的使用权主动让给应用程序。中断时让操作系统内核夺回 CPU 使用权的唯一途径。中断会使 CPU 由用户态变为内核态，是操作系统重新夺回对 CPU 的控制权。

> [!definition|中断] 也称为外中断，是指来自 CPU 执行指令外部事件，通常用于信息输入和输出，如设备发出 IO 结束中断、时间片结束发出时钟中断等。

> [!definition|异常] 也称内中断，是指来自 CPU 执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚拟系统的缺页以及专门的陷入指令等引起的事件。**异常不能被屏蔽，一旦出现就要立即处理**。

> [!tip] 如果没有中断机制，一旦应用程序在 CPU 上运行，就会一直运行这个应用程序。

> [!note] 中断和异常的分类
> - 内部异常
> 	- 故障 (Fault)：通常由指令执行引起的异常，如非法操作码、缺页故障、除 0 等。
> 	- 自陷 (Trap)：是一种事先安排的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令、系统调用指令等。
> 	- 终止 (Abort)：出现了使得 CPU 无法继续执行的硬件故障，如控制器出错、存储器校验错等。
> - 外部中断 (硬件)
> 	- 可屏蔽中断 INTR：通过 INTR 线发出的中断请求
> 	- 不可屏蔽中断 NMI：通过 NMI 线发出的中断请求，通常是紧急的硬件故障

> [!note] 中断和异常的处理过程
> 当 CPU 在执行用户程序的第 i 条指令时检测到一个异常事件，或在执行第 i 条指令后发现一个中断请求信号，则 CPU 打断当前用户程序，然后转到相应的中断或异常处理程序去执行。
> - 若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU 通过执行中断或异常返回指令，回到被打断的用户程序的第 i 条指令或者第 i+1 条指令继续执行。
> - 若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。

> [!tip] 在计算机组成原理中，我们会对[[计算机组成原理/输入输出系统#程序中断方式|程序中断]]进行更加详细的讨论。

### 系统调用

应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统内核统一掌管，因此**凡是与共享资源有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求**，由操作系统代为完成。这样可以保证系统的稳定性和完整性，防止用户非法操作。

将系统调用按照功能分类，可以分为：
1. 设备管理：完成设备的 请求/释放/启动 等功能。
2. [[操作系统/文件管理|文件管理]]：完成文件的 读/写/创建/删除 等功能。
3. 进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能。
4. 进程通信：完成进程之间的 消息传递/信号传递 等功能。
5. [[操作系统/内存管理|内存管理]]：完成内存的 分配/回收 等功能。

> [!note] 系统调用的过程：
> 1. 当应用程序需要进行系统调用时：
> 	1. 需要先执行传参指令，将相关的系统调用号和所需的参数压入堆栈；
> 	2. 调用实际的调用指令；
> 	3. 执行一个陷入指令，该陷入指令的执行引发了一个内中断，将 CPU 状态从用户态转换到内核态，CPU 会暂停执行应用程序，由硬件和操作系统内核程序保护中断进程的现场，将程序计数器 (PC)、程序状态字 (PSW) 以及通用寄存器内容等压入堆栈；
> 2. 通过系统调用号可以找到对应的系统调用处理子程序的入口地址。该程序将会检查寄存器中的参数，其中第一个参数指明系统调用的类型，还可以由更多的参数用于其他功能。
> 3. 系统调用执行完毕后，cpu转为用户态，交给应用程序计算。

> [!warning] 
> - 陷入指令是在用户态下执行，执行陷入指令后将会引发一个内中断，此时 CPU 进入核心态。
> - 发出系统调用请求是在用户态中，而对系统调用的相应处理是在核心态中。

> [!tip] 陷入指令也可称为trap指令或者访管指令。

## 操作系统结构

随着操作系统功能的不断增多和代码规模的不断扩大，提供合理的结构，对于降低操作系统复杂度、提升操作系统安全与可靠性来说变得尤为重要。

### 分层法

分层法将操作系统分为若干层，低层 (0 层) 为硬件，顶层 (第 N 层) 为用户接口，每层只能调用紧邻它的低层的功能和服务^[也叫做单向依赖]。

> [!note] 分层法的优点
> 1. 便于系统的调试和验证，简化了系统的设计和实现。*第一层可以先调试而无需考虑其他部分，因为它只使用了基本的硬件。第一层调试完且验证正确之后，就可以调试第 2 层，如此向上。如果在调试某层时发现了错误，那么错误就应该在这一层上，因为它的低层次都调试好了。*
> 2. 易扩充和易维护。*在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应的层间的接口，就不会影响其他层。*

> [!note] 分层法的缺点
> 1. 合理定义各层比较困难。*因为依赖关系固定后，往往显得不够灵活。*
> 2. 效率较差。*操作系统每执行一个功能，通常要自上而下地穿越多层，各层之间都有相应的层间通信机制。*

### 模块化

模块化是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某个方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口通信。

> [!note] 还可以进一步将各模块细分为若干具有一定功能的子模块，同时也规定好子模块之间的接口。这种设计方法称为模块-接口法。

> [!note] 衡量模块独立性的标准
> 在划分模块时，如果将模块划分得太小，会使得模块之间的联系过多，造成系统比较混乱；如果模块划分得太大，又会增加模块内部的复杂度。我们需要再两者之间权衡。
> - 内聚性：模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。
> - 耦合性：模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。

> [!note] 模块化的优缺点
> - 优点： 
> 	- 提高了操作系统设计的正确性、可理解性和可维护性。
> 	- 增强了操作系统的可适应性。
> 	- 加速了操作系统的开发过程。
> - 缺点：
> 	- 模块间的接口规定很难满足对接口的实际需求。
> 	- 各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确确定的基础上。

### 宏内核

宏内核，也称单内核、大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。由于各管理模块之间共享信息，能够有效利用相互之间的有效特性，所以具有无可比拟的性能优势。

> [!tip] 目前主流的操作系统，如 Windows, Android, IOS, MacOS, Linux 等都是基于宏内核的架构。

> [!note] 宏内核的特点
> - 优点：性能高，内核内部各种功能都可以相互调用。
> - 缺点：
> 	- 内核庞大，功能复杂，难以维护；
> 	- 大内核中某个功能模块出错，可能会导致整个系统崩溃；

> [!example]-
> ![[image/操作系统基本原理概论-1.png#center|宏内核|400]]

### 微内核

微内核架构指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。

被移出内核的操作系统代码根据分层的原则被划分为若干服务程序，它们的执行相互独立，交互都借助于微内核进行通信。

> [!note] 微内核的基本功能
> 1. 进程管理：进程之间的通信是微内核 OS 最基本的功能，此外还有进程的切换、进程的调度，以及多处理机之间的同步等功能，都应该放入微内核中。
> 2. 低级存储器管理：在微内核中只配备最基本的低级存储器管理机制，例如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核中。*实现虚拟存储管理的策略，例如采取的页面置换算法、采用的内存分配、回收策略等应该放入微内核外的存储管理服务器中。*
> 3. 中断和陷入处理：微内核 OS 将与硬件密切相关的一小部分放入微内核，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理。*在识别中断或陷入的事件后，再发送给相关的服务器进行处理。*

> [!note] 微内核的特点
> - 优点：
> 	- 拓展性和灵活性：许多的功能从内核中分离出来，当要修改某些功能或增加新功能时，只需要在相应的服务器中修改或新增功能，或者增加一个专用的服务器即可。
> 	- 可靠性和安全性：较小的内核更加易于维护，可靠性更高。
> 	- 可移植性：与 CPU 和 IO 硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因此将操作系统移植到另一个平台上所需的修改是比较小的。
> 	- 分布式计算：客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这使得微内核可以很好的支持分布式系统和网络系统。
> - 缺点：
> 	- 性能低，需要频繁的切换用户态和核心态，操作系统的执行开销大。
> 	- 用户态下的各个功能模块不能相互调用，而需要通过消息传递的方式来间接通信。

> [!example]-
> ![[image/操作系统基本原理概论-2.png#center|微内核|400]]

### 外核

外核的任务是为虚拟机分配资源，并检查这种资源使用的安全性，以确保没有机器会使用他人的资源。每个用户的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并获得分配的那部分资源。

外核独立于内核，可以在不将磁盘资源映射为页表等逻辑资源的情况下，交给用户分配。用户可以得到完整的磁盘资源。

> [!note] 外核的特点
> - 优点：
> 	- 可以直接给用户分配*不虚拟，不抽象*的硬件资源，使得用户可以更加灵活的使用硬件资源。
> 	- 减少了虚拟硬件的映射层，提高效率。
> - 缺点：
> 	- 降低了系统的一致性。
> 	- 使得系统更加复杂。

## 操作系统引导

操纵系统是一种程序，程序以数据的形式存放在硬盘中，而硬盘通常分为多个区，一台计算机中又可能有多个或者多种外部存储设备。**操作系统引导**指计算机利用 CPU 运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统的过程。

> [!note] 常见操作系统的引导过程
> 1. **激活 CPU**：激活 CPU 读取 ROM 中的 boot 程序，将指令寄存器置为 BIOS 的第一条指令，即开始执行 BIOS 的指令。
> 2. **硬件自检**：BIOS 程序在内存最开始的空间构建中断向量表，接下来的 POST 过程可能要用到中断功能。然后进行通电自检，检查硬件是否出现故障，如果有故障，主板会发出不同含义的蜂鸣，启动终止。
> 3. **加载带有操作系统的硬盘**：通电自检后，BIOS 开始读取 Boot Sequence (通过 CMOS 中保存的启动顺序，或者通过与用户交互的方式^[例如 linux 系统中的 grub 引导程序])，将控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中。
> 4. **加载主引导记录 (MBR)**：硬盘以特定的标识符区分引导硬盘和非引导硬盘，如果发现一个存储设备不是可引导盘，就去检查好下一个存储设备。如果没有启动设备，就会死机。(主引导记录 MBR 的作用是告诉 CPU 去硬盘的那个主分区找操作系统)
> 5. **扫描硬盘分区表，并加载硬盘活动分区**。MBR 包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区，主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。
> 6. **加载分区引导记录 (PBR)**：读取活动分区的第一个扇区，这个扇区称为分区引导记录 (PBR)，其作用是寻找并激活分区根目录下用于引导操作系统的程序。(启动管理器)
> 7. **加载启动管理器**：分区引导记录搜索活动分区中的启动管理器，加载启动管理器。
> 8. **加载操作系统**：将操作系统的初始化程序加载到内存中执行。

> [!tip] 名词汇总
> - ROM：主存的一部分，通常在主板上，存储 BIOS 程序，不会随着断电导致数据消失。
> - BIOS：我们常说的 BIOS 实际上是 Basic Input/Output System 的缩写。
> - MBR：主引导记录，保存在磁盘的最开始部分，包含磁盘引导程序和分区表。我们在读取磁盘时，要先读入 MBR，然后使用磁盘引导程序和分区表找到对应的分区。
> - PBR：分区引导记录，保存在分区的最开始部分，是一个用于找到启动管理器的程序。
> - 启动管理器：用于初始化操作系统的程序。

## 虚拟机

虚拟机指用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。由两类虚拟化方法。
1. 第一类虚拟机管理程序：第一类虚拟机管理程序直接运行在硬件上，类似一种操作系统。它将总的硬件资源划分为多个部分，供多个不同的虚拟机使用，这些虚拟机就像进程一样，使用虚拟机管理程序划分出来的时间片。
2. 第二类虚拟机管理程序：第二类虚拟机管理程序是运行在一个宿主操作系统上的一个应用程序，由宿主操作系统分配和调度资源，就像一个普通的进程。

> [!note] 第一类虚拟机管理程序
> 在该类别中，虚拟机作为用户态的一个进程运行，不允许执行敏感指令。但是在虚拟机看来，自己是运行在内核态的，称为虚拟内核态。当虚拟机需要执行一些敏感指令时，会由虚拟机管理程序安排这条指令的执行，即模拟类似的行为，而不是执行真正的敏感指令。

> [!note]- 两类虚拟机管理程序的特点
> | 对比        | 第一类虚拟机管理程序                            | 第二类虚拟机管理程序                                           |
> | :-------- | :------------------------------------ | :--------------------------------------------------- |
> | 对物理资源的控制权 | 直接运行在硬件之上，能直接分配和控制分配物理资源              | 运行在宿主操作系统上，依赖于宿主操作系统分配物理资源                           |
> | 资源分配方式    | 安装虚拟机时，管理系统要在原本的硬盘上自行分配存储空间，类似外核的分配方式 | 每个虚拟机拥有自己的虚拟磁盘，该磁盘实际上是宿主文件系统中的一个大文件                  |
> | 性能        | 性能更好                                  | 性能更差、需要宿主操作系统作为中介                                    |
> | 可支持的虚拟机数量 | 更多，不需要和宿主操作系统竞争资源，相同的硬件可以支持更多虚拟机      | 更少，宿主操作系统本身也要使用资源，其他的进程也要也要使用资源                      |
> | 虚拟机的可迁移性  | 更差                                    | 更好，只需要导出虚拟机镜像文件就可以迁移到另一个宿主操作系统上                      |
> | 运行模式      | 运行在最高特权级，可以执行较高特权的指令                  | 部分运行在用户态，部分运行在内核态，虚拟机发出的系统调用会被管理系统截获，并被转换为管理系统中的系统调用 |

| [[操作系统/进程管理|进程管理]] >