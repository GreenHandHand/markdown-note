---
tags:
  - 数据库
---

# 关系数据库标准语言SQL

## SQL简介

结构化查询语言SQL是一种介于关系代数与关系演算之间的语言，是一个通用的、功能极其强的 [[数据库/关系数据库|关系数据库]] 语言，是关系数据库的标准语言。

SQL语言集数据定义、数据查询、数据操纵和数据控制于一体，充分体现了关系数据语言的特点和优点

SQL语言的版本包括：

* SQL-86、SQL-89、SQL-92(SQL2)
* SQL-99(SQL3)增加了面向对象的概念
* SQL2003(SQL4)
* SQL2008

## SQL语言支持数据库的三级模式结构

* 关系模式称为基本表，基本表的集合形成数据库模式，对应着模式
* 基本表在物理上与储存文件相对应，所有储存文件的集合为物理数据库，对应着内模式
* 外模式由视图组成

### 基本对象

* 基本表：独立存在的表
* 储存文件：对最终用户透明
* 视图：由一个或多个基本表导出，不实际存在，虚表
* 索引：一个表可以带若干索引，索引存放在储存文件中

### SQL的数据定义

关系数据库系统的基本对象有模式、表、视图和索引

|       | 创建          | 删除        | 修改        |
| :---: | ------------- | ----------- | ----------- |
| 模式  | CREATE SCHEMA | DROP SCHEMA |             |
|  表   | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图  | CREATE VIEW   | DROP VIEW   |             |
| 索引  | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

在SQL中，一个SQL模式由模式名、权限标识符合模式中元素的描述符组成

* 权限标识符指明拥有该模式的用户或账号
* 模式元素包含一个数据库应用的表、视图和索引等
* 属于同一个应用的表、视图和索引等可以定义在同一个模式中

#### 模式的定义和删除

在定义模式时可以先给出模式名和权限标识符，以后再定义其中的元素，语法格式：**CREATE SCHEMA <模式名> AUTHORIZATION <用户名>**

* 如果没有指定模式名，则隐含为用户名
* 可以在创建模式的同时在模式定义中进一步创建基本表、视图、定义授权等

  ```sql
  CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义子句> | <视图定义子句> | <授权定义子句>]
  ```

删除模式语句：

```sql
DROP SCHEMA <模式名> [CASCADE | RESTRICT]
```

* CASCADE(级联式)方式
  * 表示在删除模式的同时把该模式中所有的数据库对象全部一起删除
* RESTRICT(限制式)方式（默认）
  * 表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行

#### 表的定义、修改与删除

##### 1. 定义基本表

```sql
CREATE TABLE <表名>
    (<列名><数据类型>[<列级完整性约束条件>],
     <列名><数据类型>[<列级完整性约束条件>],
     ...
     [<表级完整性约束条件>], [<表级完整性约束条件>]...);
```

* 表名：所要定义的基本表的名字
* 列名：组成该表的各个属性（列）
* 列级完整性约束条件：涉及相应属性列的完整性约束条件
* 表级完整性约束条件：涉及一个或者多个属性列的完整性约束条件
* CONSTRAINT子句定义列级或表级约束，其格式为 `CONSTRAINT<`约束名> <约束>`
* 在SQL2中增加了定义域的语句，可以用域名代替指名列的数据类型
* 域定义语句的格式为：
  `CREATE DOMAIN <域名> <数据类型>`
* 在定义基本表时，表所属的数据库模式一般被隐式指定，也可以显示地在定义表时指定表所属的数据库模式名
  * 例：CREARE TABLE SST.Student指定学生表所在的模式为学生数据库模式SST

##### 2. 修改基本表

```sql
ALTER TABLE <表名>
    [ADD <列名> <数据类型> [<完整性约束>]]
    [DROP <列名> [CASCADE | RESTRICT]]
    [ALTER <列名> <数据类型>];
```

* ADD字句用于增加新列，包括列名、数据类型和列级完整性约束
* DROP子句用于删除指定的列名
  * CASCADE表示删除列时自动删除引用该列的视图和约束
  * RECTRICT表示没有视图和约束引用时才能删除该列，否则将拒绝删除操作
* ALTER子句用于修改列的定义，如修改列的数据类型或修改列的宽度

##### 删除基本表

```sql
DROP TABLE <表名> [RESTRICT | CASCADE];
```

* 若选择RESTRICT，则删除的基本表不能是由FOREIGN KEY约束引用的表，不能有视图，不能有触发器，不能有存储过程和函数等。如果存在这些依赖该表的对象，则此表不能被删除
* 如选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图等都被一起删除。
* 缺省的情况下，默认为RESTRICT

##### 索引的建立、修改与删除

索引时一种数据结构，可以提高查询速度，大型关系数据库中的索引的实现技术是数据库管理系统实现总最重要的核心问题

建立索引是加快查询速度的有效手段

* 可根据需要在一个表上建立一个或多个索引，以提供多种存取路径，加快查找速度。也可以不建。
* 建立索引
  * DBA或表的属主（即建立表的人）根据需要建立
  * 有些DBMS自动建立以下列的索引：PRIMARY KEY, UNIQUE
* 维护索引：DBMS自动完成
* 使用索引：系统在存取数据时会自动选择是否使用索引以合适的索引作为存取路径，用户不必也不能选择索引

###### 建立索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
    ON <表名> (<列名> [<次序>], [<列名>[<次序>]]...);
```

* 表名：指定要建索引的基本表名字
* 索引可以建立在该表的一列或多列上，各列名之间用逗号分隔
* 次序指定索引值的排列次序，升序ASC，降序DESC。缺省值：ASC
* UNIQUE表明此索引值只对应唯一的数据记录
* CLUSTER表示要建立的索引时聚簇索引
  * 根据索引的顺序和数据库的物理存储属性是够相同，索引分为聚簇索引、非聚簇索引
    * 聚簇索引：对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚簇索引与数据是混为一体的，它的叶节点中存储的是实际的数据
    * 非聚簇索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置
    * 一个表中只能包含一个聚簇索引，但该索引中可以包含多个列，使用于很少对基表进行增删操作，很少对其中的变长列进行修改操作，该方法对于经常要搜索范围值的列特别有效。

###### 修改索引

```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

###### 删除索引

```sql
DROP INDEX <索引名>
```

###### 索引选择

* 索引为性能所带来的好处：
  * 对某个属性使用索引能极大提高对该属性上的值的检索效率，使用到该属性时，还可以加快连接
* 索引的代价：
  * 带索引的表在数据库中会占据更多的空间
  * 维护索引的代价，对世界进行插入、更新、删除操作的命令所花费的时间会更长
* 应评估两个因素：数据的性质和基于表的查询的性质，来决定是否创建索引，应确保对性能的提高程度大于在储存空间和处理资源方面的代价。

## SQL数据操作

### 查询

一般结构：

```sql
SELECT [ALL|DISTINCT] <目标列表达式> |
```

数据查询是数据库的核心功能

基本结构：

```sql
SELECT A1, A2, ... ,An FROM R1, R2, ..., Rn WHERE P;
```

相当于：$\Pi_{A_1,A_2,\dots,A_n}(\sigma_P(R_1\times R_2\times\dots\times R_n))$

#### 单表查询

查询仅涉及一个表，是一种最简单的查询操作

* 选择表中的若干列
* 选择表中的若干元组

SELECT语句中的查询目标不仅可以是属性列，还可以是表达式，即可以查询经过计算的值

* 表达式可以是算术表达式，字符串常量，函数，列别名等

##### 条件语句

1. 在WHERE字句中的比较条件中使用比较运算符：

   * =, >, <, >=, <=, !=
2. 使用谓词 BETWEEN ... AND ... 或者 NOT BETWEEN ... AND ...
3. 确定集合，使用谓词 IN \<值表\>, NOT IN \<值表\>
   值表：用逗号分隔的一组取值
4. 字符串匹配：

   ```sql
   [NOT] LIKE '<匹配串>' [ESCAPE '<换码字符>']
   ```

   * 匹配串：指匹配模板
     固定模式
   * ESCAPE 短语：
     当用户要查询的字符串本身就具有%或 _ 时，要使用ESCAPE
5. 涉及空值的查询：
   使用 IS NULL 和 IS NOT NULL，不能使用= NULL
   空值：SQL允许属性有一个特殊值NULL称为空值，该值常用于表述未知值、不适用值与无权限值
   空值不等同于空白或零值，没有两个相等的空值，空值和任何值进行算术运算，结果仍为空值，使用空值进行逻辑计算得到的结果为UNKNOWN
   空串指零长度的字符串

##### 对查询结果进行排序

使用ORDER BY 子句，升序ASC，降序DESC；缺省值为升序

空值将作为最大值排序：ASC排序后空值最后显示，DESC排序后空值最先显示

##### 使用聚集函数

##### 对查询结果进行分组

使用GROUP BY子句分组

* 细化聚集函数的作用对象
  1. 未对查询结果分组，聚集函**数将作用于整个查询结果
  2. 对查询结果分组后，聚集函数将分别作用于每一个组
* 分组方法：按指定的一列或者多列值分组，值相等的为一组
  * 使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和聚集函数
* GROUP BY子句的作用对象是查询的中间结果表
* 使用HAVING短语筛选最终输出结果
  * 只有满足HAVING短语指定条件的组才输出

#### 连接查询

同时涉及多个表的查询称为连接查询

##### 广义笛卡尔积

不带连接谓词的连接

广义笛卡尔积是两表元组的交叉乘积，其连接的结果会产生没有意义的元组，基本上用不到

##### 等值连接与非等值连接

等值连接、自然连接、非等值连接

* 等值连接
  * 连接运算符为 = 的连接操作
* 非等值连接
  * 比较运算符
* 自身连接
  * 一个表与其自己进行连接，称为表的自身连接
  * 需要给表起别名以示区别
  * 由于所有属性名都是同名属性，因此必须使用别名前缀
* 外连接
  * 内连接操作只输出满足连接条件的元组，外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出
  * 外连接通过非主体表中的虚行实现，该行全部由空值组成。
* 复合条件连接
  * WHERE子句中含有多个连接条件时，称为复合条件连接，复合条件连接可以看作普通连接后得到的关系表又进行一次选择运算
  * 多表连接：连接操作可以是多个表的连接

### 嵌套查询

将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询

嵌套查询的实现一般是从里到外，即先进行了子查询，在把其结果用于父查询作为条件

#### 嵌套查询的分类

* 不相关子查询
  * 子查询的条件不依赖于父查询
  * 是由里向外逐层处理，即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件
* 相关子查询
  * 子查询的查询条件依赖于父查询
  * 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表
  * 然后再取外层表的下一个元组，重复这一过程直到外层表全部检查完为止

#### 子查询谓词

##### 含有IN谓词的子查询

##### 含有比较运算符的子查询

当能确切直到内层查询返回单值时，可以用比较运算符

##### 带有ANY或ALL谓词的子查询

ANY：任何一个

ALL：所有

需要配合比较运算符使用

##### 带有EXISTS谓词的子查询

* EXISTS谓词：存在量词
  * 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值。
    * 若内层查询结果非空，则返回真值
    * 若内层查询结果为空，则返回假值
  * 由EXISTS引出的子查询，其目标列表达式通常用*，因为带EXISTS的子查询只返回真值或假值，给出列名没有实际意义
* NOT EXISTS谓词

### 集合查询

使用集合查询的原则：

* 属性的个数必须一致
* 对应的类型必须一致
* 属性名无关
* 最终结果集采用第一个结果的属性名
* 缺省为自动去除重复元组，除非显示说明ALL
* Order By放在整个语句最后

#### 并操作

```sql
<查询块1>
UNION [ALL]
<查询块2>;
```

* 参加UNION操作的每个结果集列数必须相同，而且对应项的数据类型必须兼容。
* 使用UNION合并多个结果集时，系统会自动去掉重复元组
* 如果需要保留重复元组，使用UNION ALL操作符

#### 交操作

标准SQL中没有提供集合交操作，但可以用其他方法间接实现。集合交操作可以使用AND或子查询实现

#### 差操作

集合差操作可以转化为适当的普通查询

#### 对集合操作的结果进行排序

* ORDER BY 子句只能用于对最终查询结果进行排序，不能对中间结果进行排序，在任何情况下，ORDER BY子句只能出现在最后。
* 对集合操作结果排序时，ORDER BY子句最好用数字指定排序的列属性。

## 数据更新

### 插入数据

两种插入数据方式：

* 插入单个元组
* 插入子查询结构

#### 插入单个元组

```sql
INSERT INTO <表名> [<属性列1>,...]
	VALUES (常量1, 常量2, ...);
```

功能：将新元组插入指定表中

* INTO 子句
  * 指定要插入数据的表名及属性列
  * 属性列的顺序可以与表定义的顺序不一致
  * 没有指定属性列，表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致
  * 指定部分属性列：插入的元组在其余属性列上去空值
* VALUES子句
  * 提供的值必须与INTO子句匹配：值的顺序、类型和个数
