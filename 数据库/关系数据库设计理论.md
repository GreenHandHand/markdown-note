---
tags:
  - 数据库
---

# 关系数据库设计理论

本节介绍关系数据库设计理论，该内容不同于 [[数据库/数据库完整性|数据库完整性]]、[[数据库/数据库并发控制|数据库并发控制]]、[[数据库/数据库恢复技术|数据库恢复技术]]、[[数据库/数据库的安全性|数据库的安全性]] 这些应用章节，本节是作为理论指导[[数据库/关系数据库|关系数据库]]的设计。

## 关系模型的存储异常

**数据库模式的设计**是数据库应用系统开发的核心问题
- 由于认识或看问题的方式不同，一个数据库可以设计出不同的数据模式
- 针对具体问题，如何构造一个适合于它的[[数据库/数据模型|数据模型]]

这是数据库设计的问题，是关系数据库的逻辑设计

关系数据库模型的设计，即数据库的逻辑设计，就是要从各种可能的关系模式组合中选取一组关系模式来构成一个数据库模式。

关系数据库中可能存在的**存储异常**：
1. 数据冗余：数据冗余是指同一数据被反复存储的情况。
2. 更新异常：数据冗余将导致存储空间的浪费和潜在的数据不一致及修改等问题。
3. 插入异常：数据插入操作异常是指应该插入到数据库中的数据不能执行插入操作的情况。
4. 删除异常：数据的删除异常操作是指不应该删去的数据别删除的情形。‘

出现以上存储异常的原因：
- 因为在数据间存在着一定的依赖关系
- 但数据库模式没有很好地反映这些关系

在现实世界中实体和实体间及实体内部的属性值之间存在着相互依赖又相互制约的关系，称为**数据依赖**。

## 函数依赖

函数依赖是现实世界中最广泛存在的一种数据依赖，是现实世界属性间相互联系的抽象，是数据内在的性质，它表示了关系中属性间的一种制约关系。

**函数依赖**：设关系模式 $R(U),X,Y\subseteq U$，r 是 $R(U)$ 上的任一关系，对任意元组 $t_1, t_2\in r$，如果 $t_1,t_2$ 在 X 上的属性值相等，$t_1,t_2$ 在 Y 上的属性值也相等，则称 X 函数决定 Y，或 Y 函数依赖与 X，记为 $[FD] X\to Y$，称 X 为决定因素，或称 X 为函数依赖的左部，称 Y 为函数依赖的右部。

函数依赖按照性质可以分为：
- 平凡函数依赖与非平凡函数依赖

- 完全函数依赖与部分函数依赖：
- 传递函数依赖：

### 平凡函数依赖

平凡的函数依赖定义：
- 如果 X 决定 Y，而且 Y 属于 X，也就是 Y 是 X 的真子集，则称该依赖为平凡依赖；否则为非平凡依赖。

平凡的函数依赖是对模式 R 上所有关系都成立的函数依赖。
对任一关系模式，平凡函数依赖都是必然成立的。

### 完全函数依赖

完全函数依赖定义：
- 设 R 为任一给定关系，X、Y 为其属性集，若 $X\to Y$,且 X 中的任何真子集 x 都有 $x \nrightarrow y$，则称 Y 完全函数依赖于 X, 记为 $FD\, X \overset{f}{\to} Y$。
- 若对 $X'\subset X$，而 $[FD] X'\to Y$ 成立，则称 $FD\, X\to Y$ 是部分函数依赖，即 Y 函数依赖于 X 的一部分。记为 $FD\,X\overset{p}{\to}Y$。

当 X 是单属性集时，$FD\,X\to Y$ 一定是完全函数依赖
当 X 是属性集时，$FD X\to Y$ 可能是完全函数依赖，也可能是部分函数依赖

### 传递函数依赖

传递函数依赖定义：
- 设 R 任一给定关系，X、Y、Z 为其不同属性子集，若 $X→Y$，$Y\nrightarrow X$，$Y→Z$，则有 $X→Z$，则称 Z 传递函数依赖于 X

注：如果 $Y\to X$，且已知 $X\to Y$，则 $X\leftrightarrow Y$，此时如果有 $Y\to Z$，则有 $X\to Z$，称 Z 直接函数依赖与 X

### 函数依赖的逻辑蕴涵

一个关系模式 R 上的任一关系 $r(R)$，在任意给定的时刻都有它所满足的一组函数依赖集 F。若关系模式 R 上的任一关系都能满足一个确定的函数依赖集 F，则称 F 为 R 的函数依赖集。

定义：设函数依赖集 F 和关系模式 $R(U)$，属性集 $X,Y\subseteq U$，关系模式 R 满足 F。如果关系模式 R 满足 $FD\,X\to Y$，则称 $F$ 逻辑蕴涵 $FD\,X\to Y$，或称 $FD\,X\to Y$ 逻辑蕴涵于 $F$。记为 $F\vDash X\to Y$。

定义：设函数依赖集 $F$，所有被 F 逻辑蕴涵的函数依赖称为 F 的闭包，记为 $F^+$。

定义：设关系模式 $R(U,F)$，U 是 R 的属性全集，F 是 R 的函数依赖集，X 是 U 的子集。如果满足条件：
1. $X\to U\in F^+$
2. 不存在 $X'\subset X$ 且 $X'\to U\in F^+$ 成立
则称 X 为模式 R 的一个候选键。要确定关系模式的候选键，需要确定模式中属性间的依赖关系，找到满足上述规则的 X。

## 函数依赖公理

已知函数依赖集 F，如果确定 F 是否逻辑蕴涵 $FD\,X\to Y$？该问题需要通过 Armstrong 公理。

### Armstrong 公理

Armstrong 公理：设关系模式 $R(U,F)$，并且 X，Y，Z 和 W 是 U 的子集
- 自反律：若 $Y\subseteq X\subseteq U$，则 $F \vDash X\to Y$
- 增广律：若 $F\vDash X\to Y$，且 $Z\subseteq U$，则称 $F\vDash XZ\to YZ$
- 传递律：若 $F\vDash X\to Y, F\vDash Y\to Z$，则称 $F\vDash X\to Z$

根据上面的三个公理可以得到三条推论：
- 合成规则：由 $X\to Y, X\to Z$，则 $X\to YZ$
- 分解规则：由 $X\to Y$ 及 $Z\subseteq Y$，则 $X\to Z$
- 伪传递规则：由 $X\to Y, YZ\to W$ ，则 $XZ\to W$

 Armstrong 公理系统是一套推理规则，从一组函数依赖求得蕴涵的函数依赖，是模式分解算法的理论基础，求给定关系模式的键

**Armstrong 公理是有效的、完备的。**

### 属性闭包

定义：设关系模式 $R(U,F),U=\{A_1,A_2,\dots,A_n\},X\subseteq U$。所有用公理退出的函数依赖 $X\to A_i$ 中 $A_i$ 的属性集合称为属性集 X 关于函数依赖集 F 的闭包，记为 $X_F^+$。

即 $X_F^+={A_i|所有用公理由F推出的X\to A_i}$

定义：设关系模式 $R(U,F),X,Y\subseteq U$。能够由 Armstrong 公理从 F 导出 $X\to Y$ 成立的充要条件是 $Y\subseteq X_F^+$。

通过属性闭包的概念，可以把判定 $X\to Y$ 是否能由 F 根据 Armstrong 公理导出的问题，转换为求 $X_F^+$，判定 Y 是否为 $X_F^+$ 的子集的问题。

#### 求属性闭包的算法

计算属性集 X 关于 F 的闭包 $X_F^+$
输入：模式 R 的属性全集 U，U 上的函数依赖集 F，属性集 X
输出：属性集 X 的闭包 $X_F^+$
方法：
1. 初值 $X^{(0)}=X,i=0$
2. $X^{(i+1)}=X^{(i)}\cup Z$，其中，属性集 $Z=\{A|存在V\to W\in F, V\subseteq X^{(i)}且A\in W而A\notin X^{(i)} \}$
3. 判断 $X^{(i+1)}=X^{(i)}$ 或 $X^{(i+1)}=U$ 是否成立，若成立转 $(5)$
4. $i=i+1$，转 $(2)$
5. 输出 $X_F^+$ 的结果 $X^{(i+1)}$

通俗来说，就是按一下步骤进行：
1. 令 X = 初值
2. 在 F 中找到左边是 X 的子集，而右边最少有一个不是 X 的子集的函数依赖
3. X = X 与右边的并集
4. 重复上述步骤直到没有符合条件的函数依赖

### 函数依赖集的等价和覆盖

定义：如果 $G^+=F^+$，就说函数依赖集 F 覆盖 G（F 是 G 的覆盖或者 G 是 F 的覆盖）或 F 与 G 等价

**函数依赖集等价的充要条件**：$F\subseteq G^+ 同时G\subseteq F^+$

上面给出了判断两个函数依赖集等价的可行算法：要判断 $F\subseteq G^+$，只须逐一对 F 中的函数依赖 $X\to Y$，考查 Y 是否属于 $X_G^+$ 就行了。

### 最小依赖集

定义：如果函数依赖集 F 满足下列条件，则称 F 为一个最小函数依赖集或者最小覆盖：
1. F 中的所有函数依赖其右部都是单属性
2. 对 F 中的任一函数依赖 $X\to A, F - \{X\to A\}$ 与 F 不等价
3. 对 F 中的任一函数依赖 $X\to A, F-\{X\to A\}\cup\{Z\to A\}$ 与 F 不等价。其中 Z 是 X 的真子集。

最小依赖集的特点：
- 右部都是单属性
- 没有多余的函数依赖
- 左部没有多余属性

定理：每个函数依赖集 F 均等价与一个最小函数依赖集 $F_m$。

找到函数的最小依赖集的方法：
1. 逐一检查 F 中各函数依赖 $FD_i:\,X\to Y$，若 $Y=\{A_1A_2\dots A_k\},k>2$，则用 $\{X\to A_j|j=1,2,\dots,k\}$ 来取代 $X\to Y$
2. 逐一检查 F 中各函数依赖 $FD_i:\,X\to A$，令 $G=F-\{X\to A\}$，若 $A\in X_G^+$，则从 F 中去掉此函数依赖。
3. 逐一取出 F 中各函数依赖 $FD_i:\,X\to A$，设 $X=\{B_1B_2\dots B_m\}$，逐一考查 $B_i(i=1,2,\dots,m)$，若 $A\in(X-B_i)_F^+$，则以 $X-B_i$ 取代 X

通俗的来说，就是:
1. 将右部全部拆分
2. 逐个查看函数依赖是否可以舍弃，具体的来说，就是去掉依赖后，求该依赖右部的闭包，如果不包含左部，则不能去掉。例如依赖 $A\to B$，我们将其去掉后计算 $A^+$ 中是否含有 $B$，若不含，则不能去掉。
3. 逐个查看函数依赖的左部是否可以化简，具体的来说，就是分别计算左部各个的闭包，如果包含右部，则可以化简。例如依赖 $CD\to A$，计算 $C^+$ 与 $D^+$，去掉其中包含 A 的对应符号。

F 的最小函数依赖集 $F_m$ 不一定是唯一的，若改造后的 F 与原来的 F 相同，说明 F 本身就是一个最小依赖集。

## 模式分解

一个大的模式在属性间可能会存在复杂的数据依赖关系，用来存储异常等问题。因此需要一个大的关系模式用几个较小的模式代替，即进行模式分解。

定义：设关系模式 $R(U).\rho=\{R_1(U_1), R_2(U_2),\dots,R_k(U_k)\}$ 是一个关系模式的集合，若 $\bigcup\limits_{i=1}^kU_i=U$，则称 $\rho$ 是关系模式 $R(U)$ 的一个分解。

分解后的模式应该与原模式等价
- 无损连接分解：分解后的模式不损失任何信息
- 分解保持依赖性：分解后的模式保持原来的函数依赖

### 无损连接分解

一个模式分解为多个模式，相应地储存在一个关系中的数据要分别存储到多个关系中。
分解后的关系通过自然连接要能够恢复为原来的关系，即保证连接后的关系与原关系完全一致。

### 分解的保持依赖性

分解后的模式是否能表征原有的函数依赖，也是分解后的模式是否与原模式等价的一个标准。

如果一个分解具有无损连接性，则它能够保证不丢失信息。如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况。即分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。

## 关系模式的规范化

范式：规范化的关系模式
- 符合某一种级别的关系模式的集合
- 满足不同程度要求的关系模式为不同的范式
- 根据规范化程度的不同，数据库范式从低到高有 1NF、2NF、3NF、BCNF 等
- 一个数据库模式可以通过模式分解，从低一级的范式转化为若干个高一级的范式。
- 从低一级的范式通过分解达到高一级范式的过程称为关系模式的规范化——规范化理论的核心

### 第一范式（1NF）

**第一范式**是最低级别的关系模式，关系数据库中的关系模式至少都应是第一范式的

定义：如果关系模式 R 的每个属性对应的值域都是不可再分的，称模式 R 属于第一范式，简记为 $R\in 1NF$。

若数据库模式 R 中的每个关系模式都是 1NF，数据库模式 $R\in 1NF$。
一个数据库系统的关系至少应该是 1NF 的，是关系作为二维表的起码的要求。不满足 1NF 的数据库模式不能称为关系数据库。

### 第二范式 (2NF)

**第二范式**定义：设关系模式 R, A 是 R 中的属性，F 是 R 上的函数依赖集。如果 A 包含在 R 的某个候选键中，称 A 为主属性，否则称 A 为非主属性。

定义：如果一个关系模式 $R\in 1NF$，且所有非主属性都完全依赖与 R 的每个候选键，则 $R\in2NF$。

如果数据库 R 中的每个关系模式都属于 2NF，则数据库模式 $R\in 2NF$。

判断一个关系模式是否属于 2NF：
- 需要了解关系模式的属性间存在哪些依赖
- 根据数据依赖关系，找出关系模式的候选键
- 确定哪些属性是主属性，哪些属性是非主属性
- 确定所有非主属性与候选键之间是否否是完全函数依赖关系，以判断该模式是够属于 2NF

2NF 并不能完全消除关系模式中的各种储存异常情况。

### 第三范式（3NF）

**第三范式**：设 $R\in 1NF$，若在 R 中没有非主属性传递依赖与 R 的候选键，则关系模式 $R\in 3NF$。如果数据库模式 R 中的每一个关系模式都是 3NF，则数据库模式 $R\in 3NF$

- 一个 2NF 的关系模式不一定属于 3NF
- 一个关系模式若是 3NF 的，则一定属于 2NF

若 $R\in 3NF$，则 R 的每一个非主属性既不部分函数依赖于候选键也不传递函数依赖与候选键。

### Boyce-Codd 范式 (BCNF)

**BCNF 定义**：若 $R\in 1NF$，而且 R 中没有任何属性传递依赖于 R 中的任一候选键，则关系模式 R 属于 Boyee-Codd 范式 (BCNF)。如果数据库模式 R 中的每个关系都属于 BCNF，则数据库模式 $R\in BCNF$

BCNF 不但排除了非主属性对主属性的传递依赖，也排除了主属性键的传递依赖。

定义：设关系模式 $R\in 1NF$，F 是 R 上的函数依赖集，对于 F 中的每一个函数依赖 $X\to Y$ ，X 必含有候选键，则 $R\in BCNF$。如果 $R\in BCNF$，则对于 R 上的每一个函数依赖，每个决定因素都包含候选键。

3NF 与 BCNF 的关系：
- 若 $R\in BCNF$，一定有 $R\in 3NF$
- 若 $R\in 3NF$，不一定有 $R\in BCNF$

BCNF 的关系模式所具有的性质：
1. 所有非主属性都完全函数依赖于每个候选键
2. 所有主属性都完全函数依赖于每个不包含它的候选键
3. 没有任何属性完全函数依赖于非键的任何一组属性

在函数依赖的范围内，BCNF 已达到了关系模式的最大分离，已经消除了插入、删除异常，是函数依赖范围内能够达到的最高范式

### 模式分解算法

生成 3NF 的算法：
输入：关系模式 $R(U,F)$
输出：达到 3NF 的具有无损连接性和保持依赖性的 R 的一个分解
1. 寻找没有出现在 F 中的 R 属性，将这些属性单独组成一个关系模式，并将这些属性从 R 中去掉，设其余属性所组成的关系模式仍为 R。
2. $F:=F\cup\{U\to Z\}$，Z 是没有出现在 F 中的附加属性
3. 计算 F 的最小函数依赖集，结果仍记为 $F$
4. 若有 X，Y 为 F 中函数依赖的左部且 $X\leftrightarrow Y$，则将这些函数依赖分为一组，X，Y 可以相同。
5. 将每组函数依赖组成一个关系模式，并将附加属性 Z 从含有它的模式中除去。
6. 若有一个关系模式所含的属性与 R 的属性相同，输入该模式，否则，输出这些模式。
7. 算法终止。

通俗的说，就是：
1. 将 Z 记为 R 中没有出现在 F 中的属性，R 记为 F 中出现的属性。
2. 令 $F=F\cup\{U\to Z\}$
3. 计算 F 的最小函数依赖集，记为 F
4. 按照左部对 F 进行划分
5. 每组函数依赖组成关系模式 $R_i$，并将 Z 去掉
6. 如果有一个与 R 相同，则输出 R，否则全部输出。

生成 BCNF 的算法：
输入：关系模式 $R(U,F)$
输出：达到 BCNF 的 R 的一个无损分解
1. 设 $\rho=\{R(U,F)\}$
2. 检查 $\rho$ 中各关系模式是否为 BCNF，若是，则算法终止
3. 若 $\rho$ 中有 $R_i(U_i, F_i)$ 不属于 BCNF，即 $F_i$ 中有 $FD\,X\to Y$，而 X 不是 $R_i$ 的键，分解 $R_i$ 为 $R_{ii}=XY$，$R_{i2}=R_i-Y$
4. 用 ${R_{i1}, R_{i2}}$ 代替 $\rho$ 中的 $R_i$，返回 $(2)$

### 小结

![[Pasted image 20230412135658.png]]
