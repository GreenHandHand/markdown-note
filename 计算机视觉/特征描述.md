---
aliases:
  - feature description
  - descroptor
tags:
  - 计算机视觉
---

# 特征描述

在通过 [[特征检测]] 中得到了特征的位置后，我们需要将其描述出来。我们希望在一个物体的不同图像中，检测出来的相同特征应当有着相同的特征描述符，即得到的特征向量距离应当比其他的特征向量更近。

特征描述符 (descriptor) 需要满足不变性与可辨别性：
- 不变性：图像改变时，特征描述符不应该改变。
- 可辨别性：一个图像中的每一个特征描述符应该是独一无二的。

大多数的特征描述符的不变性都是针对于 2d 变化设计的，例如平移、旋转或者缩放。但是它们通常也可以适应一些 3d 的变化，例如：
- 有限的 3D 旋转
- 有限的仿射变换
- 有限的照明、对比度变换

## 特征描述符

这部分介绍一些常用的特征描述符。

### MOPS

MOPS (Multiscale Oriented Patches) 是一种多尺度、带方向的块描述符。该特征描述符的计算方式如下：
- 根据尺寸和角度，选取一个 $40\times 40$ 的窗口
- 缩小到原窗口的 $1/5$
- 旋转至水平
- 采样这个 $8\times 8$ 的窗口
- 标准化窗口的灰度 (减去均值，除以标准差)

### SIFT

SIFT 使用的基于梯度的特征描述符。这种特征描述符可以很好的捕捉特征点邻域的纹理信息。其步骤如下：
1. 使用一个与关键点尺度，即 $\sigma$ 相同的模糊图像，与一个固定大小的特征点邻域，其中领域的半径可以使用下面的公式进行计算。其中 $d$ 表示划分的子块的大小，这里取 4。
$$
\text{radius}=\frac{3\sigma\sqrt{2}(d+1)+1}{2}
$$
2. 旋转坐标轴到关键点主方向 (关键点的梯度方向)，可以使用矩阵乘法的方式将所有的点的坐标进行修改，然后以关键点为中心，通过三线性插值的方式将其补充为 $16\times16$ 形状的邻域像素。
$$
\begin{bmatrix}\hat x\\\hat y\end{bmatrix}=\begin{bmatrix}\cos\theta &-\sin\theta\\\sin\theta&\cos\theta\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}
$$
3. 将邻域像素划分为 $4\times 4$ 大小的小块，其中每一块也为 $4\times 4$，分别计算每个块内的 8 个方向的梯度直方图，获得每个方向的梯度幅值，最后组成一个 $4*4*8=128$ 维度的描述向量。

SIFT 描述符是一个 128 维度的向量，且具有：
1. 旋转不变性：通过将邻域点的方向旋转到特征点的主方向，从而实现了旋转不变性
2. 尺度不变性：使用了多尺度的图像进行检测

通过 SIFT 描述符，我们可以直接通过欧氏距离来找到匹配的向量。

更进一步，我们对 SIFT 描述符进行一些修改，可以得到对于光照变化更加鲁棒的描述符：
1. 首先，由于 SIFT 描述符是由梯度构成的，因此它具有一定的亮度不变性。
2. 为了纠正由于对比度导致的梯度幅度增加，我们对描述符的直方图进行归一化，确保其幅度为 1.0
3. 大幅度的图像梯度一般来自不可靠的三维光照，例如耀斑等。为了减小它们的影响，我们将描述符中的所有值截断为 0.2，然后再对向量进行归一化。

### HoG

方向梯度直方图 (Histogram of Oriented Gradients) 是一种基于图像中各区域的梯度信息，通过建立直方图来描述不同方向上的梯度分布的特征描述符。

HoG 是在判别目标形状的任务中提出，面临
- 姿态的广泛变化和外观的大幅度变化
- 在不同光照下杂乱的背景
- 移动视觉中的速度

HoG 通过分析图像中各个区域的梯度强度或者边缘方向的分布来描述物体的特征，这种方法可以有效的捕捉到物体的轮廓和纹理信息，帮助我们理解图像中的局部架构。

HoG 方法的过程如下所示：
1. 一些图像预处理，包括转换为灰度图形、Gamma 矫正等。
1. 将图像窗口划分为一些小的区域，这些区域可以是矩形，也可以是径向 (radial) 的，称为单元格 (cell)。
2. 对于每一个单元格，计算该区域内像素的梯度方向，并构建一个大小为 $n$ 加权方向直方图。
3. 为了更好的适应不同的光照、阴影，在多个相邻单元格之间进行归一化是一种有效的方法。这个比单元格更大的结构称为块 (block)。块之间是可以有重叠的，对于矩形划分的单元格，常使用移动窗口的方式来获得所有的块。如果一个块中包含了 $m$ 个单元格，那么这个块就可以描述为 $n\times m$ 维度的向量。
4. 将所有块的向量组合起来，就得到了图像的 HoG 特征描述块，用于描述整张图像。

在实际应用中，我们一般将一张图像转换为由块组成的 HoG 特征图，这样的特征图有一个好处，就是对于任意大小的子图，我们只需要将其中所有的特征描述块拼接，就可以得到这个区域的特征描述块。

对于 HoG 与 SIFT 方法，有以下区别：
1. HoG 通常用于描述较大的图像区域，而 SIFT 用于关键点匹配
2. SIFT 直方图相对于主导梯度进行了归一化处理，但是 HoG 没有进行这种处理
3. HoG 梯度是通过邻域区间进行归一化的

## 特征匹配

特征匹配问题较为简单，就是给定了图一中的一个特征，如何在图二中找到最为匹配的特征。有以下两步：
1. 定义距离函数，用于比较两个特征描述符 $\Vert f_1-f_2\Vert$
2. 比较两个图中的所有特征，找到距离最近的一对特征

这个问题在[[机器学习/聚类|聚类]]中已经被广泛的研究过了，我们可以使用大多数的聚类算法来进行匹配。

一般而言，两个图像中的特征点不会全部匹配，我们可以通过设定一个阈值来判断两个点是否应该被配对。尽管这样，也仍然无法避免配对的问题。为了找到一个最好的阈值，我们需要一些指标来评估一个配对方法的性能。

对于配对问题，我们使用 [[实践知识/评价指标#混淆矩阵]] 来进行计算。最常用的两个指标分别为：
- 召回率 (recall)：true positives / total positive
- 特异度 (specificity)：false positives / total negatives

此外，还常用 ROC 曲线与 AUC 分数来对方法进行评估。其中 AUC 越高，性能越好。

## 图像对齐

给定了两张图像，我们如何得到这两张图像之间的变换关系？通过之前方法的介绍，我们通过特征检测与匹配的方式，得到了两张图像中匹配的特征点。下面从不同的变换方式介绍方法。

假设图像一中的特征点的坐标为 $(x_n,y_n)$，图像二中的特征点的坐标为 $(x_n',y_n')$。

### 平移变换

对于平移变换，我们有对于每个点都有一个固定的偏移量，设这个偏移量为 $(x_t,y_t)$，我们可以使用任意一对特征点来求得这个偏移量，但是由于误差的存在，我们使用均值替代，即
$$
(x_t,y_t)=\left(\frac{1}{n}\sum_{i=1}^n(x_i'-x_i),\frac{1}{n}\sum_{i=1}^n(y_i'-y_i)\right)
$$

### 仿射变换

经过仿射变换后得到的图像满足单应性，每个特征点应当满足
$$
\begin{bmatrix}x'\\y'\\1\end{bmatrix}
=\begin{bmatrix}a&b&c\\d&e&f\\0&0&1\end{bmatrix}
\begin{bmatrix}x\\y\\1\end{bmatrix}
$$
根据上式，我们只需要求解线性系统
$$
\begin{aligned}
x'&=ax+by+c\\
y'&=dx+ey+f
\end{aligned}
$$
使用矩阵的方式，表示为
$$
\small\begin{bmatrix}x_1&y_1&1&0&0&0\\0&0&0&x_1&y_1&1\\&&\vdots\\x_n&y_n&1&0&0&0\\0&0&0&x_n&y_n&1\end{bmatrix}\begin{bmatrix}a\\b\\c\\d\\e\\f\end{bmatrix}=\begin{bmatrix}x_1'\\y_1'\\\vdots\\x_n'\\y_n'\end{bmatrix}
$$
然后通过最小二乘法求解得到结果。

### 任意变换

现在将前面的两种变换加起来，即我们需要处理方程
$$
\begin{bmatrix}x'\\y'\\1\end{bmatrix}
=\begin{bmatrix}h_{00}&h_{01}&h{02}\\h_{10}&h_{11}&h_{12}\\h_{20}&h_{21}&h_{22}\end{bmatrix}
\begin{bmatrix}x\\y\\1\end{bmatrix}
$$
展开上式，我们可以得到一个非线性系统
$$
\begin{aligned}
x_i'&=\frac{h_{00}x_i+h_{01}y_i+h_{02}}{h_{20}x_i+h_{21}y_i+h_{22}}\\
y_i'&=\frac{h_{10}x_i+h_{11}y_i+h_{12}}{h_{20}x_i+h_{21}y_i+h_{22}}
\end{aligned}
$$
通过变换，我们也可以通过线性的方式求解：
$$
\begin{aligned}
x_i'(h_{20}x_i+h_{21}y_i+h_{22})&=h_{00}x_i+h_{01}y_i+h_{02}\\
y_i'(h_{20}x_i+h_{21}y_i+h_{22})&=h_{10}x_i+h_{11}y_i+h_{12}
\end{aligned}
$$
写成矩阵的方式，如下所示：
$$
\small\begin{bmatrix}x_1&y_1&1&0&0&0&-x_1'x_1&-x_1'y_1&-x'\\0&0&0&x_1&y_1&1&-y_1'x_1&-y_1'y_1&-y_1'\\&&&&\vdots\\x_n&y_n&1&0&0&0&-x_n'x_n&-x_n'y_n&-x'\\0&0&0&x_n&y_n&1&-y_n'x_n&-y_n'y_n&-y_n'\end{bmatrix}\begin{bmatrix}h_{00}\\h_{01}\\h_{02}\\h_{10}\\h_{11}\\h_{12}\\h_{20}\\h_{21}\\h_{22}\end{bmatrix}=\begin{bmatrix}0\\0\\\vdots\\0\\0\end{bmatrix}
$$
同样使用最小二乘法得到结果。

## 全景

全景 (panorama) 是一种将所有角度的图像拼接在一起，最后得到一幅完整图像的技术。结合上述的方法，包括 [[直线检测]]、特征检测和匹配，可以将不同的角度的图像结合到一起，组成全景。