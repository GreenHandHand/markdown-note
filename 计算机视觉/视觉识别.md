
---
tag:
  - 计算机视觉
---

# 视觉识别

视觉识别是一个较为宽泛的任务，其包括了：
1. 分类：对图像进行分类，获得图像的类别，或者判断某物体是否包含在图像中。
2. 检测：检测在分类的基础上，还需要指出物体的位置。或者试图识别图像上的所有物体。或者检测图像中包含的语义。
3. 理解：理解图像中的事物并进行回答。

视觉识别是一项困难的任务，我们需要设计算法，实现
- 分类图像或者视频
- 检测并定位物体
- 估计语言和几何信息
- 分类人类活动与事件

视觉识别中存在大量的挑战，例如类别多、视角变化、光照变化、尺度变换、物体形状变化、遮挡、背景复杂、类内变化多样等，使得视觉挑战一直都是一项富有挑战的任务。

## KNN 算法

在机器学习中，[[k 近邻]]算法 (K-nearest neighbor, [[机器学习/k 近邻|KNN]]) 是在计算机视觉中应用的一个代表算法。机器学习中，任务被定义为
$$
y=f(\mathbf x)
$$
其中，$y$ 作为输出，$f$ 是预测函数，$\mathbf x$ 是输入图像。机器学习中处理数据的范式是
- 训练：根据给定的训练数据集，优化模型的预测误差
- 测试：使用训练的模型在没有出现在训练数据中的测试数据集上测试

KNN 算法是一种非常简单的算法，它为每个数据点分配距离训练数据标签最近的标签。其算法步骤如下：
```pseudo
	\begin{algorithm}
	\caption{k-nearest neighbors}
	\begin{algorithmic}
	\Input train data $\mathbf x_i$ and it's label $y_i$
	\Input test input x
	\Output test label y
	\State compute distance to all training data points
	\State Select $k$ training points cloest to $x$
	\State Assign $x$ to label $y$ that is most common among the $k$ nearest neighbor
	\end{algorithmic}
	\end{algorithm}
```
KNN 算法简单易用，只有一个超参数 $k$ 需要选择，通过[[实践知识/交叉验证|交叉验证]]的方式，可以找到一个合适的 $k$ 值。常用的交叉验证见 [[机器学习概述#交叉验证]]。

在机器学习中有着许多的分类器，包括 [[k 近邻]]，[[支持向量机]]、神经网络，[[朴素贝叶斯]]，[[贝叶斯网络]]，[[线性模型#对数几率回归|逻辑回归]]，[[随机森林]]，[[决策树]]，[[条件随机场]] 等。

根据 No Free Lunch 理论，在监督学习的情况下，我们无法得知那种模型的泛化性能最好。没有那种分类器天生好于其他所有模型，我们只能根据误差来对模型在特定情况下的表现进行选择：
- 模型固有的误差 (inherent)：无法避免的误差。
- 偏差 (bias)：由于过度简化导致的误差。
- 方差 (variance)：由于无法从有限数据中完美估计参数导致的误差。

简而言之，要考虑将机器学习方法应用于目标识别时：
- 了解数据的特性，包括监督信息、训练示例数量以及数据的噪声水平。
- 确定目标，因为它会影响表示方法、学习算法和评估指标的选择。
- 深入理解每个考虑中的机器学习算法的数学原理。

## 视觉词袋模型

词袋模型 (Bag of Word, BOW) 是对文本进行编码的一种方式，这种方式将每个 token 编码为一个独热向量。在视觉中，我们也可以使用类似的思想对图像进行编码。在视觉中，我们可以将图像按照构成元素划分为 texton，这样的编码方式在进行图像级别的分类与识别的时候取得了不错的效果。

下面介绍的是与 bow 思想类似的 bag of features 算法。该算法的步骤如下：
1. 将数据图像切分，从中提取特征。切分方式有多重，早期使用常规网格，后来使用特征检测，还有一些其他的方法，包括随机采样、基于图像分割的 patch 方法。
2. 通过数据图像的特征，构建一个视觉词表。基本方法是使用[[机器学习/聚类|聚类]]算法，得到很多的聚类中心，这些中心就是具有代表性的基本 token。
3. 使用视觉词表将图像量化，使用视觉词表序列的方式表示图像。这一步通过直方图的方式，根据视觉词表将图像表示为向量。
4. 在获取了图片的编码之后，我们可以使用一些分类器、聚类算法实现想要的功能。

词袋模型最大的问题是抛弃了空间信息，但是在视觉中，我们可以通过图像金字塔获得图像不同尺度的特征。将词袋模型与图像金字塔结合，我们就可以获取图像中的空间信息。

## 目标检测

目标检测 (object detection) 是一项在现实中应用广泛的技术。其目标是在图像中找到目标对象，并标记其位置。由于该技术应用非常广泛，因此有许多的开源数据集。

在目标检测中，我们一般使用一个锚框来标记检测对象，每个锚框都有自己的标签。

### Benchmarks

- PASCAL VOC Challenge：20 个种类，用于分类、检测、分割
- ImageNet Large Scale Visual Recognition Challenge (ILSVR)：200 个类于检测的对象
- Common Objects in Context (COCO)：91 个需要检测的物体

### 评价指标

在进行评价时，一般使用真实锚框 (ground truth) 与预测锚框 (prediction) 的重叠率作为评价指标，以 0.5 为分界线，高于的为预测正确的样本，低于的为预测错误的样本。

在实际中，我们的模型将会预测非常多的锚框，并为每个锚框预测一个置信度/响应值 (score)，在进行输出时，我们只会输出那些大于给定阈值的锚框。

### Deformable Parts model

首先考虑一个简单的目标检测模型。对于图像的任意区域，我们希望将其与目标模板进行匹配，于是可以提出下面的方法：
1. 计算模板的 HOG 特征
2. 将其与图像的不同区域的 HOG 特征进行匹配，这个区域就是目标检测的锚框
3. 为了使用不同大小的锚框来检测不同尺度的目标，我们使用固定大小窗口，在图像金字塔的不同层级进行检测。
4. 设定一个阈值，对于分数大于阈值的锚框，输出为匹配。

上述方法是一个简单的目标检测模型，对于那些视觉上相近的物体，可以进行有效的检测。但是实际上不同的图像中，每个物体相对于视点的角度是不同的，上面的简单模型只能检测与模板角度相差不大的目标。为了增加目标检测对于目标形变的适应性，DPM 方法将目标划分为了多个组件。

DPM (Deformable Parts model)，可变形的组件模型，是一种基于组件的检测算法，对于目标的形变有很强的鲁棒性。该算法
- 通过 [[特征描述#HoG|HoG]] 特征模板来进行检测
- 对于每个模板，包含一个根检测器 (root filter) 与一些组件检测器 (part filter)
	- 根检测器：用于检测整个物体，对于细节不重视
	- 组件检测器：将目标划分为了多个部分，每个部分使用一个组件检测器进行检测

![[Pasted image 20240106133511.png]]

这样的划分方式使得模型对于物体的形变有了一定的鲁棒性。根检测器由于缺乏细节，因此可以在物体形变的情况下较好的定位。而组件检测器只关注一小部分，且包含更多的细节，用于更加精确的检测。我们在实际中假设划分出的组件总是不变的。
![[Pasted image 20240106133821.png]]

使用数学的语言描述上述模型，不妨设包含 $n$ 个组件的目标检测模型为
$$
(F_0,P_1,\cdots,P_n,b)
$$
其中 $F_0$ 为根检测器，$P_i$ 为第 $i$ 个组件检测器，$b$ 为模型的偏置。每一个检测器定义为
$$
(F_i,v_i,d_i)
$$
其中 $F_i$ 为第 $i$ 部分，$v_i$ 为组件检测器相对于根检测的位置，$d_i$ 定义为部件在每个位置的形变成本。为了表示一个检测物体，我们需要定义该物体的位置表示：
$$
z=(p_0,\cdots,p_n),\quad\text{where}\ p_i=(x_i,y_i,l_i)
$$
即使用所有组件的坐标与层级来表示一个物体。

为了评估一个区域对于模板的符合程度，我们定义响应值为：
$$
\text{score}=\sum_{i=0}^n F_i\phi(p_i,H)-\sum_{i=1}^nd_i(\Delta x_i,\Delta y_i,\Delta x_i^2,\Delta y_i^2)
$$
其中，前者定义为所有检测器得到的分数之和，后者定义为所有组件检测器的惩罚项之和。

该模型的检测过程如下所示：
![[Pasted image 20240106135444.png]]
用语言描述一下，就是：
1. 提供一个全局模板与一些组件模板
2. 在原始图像与两倍分辨率的图像上计算 HoG 特征图
3. 使用全局模板在原始图像的特征图上计算响应值，使用组件模板在两倍分辨率的图像上计算响应值，计算 $F_i\phi(p_i,H)$
4. 计算每个组件的空间成本，即相对于根检测器，组件检测器的距离 $v_i$ 与形变容忍程度 $d_i$。
5. 计算响应分数。

DPM 使用手动选择的组件，并通过在这些部分激活上训练的空间模型来检测目标。优势包括部分具有直观含义，可以使用标准的检测方法，并且在特定类别上表现良好。然而，缺点包括需要手动选择部分，有时部分的外观分布不简单，无法保证没有遗漏重要的部分。当切换到另一类别时，需要重新构建模型。