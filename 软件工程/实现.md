---
tags:
  - 软件工程
---

# 实现

通常把编码和测试统称为实现。
- 编码：把软件设计结果翻译成某种程序设计语言书写的程序。作为软件工程的一个阶段，编码是对设计的进一步具体化，因此，程序的质量主要取决于软件设计的质量。
- 测试：测试的目的是在软件投入生产性运行之前，尽可能多地发现软中的错误。目前软件测试仍是保证软件质量的关键步骤，它是对软件规格说明、设计和编码的最后复审。

## 编码

> [!note] 选择程序设计语言的标准
> 1. 优先选择高级语言。
> 2. 系统用户的要求。
> 3. 可以使用的编译程序。
> 4. 可以得到的软件工具。
> 5. 工程规模。
> 6. 程序员的知识。
> 7. 软件可移植性要求。
> 8. 软件的应用领域。

源程序代码的逻辑简明清晰、易读易懂是好程序的一个重要标准。为了做到这一点，应该遵守以下规则：
1. 程序内部的文档。所谓程序内部的文档包括恰当的标识符，适当的注解和程序的视觉组织等。
2. 数据说明。数据说明的次序应该标准化。有次序就容易查阅，因此能够加速测试、调试和维护的过程。如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。
3. 语句构造：每个语句都应该简单而直接，不能为了提高效率而使程序变得过分复杂。
	- 不要为了节省空间而把多个语句写在同一行。
	- 尽量避免复杂的条件测试。
	- 尽量减少对非条件的测试。
	- 避免大量使用循环嵌套和条件嵌套。
	- 利用括号使逻辑表达式和算术表达式的运算次序清晰直观。
4. 输入输出：在设计和编写程序时应该考虑下述输入输出风格的规则：
	- 对所有输入数据进行检验。
	- 就爱你差输入项重要组合的合法性。
	- 保持输入格式简单。
	- 使用数据结束标记，不要求用户指定数据的数目。
	- 明确提示交互式输入的请求，详细说明可用的选择或边界数值。
	- 当程序设计语言对格式有严格要求时，应保持输入格式一致。
	- 良好的输出报表。
	- 给所有输出数据加标志。
5. 效率：主要指时间复杂度和空间复杂度。正在把详细设计结果翻译成程序时，总可以应用以下规则：
	- 写程序之前先简化算术和逻辑表达式
	- 仔细研究嵌套的循环，以确定是否有语句可以从内层向外转移。
	- 尽量避免使用多维数组。
	- 尽量避免使用指针和复杂的表。
	- 使用执行时间短的算术运算。
	- 不要混用不同的数据类型。
	- 尽量使用整数运算和布尔表达式

## 软件测试基础

测试的目标可以总结如下：
1. 测试是为了发现程序中的错误而执行程序的过程。
2. 好的测试方案是极可能发现迄今为止尚未发现的错误的测试。
3. 成功的测试是发现了至今为止尚未发现的错误的测试。

测试只能查找程序中的错误，不能证明程序中没有错误。

> [!note] 软件测试准则
> 1. 所有测试都应该能追溯到用户需求。
> 2. 应该远在测试开始之前就制定出测试计划。
> 3. 把 Pareto 原理应用到软件测试中，Pareto 原理说明，测试发现的错误中的 80% 很可能是由程序中 20% 的模块造成的。
> 4. 应该从小规模的测试开始，并逐步进行大规模的测试。通常，首先终点测试单个程序模块，然后把测试重点转向在集成的模块簇中寻找错误，最后在整个系统中寻找。
> 5. 穷举测试是不可能的。
> 6. 为了达到最佳的测试效果，应该由独立的第三方从事测试工作。

> [!note] 测试方法
> - 黑盒测试：已经指导产品应该具有的功能，可以通过测试来检验每个功能都能正常使用。黑盒测试又称为功能测试。
> - 白盒测试：知道产品内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常进行。白盒测试又称为结构测试。

### 测试步骤

除非是测试一个小程序，否则一开始就把整个系统作为一个单独的实体来测试是不现实的。测试过程必须分步骤进行，后一个步骤来逻辑上是前一个步骤的继续。大型软件系统的测试过程基本上由下述几个步骤组成。
1. 模块测试：在设计地好的软件系统中，每个模块完成一个清晰定义的子功能，且这个子功能与同级其他模块之间没有相互依赖关系。
	- 模块测试的目的是保证每个模块作为一个单元能正确运行，所以模块测试又称为单元测试。
	- 在这个测试步骤中发现的往往是编码和详细设计的错误。
2. 子系统测试：子系统测试是把经过单元测试的模块放在一起形成一个子系统来测试。
	- 模块间相互协调和通信是这个测试过程中的主要问题。
	- 这个测试步骤着重测试模块的接口。
3. 系统测试：把经过测试的子系统配装成一个完成的系统来测试。
	- 这个过程不仅应该返现设计和编码的错误，还应该验证系统确实能提供需求说明书中指定的功能，而且系统的动态特性也符合预定要求。
	- 这个测试步骤中发现的往往是软件设计中的错误，也可能返现需求说明中的错误。
4. 验收测试：把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但是是在用户积极参与下进行的。
5. 平行运行：关系重大的软件产品在验收后往往不立即投入生产性运行，而是要再经过一段平行运行时间的考验。所谓的平行运行就是同时运行新开发出来的系统和即将被它取代的旧系统，以便比较新旧两个系统的处理结果。

## 单元测试

单元测试集中监测软件设计的最小单元，即**模块**。通常，单元测试和编码属于软件过程的同一阶段。在编写出源程序代码并通过了编译程序的语法检查后，就可以用详细设计描述作指南，对重要执行通路进行测试，以便发现模块内部的错误。

通常，单元测试主要使用白盒测试技术，而且对多个模块的测试你可以并行地进行。

### 测试重点

在单元测试期间着重从下述 5 个方面对模块进行测试：
1. 模块接口：首先对通过模块接口的数据流进行测试，如果数据不能正确地进出，所有其他测试都是不切实际的。
2. 局部数据结构：对模块来说，局部数据结构是常见的错误来源。应该仔细设计测试方案，以便发现局部数据说明、初始化、默认值等方面的错误。
3. 重要的执行通路：由于通常不可能进行穷尽测试，因此在单元测试期间选择最优代表性，最可能发现错误的执行通路进行测试是十分关键的。
4. 出错处理通路：好的设计应该能遇见出现错误的条件，并且设置适当的处理错误的通路，以便在真的出现错误时执行相应的出错处理通路或干净地结束处理。当评价出错处理通路时，应该着重测试下述一些可能发生的错误：
	1. 对错误的描述是难以理解的。
	2. 记下的错误与实际遇到的错误不同。
	3. 在对错误进行处理之前，错误条件已经引起了系统干预。
	4. 对错误的处理不正确。
	5. 描述错误的信息不足以帮助确定造成错误的位置。
5. 边界条件：边界条件是单元测试中最后也是最重要的任务。软件常常在它的边界上失效。

### 代码审查

人工测试源程序可以由程序的编写者本人非正式地进行，也可以由审查小组正式进行。后者称为代码审查，它是一种非常有效的程序验证技术，对于典型的程序来说，可以查出 30%~70% 的逻辑设计错误和编码错误。审查小组最好由下述 4 人组成：
1. 组长：应该是一个很有能力的程序员，而没有直接参与这项工程。
2. 程序的设计者。
3. 程序的编写者。
4. 程序的测试者。

### 计算机测试

模块并不是一个独立的程序，因此必须为每个单元测试开发驱动软件或存根软件。
- 通常**驱动程序**也就是一个主程序，它接收测试数据，把这些数据传送给被测试的模块，并且印出有关的结果。
- **存根程序**代替被测试的模块所调用的模块。它使用被它代替的模块的结构，可能做最少量的数据操作，印出对入口的检验和操作结果，并且把控制归还给调用它的模块。

模块的内聚程度高可以简化单元测试过程。如果每个模块只完成一种功能，则需要的测试方案数目将明显减少，模块中的错误也更容易被预测和发现。

## 集成测试

集成测试是测试和组装软件的系统化技术。由模块组装成程序时有两种方法：
- 非渐增式测试：先分别测试每个模块，再把所有模块按设计要求放在一起结合成要测试的程序。
- 渐增式测试：把下一个要测试的模块通已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。

> [!note]
> 非渐增式测试一下子把所有模块放在一起，并把庞大的程序作为一个整体来测试，测试者面对的情况十分复杂。渐增式测试把程序划分为小段来构造和测试，在这个过程中比较容易定位和改正错误，对接口可以进行更加彻底的测试。因此，目前在进行集成测试时普遍采用渐增式测试方法。

### 自顶向下集成

自顶向下集成方法是日益为人们广泛采用的测试和组装软件的途径。从主控制模块开始，沿着程序的控制层次向下移动，主键把各个模块结合起来。在把附属于 (及最终附属于) 主控制模块的那些模块组装到程序结构中去时，或者使用深度优先的策略，或者使用宽度优先的策略。

> [!example]- 自顶向下集成 (深度优先)
> ![[image/实现-1.png]]
> 深度优先的结合方法先组装在软件结构的一条主控制通路上的所有模块。

对模块结合进软件结构的具体过程由下述 4 个步骤完成：
1. 对主控制模块进行测试，测试时用存根程序代替所有直接附属于主控制模块的模块。
2. 根据选定的结合策略 (深度优先或者宽度优先)，每次用一个实际模块替换一个存根程序 (新结合进来的模块往往又需要新的存根程序)。
3. 在结合进一个模块的同时进行测试。
4. 为了保证加入模块没有引进新的作物，可能需要进行回归测试 (即全部或者部分地重复以前做过的测试)。

> [!note] 自顶向下的特点
> - 优点：
> 	- 自定向下的结合策略能够在测试的早起对主要的控制或关键的抉择进行检验。在一个分解得好的软件结构中，关键的抉择位于层次系统的叫上层，因此首先碰到。
> 	- 不需要测试驱动程序。
> - 缺点：在实际使用中可能遇到逻辑上的问题。这类问题中最常见的是，为了充分测试软件系统的较高层次，需要在较低层测上的处理。然而在自顶向下测试的初期，存根程序代替了低层次的模块，因此，在软件结构中没有重要的数据自下而上流。为了解决这种问题，测试人员有两种选择：
> 	- 把许多测试推迟到用真实模块替代了存根程序以后再进行。
> 	- 从层次系统的底部向上组装软件。这种方法称为自底向上的测试。
> 	- 底层关键模块中的错误发现较晚，而且这种方法在早期不能充分展开人力。

### 自底向上集成

自底向上测试从**原子**模块 (即在软件结构最底层的模块) 开始组装和测试。因此是从底部向上结合模块，总能得到所需的下层模块处理功能，所以不需要存根程序。

下述步骤可以实现自底向上的结合策略：
1. 把底层模块组合成实现某个特定的软件子功能的族。
2. 写一个驱动程序 (用于测试的控制程序)，协调测试数据的输入和输出。
3. 对由模块组成的子功能族进行测试。
4. 去掉驱动程序，沿软件结构自下而上移动，把子功能族组合起来形成更大的子功能族。

随着结合向上移动，对测试驱动程序的需要也减少了。事实上，如果软件结构的顶部两层用自顶向下的方法组装，可以明显减少驱动程序的数目，而且族的结构也将大大简化。

### 改进策略

在测试设计的软件系统时，应该根据软件的特点以及工程进度安排，选用适当的测试策略。一般来说，纯粹自定向下或纯粹自底向上的策略可能都不实用。人们在实践中创造出许多混合策略：
1. 改进的自顶向下测试方法：基本使用自顶向下的测试方法，但是在遭际使用自底向上的方法测试软件中的少数关键模块。
	- 一般的自顶向下方法所具有的优点这种方法中也有，而且能在测试的早期发现关键模块中的错误。
	- 缺点比自顶向下方法多一条，即测试关键模块时需要驱动程序。
2. 混合法：对软件结构中较上层使用的自顶向下方法与软件结构中较下层使用的自底向上方法相结合。这种方法兼有两种方法的优点和缺点。

### 回归测试

在集成测试过程中，每当一个新模块结合进来时，程序就发生了变化。建立了新的数据流路径，可能出现了新的 IO 操作，激活了新的控制逻辑。这些变化可能使原来工作正常的模块出现问题。在集成测试的范畴中，所谓的回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。

回归测试集包括下述 3 类不同的测试用例：
1. 检测软件全部功能的代表性测试用例。
2. 专门针对可能受修改影响的软件功能的附加测试。
3. 针对被修改过的软件成分的测试。

> [!note]
> 集成测试中，回归测试用例的数量可能会变得非常大。因此，应该把回归测试集设计成只包括可以检测程序每个主要功能中的一类或多类错误的一些测试用例。

## 确认测试

确认测试又称为验收测试，它的目的是验证软件的有效性。那么什么样的软件才是有效的呢？软件有效性的一个简单的定义是：如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的。

需求分析阶段产生的软件需求规格说明说，准确地描述了用户对软件的合理期望，因此是软件有效性的标准，也是进行确认测试的基础。

> [!note] 术语
> - 确认 (validation)：保证软件确实满足了用户需求而进行的一系列活动。
> - 验证 (verification)：指保证软件正确地实现了某个特定要求的一系列活动。

确认测试必须有用户积极参与，或者以用户为主进行。用户应该参与设计方案，使用用户界面输入测试数据并且分析评价测试的输出结构。为了使得用户能够积极主动地参与测试，特别是为了使用户能有效地使用这个系统，通常在验收之前由开发单位对用户进行培训。

确认测试通常使用黑盒测试法。应该仔细设计测试计划和测试过程。
- 测试计划：要进行的测试种类及进度安排。
- 测试过程：规定了用来检测软件是否与需求一致的测试方案。

> [!note] 确认测试的结果
> 1. 功能和性能与用户要求一致，软件是可以接受的。
> 2. 功能和性能与用户要求的有差距。
>
> 这个阶段发现的问题往往与需求分析阶段的差错有关，涉及的面通常比较广，因此解决起来比较困哪。

> [!note] 软件配置复查
> 确认测试的一个重要内容是复查软件配置。复查的目的是保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。

> [!note] Alpha 测试和 Beta 测试
> 如果软件是专门为某个客户开发的，可以进行一系列验收测试，以便用户确认所有需求都得到了满足。验收测试是由最终用户而不是系统的开发者进行的。
>
> 如果一个软件是为许多客户开发的，那么，让每个客户都进行正式的验收测试是不现实的。在这种情况下，绝大多数软件开发商都使用被称为 Alpha 测试和 Beta 测试的过程，来发现那些看起来只有最终用户才能发现的错误。
> 1. **Alpha 测试**：用户在开发者的场所进行，并且在开发者对用户的指导下进行测试。开发者负责记录发现的错误和使用中遇到的问题。总之，Alpha 测试是在受控的环境中进行的。
> 2. **Beta 测试**：由软件的最终用户们在一个或多个客户场所进行。与 Alpha 测试不同，开发者通常不在 Beta 测试的现场，因此 Beta 测试是软件在开发者不能控制的环境中的真实应用。
> 	 - 用户记录在 Beta 测试过程中遇到的一切问题，并且定期把这些问题报告给开发者。
> 	 - 接收到在 Beta 测试期间报告的问题之后，开发者对软件产品进行必要的修改，并准备向全体客户发布最终的软件产品。

## 白盒测试技术

不同的测试数据发现程序错误的能力差别很大，为了提高测试效率降低测试成本，应该选用高效的测试数据。因为不可能进行穷尽的测试，所以选用少量最有效的测试数据，做到尽可能完备的测试就更重要了。

本节叙述使在白盒方法测试软件时设计测试数据的典型技术。

### 逻辑覆盖

有选择地执行中某些最最有代表性的通路是对穷尽测试的唯一可行的替代方法。所谓逻辑覆盖是对同一系列系统测试过程的总称，这组测试过程逐渐进行越来越完整的通路测试。从覆盖源程序语句的详尽程度分析，大致有以下一些不同的覆盖标准：
1. 从逻辑的覆盖程度来看：
	1. **语句覆盖**：为了暴露程序中的错误，至少每个语句应该执行一次。语句覆盖的含义是，选择足够多的测试数据，使被测程序中每个语句至少执行一次。
		- 语句覆盖是很弱的逻辑覆盖标准。
	2. **判定覆盖**：又叫分支覆盖。不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次。
		- 判定覆盖比语句覆盖强，但是对程序逻辑的覆盖程度仍然不高。
	3. **条件覆盖**：不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。
		- 条件覆盖通常比判定覆盖强，因为它使判定条件表达式中每个结构都取到了两个不同的结果。而判定覆盖只关心整个判定表达式的值。
	4. **判定/条件覆盖**：同时满足判定覆盖和条件覆盖。选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。
	5. **条件组合覆盖**：条件组合覆盖是更强的覆盖标准，它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。
2. 从程序路径的覆盖程度来看：
	1. **点覆盖**：图论中点覆盖的定义如下：如果连通图 $G$ 的子图 $G'$ 是连通的，而且包含 $G$ 的所有结点，则称 $G'$ 是 $G$ 的点覆盖。满足点覆盖标准要求选取足够多的测试数据，使得程序执行路径至少经过流图的每个节点一次。
		- 显然，点覆盖标准与语句覆盖标准是相同。
	2. **边覆盖**：图论中边覆盖的定义如下：如果连通图 $G$ 的子图 $G'$ 是连通的，而且包含 $G$ 的所有边，则称 $G'$ 是 $G$ 的边覆盖。为了满足边覆盖，要求选取足够多的测试数据，使得程序执行路劲至少经过流图的每条边一次。
		- 通常，边覆盖和判定覆盖是一致的。
	3. **路径覆盖**：选取足够多的测试数据，使程序的每条可能路径都至少执行一次。

#### 基本路径测试

使用基本路径测试技术设计用例时，首先计算程序的环形复杂度，并用该复杂度为指南定义执行路径的基本集合，从该基本集合导出的测试用例可以保证程序中的每条语句至少执行一次，并且每条条件在执行时都将分别取真、假两种值。

使用基本路径测试技术设计测试用例的步骤如下：
1. 根据过程设计结果画出相应的流图。
2. 计算图的 [[软件工程/详细设计#McCabe 方法|环形复杂度]]。环形复杂度定量度量程序的逻辑复杂性。
3. 确定线性独立路径的基本集合。所谓独立路径是指引入程序的一个新的处理语句集合或一条新条件的路径。即*独立路径至少包含一条在定义该路径之前不曾使用的边*。
4. 设计可强制执行基本集合中每条路径的测试用例。

### 条件测试

用条件测试技术设计出的测试用例，能够检查程序模块中包含的逻辑条件。条件成分的类型包含布尔算符、布尔变量、布尔括弧、关系算法及算术表达式。如果条件错误，则至少条件的一个成分不正确，因此，条件错误的类型如下：
1. 布尔算符错 (布尔算法不正确，遗落布尔算法或有多余的布尔算符)
2. 布尔变量错
3. 布尔括弧错
4. 关系算法错
5. 算术表达式错

> [!note] 包含 $n$ 个变量的布尔表达式需要 $2^{n}$ 个测试。这个策略可以发现布尔算符、变量和括弧的错误，但是，该策略仅在 $n$ 很小时才是实用的。

> [!note] 条件测试的优点
> 1. 容易度量条件的测试覆盖率。
> 2. 程序内条件的测试覆盖率可以指导附加测试的设计。

### 循环测试

循环时大多数软件算法的基础，但是，在测试软件时往往未对循环结构进行足够的测试。循环测试是一种白盒测试技术，它专注于测试循环结构的有效性。
1. 简单循环：应该使用下列测试集来测试简单循环，其中 $n$ 是允许通过循环的最大次数：
	- 跳过循环
	- 只通过循环一次
	- 通过循环两次
	- 通过循环 $m$ 次，其中 $m<n-1$
	- 通过循环 $n-1,n,n+1$ 次
2. 嵌套循环：如果把简单循环的测试方法直接应用到嵌套循环，可能的测试数就会随着嵌套曾是的增加按几何级数增长，这会导致不切实际的测试数目。我们采用下面的方法：
	- 从最内层循环开始测试，把所有其他循环都设置为最小值。
	- 对最内层循环使用简单循环测试方法，而使外层循环的迭代参数取最小值，并为越界值或非法值增加一些额外的测试。
	- 由内向外，对下一个循环进行测试，但保持所有其他外层循环为最小值，其他嵌套循环为典型值。
	- 继续进行下去，直到测试完所有循环。
3. 串接循环。如果串接循环的各个循环都彼此独立，则可以使用前述的测试简单循环的方法来测试串接循环。但是，如果两个循环串接，并且第一个循环的循环计数器值是第二个循环的初始值，则这两个循环不是独立的。当循环不独立时，建议使用测试嵌套循环的方法来测试串接循环。

## 黑盒测试技术

黑盒测试着重测试软件功能。黑盒测试并不能取代白盒测试，它是与白盒测试互补的测试方法，它很可能发现白盒测试不易发现的其他类型的错误。

> [!note] 黑盒测试力图发现的错误
> 1. 功能不正确或遗漏了功能。
> 2. 界面错误。
> 3. 数据结构错误或外部数据库访问错误。
> 4. 性能错误。
> 5. 初始化和终止错误。

白盒测试在测试过程的早期阶段进行，而黑盒测试主要用户测试过程的后期。设计黑盒测试方案时，应该考虑下述问题：
1. 怎样测试功能的有效性。
2. 哪些类型的输入可构成好测试用例？
3. 系统是否对特定的输入值特别敏感？
4. 怎样划定数据类的边界？
5. 系统能够承受什么样的数据率和数据量？
6. 数据的特定组合将对系统产生什么影响？

### 等价划分

等价划分是一种黑盒测试技术，这种技术把程序的输入域划分成若干数据类，据此导出测试用例。一个理想的测试用例能够独立发现一类错误。

> [!note]
> 穷尽的黑盒测试通常时不现实的。因此，只能选取少了最有代表性的输入数据作为测试数据，以期用较小的代价暴露较多的程序错误。

等价划分法力图设计出能发现若干类程序错误的测试用例，从而减少必须设计的测试用例的数目。如果把所有可能的输入数据划分成若干等价类，则可以合理地做出下述假定：每类中的一个典型值在测试中的作用于这一类中所有其他值的作用相同。因此，可以从每个等价类中只取一组数据作为测试数据。

> [!note] 划分等价类
> 使用等价划分法设计测试方案首先需要划分输入数据的等价类，为此需要研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类。在确定输入数据的等价类时常常还需要分析输出数据的等价类，以便根据输出数据的等价类导出对应的输入数据等价类。
>
> 划分等价类需要经验，下述几条启发式规则可能有助于等价类的划分：
> 1. 如果规定了输入值的范围，则可以划分出一个有效等价类 (输入值范围)，两个无效等价类 (输入值过大或过小)。
> 2. 如果规定了输入数据的个数，则类似地也可以划分出一个有效等价类和两个无效等价类。
> 3. 如果规定了输入数据的一组值，而且数据对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类。
> 4. 如果规定输入数据必须遵守的规则，则可以划分出一个有效的等价类和若干个无效的等价类。
> 5. 如果规定了输入数据为整型，则可以划分出正整数、零、负整数 3 个有效类。
> 6. 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表。

划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤：
1. 设计一个新的测试方案以尽可能多地覆盖尚未覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止。
2. 设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止。

### 边界值分析

经验表明，处理边界情况时程序最容易发生错误。因此，设计使程序运行在边界情况附近的测试方案，暴露出程序错误的可能性更大一些。

使用边界值分析方法设计测试方案首先应该确定边界情况，这需要经验和创造性，通常输入等价类和输出等价类的比娜姐，就是应该着重测试的程序边界情况选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值。也就是说，按照边界值分析法，应该选取刚好等于、稍小于、稍大于等价类边界值的数据作为测试数据，而不是选取每个等价类内的典型值或任意值作为测试数据。

### 错误推测

错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。

## 调试

调试作为测试的后果出现，也就是说，调试是在测试发现错误之后排除错误的一个过程。虽然调制应该而且可以是一个有序过程，但是，目前它在很大程度上仍然是一项技巧。

调试过程总会有以下两种结果：
1. 找到问题的原因并把问题修正和排除掉。
2. 没有找到问题的原因。在这种情况下，调试人员可以猜想一个原因，并设计测试用例来验证这个假设，重复此过程直到找到原因并修正了错误。

> [!note] 调试途径
> 无论采用什么方法，调试的目标都是寻找软件错误的原因并修正错误。通常需要把系统地分析、直觉和运气组合起来，才能实现上述目标。一般来说，有下列 3 种调试途径：
> 1. 蛮干法：`print` 大法。
> 2. 回溯法：从发现症状的地方开始，人工沿程序控制流往回追踪分析源程序代码。
> 3. 原因排查法：对分查找法、归纳法和演绎法都属于原因排除法。
> 	- 对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，可以利用赋值语句或输入语句在程序中点附近注入这些变量的正确值，然后运行程序检查结果。如果输出结果是正确的，则错误原因在程序的前半部分。反之，错误在后半部分。
> 	- 归纳法：从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先先把和错误有关的数据组织起来分析，以便发现可能的错误原因，然后导出对错误原因的一个或多个假设，并利用已有数据来证明和排除这些假设。
> 	- 演绎法：从一般原理或提前出发，经过排除和精化的过程推导出结论。

## 软件可靠性

软件可靠性是程序在给定时间间隔内，按照规格说明书的规定成功地运行的概率。

通常用户也很关注软件系统可以使用的程度。一般来说，对于任何其故障是可以修复的系统，都应该同时使用可靠性和可用性衡量它的优劣程度。软件可用性的一个定义是，软件可用性是程序在给定时间点，按照规格说明书的规定，成功地运行的概率。

> [!note] 可靠性与可用性的差别
> - 可靠性意味着在 $0$ 到 $t$ 这段时间间隔内系统没有失效。
> - 可用性只意味着在时刻 $t$ 系统是正常运行的。

如果在一段时间内，软件系统故障停机时间分别为 $t_{d_{1}},t_{d_{2}}\cdots$，正常运行时间分别是 $t_{u_{1}},t_{u_{2}}\cdots$，则系统的稳态可用性为：
$$
A_{ss}=\dfrac{T_{up}}{T_{up}+T_{down}}
$$
其中
$$
T_{up}=\sum t_{ui},T_{down}=\sum t_{di}
$$
如果引入系统平均无故障时间 MTTF 和平均维修时间 MTTR 的概念，则系统稳态可用性可以变为
$$
A_{ss}=\dfrac{\text{MTTF}}{\text{MTTF}+\text{MTTR}}
$$
其中
- 平均维修时间 MTTR 是维修一个故障平均需要用的时间，它取决于维护人员的技术水平和对系统的熟悉程度，也和系统的可维护性有重要关系。
- 平均无故障时间 MTTF 是系统按规格说明书规定成功地运行的平均时间，它主要取决于系统中潜伏的错误的数目，因此和测试密切相关。

---
< [[软件工程/详细设计|详细设计]] | [[软件工程/维护|维护]] >
