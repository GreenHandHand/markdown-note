---
tags:
  - 软件工程
---

# 维护

在软件产品被开发出来并交付用户使用之后，就进入了软件的运行维护阶段。这个阶段是软件声明周期的最后一个阶段，其基本任务是保证软件在相当长的时期能够正常运行。

软件维护需要的工作量很大，平均来说，大型软件的维护成本高达开发成本的 4 倍作用。软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要的工作量，降低软件系统的总成本。

> [!note] 维护
> 所谓软件维护，就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。可以通过描述软件交付使用后可能进行的 4 项活动，具体定义软件维护：
> 1. 在任何大型程序使用期间，用户比如会发现程序错误，并且把它们遇到的问题报告给维护人员。把纠正和改正错误的过程称为**改正性维护**。
> 2. 软件的使用寿命很容易超过硬件的更新周期，远远长于最初开发这个软件时运行环境的寿命。因此，**适应性维护**就是为了和变化了的环境适当地配合而进行的修改软件的活动，是既必要又经常的维护活动。
> 3. 在使用软件的过程中用户往往提出增加新功能或修改已有的功能，还可能提出一般性的改进意见。为了满足这类要求，需要进行**完善性维护**。这项维护活动通常占软件维护工作的大部分。
> 4. 为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件时，出现了**预防性维护**。

## 软件维护的特点

1. 结构化维护与非结构化维护差别巨大：
	- 非结构化维护：如果软件配置的唯一成分是程序代码，那么维护活动从艰苦地评价程序代码开始，而且常常由于程序内部文档不足而使评价更困难。非结构化维护需要付出很大的代价，这种维护方式是没有使用良好定义的方法开发出来的软件的必然结果。
	- 结构化维护：如果有一个完整的软件配置存在，那么维护工作从评价设计文档开始，确定软件重要的结构特点、性能特点以及接口特点。估量要求的改动将带来的影响，并且计划实施途径。然后修改设计并且对所做的修改进行仔细复查。接下来编写相应的源程序代码，使用在测试说明中包含的信息进行回归测试，最后把修改后的软件再次交付使用。
2. 维护的代价高昂。
3. 维护的问题很多：与软件维有关的绝大多数问题，都可以归因于软件定义和软件开发的方法有缺点。在软件生命周期的头两个时期没有严格而又科学的管理和规划，几乎必然会导致在最后阶段出现问题。

## 软件维护过程

维护过程本质上是修改和压缩了的软件定义和开发过程，而且事实上远在提出一项维护要求之前，与软件维护有关的工作已经开始了。首先必须建立一个维护组织，随后必须确定报告和评价的过程，而且必须为每个维护要求规定一个标准化的事件序列。此外，还应该建立一个适用于维护活动的记录保管过程，并规定复审标准。
1. 维护组织：在维护活动开始之前就明确维护责任是十分重要的，这样可以大大减少维护过程中可能出现的混乱。
2. 维护报告：应该用标准化的格式表达所有软件维护要求。维护要求表是一个外部产生的文件，它是计划维护活动的基础。软件组织内部应该制订出一个软件修改报告，在拟定进一步的维护计划之前，把软件修改报告提交给变化授权人审查批准。它给出如下信息：
	1. 满足维护要求表中提出的要求所需要的工作量。
	2. 维护要求的性质。
	3. 这项要求的优先次序。
	4. 与修改有关的事后数据。
3. 维护的事件流。
4. 保存维护记录：应该为每项维护工作都收集维护记录数据，可以利用这些数据构成一个维护数据库的基础。
5. 评价维护活动：如果已经开始保护维护记录了，则可以对维护工作做一些定量度量。根据对维护工作定量度量的结果，可以做出关于开发技术、语言选择、维护工作量规划、资源分配及其他许多方面的决定。

> [!note] 维护阶段的事件流
> ![[Assets/维护-1.png]]

> [!note] 维护记录
> 1. 程序标识。
> 2. 源语句数。
> 3. 机器指令条数。
> 4. 使用的程序设计语言。
> 5. 程序安装的日期。
> 6. 自动安装以来程序运行的测试。
> 7. 自从安装以来程序失效的次数。
> 8. 程序变动的层次和标识。
> 9. 因程序变动而增加的源语句数。
> 10. 因程序变动而删除的源语句数。
> 11. 每个改动耗费的人时数。
> 12. 程序改动的日期。
> 13. 软件工程师的名字。
> 14. 维护要求表的表示。
> 15. 维护类型。
> 16. 维护开始和完成的日期。
> 17. 累积用于维护的人时数。
> 18. 与完成的维护相联系的纯效益。

## 软件的可维护性

可以把软件的可维护性定性地定义为：维护人员理解、改正、改动或改进这个软件的难易程度。提供软件的可维护性是支配软件工程方法学所有步骤的关键目标。

### 决定软件可维护性的因素

维护就是在软件交付使用后进行的修改，修改之前必须理解待修改的对象，修改之后应该进行必要的测试，以保证所做的修改是正确的。如果是改正性维护，还必须预先进行调试以确定错误的具体位置。因此，决定软件可维护性的因此主要有下述 5 个：
1. **可理解性**：表现为外来读者理解软件的结构、功能、接口和内部处理过程的难易程序。模块化、详细的设计文档、结构化设计、程序内部的文档和良好的各级程序设计语言等，都对提高软件的可理解性有重要贡献。
2. **可测试性**：诊断和测试的容易程序取决于软件容易理解的程序。良好的文档对诊断和测试是至关重要的，此外，软件结构，可用的测试工具和调试工具，以及以前设计的测试过程也都是非常重要的。
3. **可修改性**：耦合、内聚，信息隐藏，局部化，控制域与作用域的关系等，都影响软件的可修改性。
4. **可移植性**：软件可移植性指，把程序从一种计算环境转移到另一种计算环境的难易程度。
5. **可重用性**：所谓重用指同一事物不做修改后稍加改动就可以在不同环境中多次重复使用。大量使用功能可重用的软件构件来开发软件，可以从下述两个方面提高软件的可维护性。
	1. 通常，可重用的软件构件在开发时都经过很严格的测试，可靠性比较高，且在每次重用过程中都会发现并清除一些错误。随着时间推移，这样的构件将变成实质上无错误的。因此，软件中使用的可重用构件越多，软件的可靠性越高，修正性维护需求越少。
	2. 很容易修改可重用的软件构件使之再次应用在新环境中，因此软件使用的可重用构件越多，适应性和完善性维护也就越容易。

### 文档

文档是影响软件可维护性的决定性因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。软件系统的文档可以分为用户文档和系统文档两类。
- 用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的。
- 系统文档描述系统设计，实现和测试等方面的内容。

> [!note] 用户文档
> 用户文档是用户了解系统的第一步，它应该能使用户获得对系统的准确的初步印象。文档的结构方式应该使用户能够方便地根据需要阅读有关的内容。用户文档至少包含下述 5 方面的内容：
> 1. 功能描述，说明系统能够做什么。
> 2. 安装文档，说明怎样安装这个系统以及怎样使系统适应特定的硬件配置。
> 3. 使用手册，简要说明如何着手使用这个系统 (应该通过丰富的例子说明怎样使用常用的系统功能，还应该说明用户操作错误时怎样恢复和重新启动)。
> 4. 参考手册，详尽描述用户可以怎样使用所有系统设施以及它们的使用方法，还应该解释系统可能产生的各种出错信息的含义。
> 5. 操作员指南，说明操作员应该如何处理使用中出现的各种问题。

> [!note] 系统文档
> 所谓的系统文档是指从问题定义、需求说明到验收测试计划这样一系列和系统实现有关的文档。

## 软件再工程过程

典型的软件再工程过程模型定义了 6 类活动。
1. 库存目录分析：应该仔细分析库存目录，按照业务重要程度、寿命、当前可维护性、预期的修改次数等标准，把库中的应用系统排序，从中选出再工程的候选者，然后明智地分配再工程所需要的资源。
2. 文档重构：老程序固有的特点是缺乏文档。具体情况不同，处理这个问题的方法也不同。
	1. 建立文档非常消耗时间，不可能为数百个程序都重新建立文档。如果一个程序是相对稳定的，正在走向其有用生命的终点，而且可能不会再经历什么变化，那么让它维持现状是一个明智的选择。
	2. 为了便于今后的维护，必须更新文档，但是由于资源有限，应采用*使用时建文档*的方法。
	3. 如果某应用系统是完成业务工作的关键，而且必须重构全部文档，则仍然应该设法把文档工作减小到必需的最小量。
3. 逆向工程：逆向工程是一个恢复设计结果的过程，逆向工程工具从现存的程序代码中抽取有关数据、体系结构和处理过程的设计信息。
4. 代码重构：代码重构是最常见的再工程活动。为了完成代码重构活动，首先用重构工具分析源代码，标注出和结构化设计概念相违背的部分，然后重构有问题的代码。最后，复审和测试生成的重构代码并更新代码文档。
5. 数据重构：与代码重构不同，数据重构发生在相当低的抽象层次上，它是一种全范围的再工程活动。在大多数情况下，数据重构始于逆向工程活动，分解当前使用的数据体系结构，必要时定义数据模型，标识数据对象和属性，并从软件质量的角度复审现存的数据结构。
6. 正向工程：也称革新或改造，这样活动不仅从现有程序中恢复设计信息，而且使用该信息去改变或重构现有系统，以提高整体质量。

---
< [[00-笔记/软件工程/实现|实现]] | [[00-笔记/软件工程/面向对象方法学|面向对象方法学]] >
