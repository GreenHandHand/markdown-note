---
tags:
  - 最优化
---

# 多目标优化问题

![[Assets/Pasted image 20230504152458.png]]

## 多目标优化概念

### 解空间与目标函数值空间

- 目标函数值空间 (Objective space)
- 解空间 (Variable space)
  ![[Assets/Pasted image 20230504152654.png]]
### 支配 (dominate)

支配的概念：
- 解 A 支配解 B
- 解 B 被解 A 支配
- 解 A 的所有目标函数取值都不差于解 B，且解 A 的至少一个目标函数取值优于解 B

非支配集合：
对于一个集合 P，它的非支配集合是 P 的子集、包含所有不被任何集合 P 中其它解支配的解。

### 帕累托最优集合

可行域的非支配集合即定义为<font color="#ff0000">帕累托最优集合</font>（Pareto-optimal set）
所有帕累托最优解对应的目标函数值即构成<font color="#ff0000">帕累托最优前沿</font>（Pareto-optimal front）

## 多目标优化的目标

目标：找到帕累托最优集合，即：
1. 算法找到的解的目标函数值要趋近于帕累托最优前沿
2. 算法找到的解需要尽可能分散

## 经典算法-加权求和法

将目标函数值加权求和，人为调整 $w$ 值得到不同的解，理想情况下，通过不断改变 $w$ 的值，最终可以得到帕累托最优前沿。

![[Assets/Pasted image 20230504154340.png]]

#### 可行解对应目标函数值为凸集时

通过不断的调整 $w$ 的值，可以得到所有的帕累托最优解。

![[Assets/Pasted image 20230504154940.png]]

#### 可行域对应目标函数值为非凸集时

无论如何设置 $w$ 的值，都无法得到所有的帕累托最优解。

![[Assets/Pasted image 20230504155055.png]]

因此在目标函数非凸的时候，不能通过加权求和法得到帕累前沿，因此需要使用其他的方法来得到需要的最优解。

## 多目标优化的智能优化算法（NSGA-II）

使用智能优化算法求解多目标优化问题有天然的优势，在每一次迭代优化时，应当遵从 [[#多目标优化的目标]] 对解进行优化。

### 解的筛选

#### 排序

多种方法可以衡量解靠近帕累托前沿的程度：
- 支配深度 (Dominance depth)
- 支配次序 (Dominance rank)
- 支配数目 (Dominance count)

这里介绍利用支配深度对解进行排序。
1. 找到帕累托最优解
2. 标记为 front 1 并移除
3. 重复上面的两个过程，并标记为 front n，直到遍历所有解

#### 多样性

多种方式可以保证解足够足够分散，这里介绍**基于拥挤距离**进行筛选。该值越大，说明该解距离其余解越远，越应该保留。
![[Assets/Pasted image 20230504160901.png]] ![[Assets/Pasted image 20230504161258.png]]
### NSGA-II 算法

- 基于 NSGA 算法提出
- 基于[[00-笔记/最优化/进化算法/遗传算法]]提出

对遗传算法进行修改：
![[Assets/Pasted image 20230504163105.png]]

#### 评估解的质量

1. 计算每个解的目标函数值
2. 根据支配深度对解进行排序，得到多个前沿
3. 分别对每个前沿中的解计算拥挤程度
4. 完成对每个解的评估，其中每个解都有两个评估标准，按照支配深度->拥挤程度的顺序进行比较。

#### 解的筛选

锦标赛式选择法（binary tournament selection）：
- 将所有的解两两分组，每一组选择较优解，如果解的支配深度、拥挤程度相同，则随机选择。

#### 基因交叉与基因突变

使用实码遗传算法的方式进行基因交叉与基因突变。