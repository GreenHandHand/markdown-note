---
tags:
  - 编译原理
---

# 语法分析

本节介绍语法分析部分。首先介绍概念，然后介绍手工实现的技术，最后介绍用于自动化工具的算法。用于源程序中可能会包含错误，因此我们还将讨论如何拓展语法分析方法，以便从常见错误中恢复。

在设计语言时，每种程序设计语言都有一组精妙的规则来描述程序的语法结构。程序设计语言的语法可以使用上下文无关文法或者 BNF 表示法来描述，文法为语言设计者和编译器编写者都提供了很大的方便。

文法分析的目的是实现一个将词法分析输出的词素流转换为一棵语法树，便于之后的语义分析与中间代码的翻译。

## 引论

在本节中，我们将探讨语法分析器是如何集成到一个典型的编译器中的。然后我们将研究算术表达式的典型文法。通过表达式文法已经足以说明语法分析的本质，因为处理表达式的语法分析技术可以用于处理程序设计语言的大部分构造。这一节的最后将讨论错误处理的问题，因为当语法分析器发现它的输入不能由它的文法生成时，它必须做出适当的反应。

### 语法分析器的作用

在我们的编译器模型中，语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成。我们希望语法分析器能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。

对于良构 (well-formed) 的程序，语法分析器构造出一颗语法分析树，并把它传递给编译器的其他部分进行进一步处理。实际上，不需要显式的构造出这颗语法分析树，因为对源程序的检查和翻译动作可以和语法分析交错完成，因此，语法分析器和前端的其他部分可以使用一个模块实现。

处理文法的语法分析器大体上分为三种类型：通用的、自顶向下的、自底向上的。通用的语法分析方法虽然可以对任意文法进行语法分析，但是这些通用方法效率很低，不能用于编译器产品。因此我们这里主要讨论*自顶向下*和*自底向上*两种方式。
- 自顶向下：从语法分析树的顶部 (根节点) 开始向底部 (叶子节点) 构造语法分析树
- 自底向上：从叶子节点开始，逐渐向根节点方向构造

在这两种方法中，语法分析器的输入总是按照从左向右的方式被扫描的，每次扫描一个符号。

最高效的自顶向下方法和自底向上方法只能处理某些文法子类，但是其中的某些子类，特别是 LL 和 LR 文法，其表达能力已经足够描述现代程序设计语言的大部分语法构造了。手工实现的语法分析器通常使用 LL 文法。处理较大的 LR 文法类的语法分析器通常是使用自动化工具得到的。

在本章中，我们假设语法分析器的输出是语法分析树的某种表示形式。该语法分析树对应于来自词法分析的词法单元流。在实践中，语法分析过程可能包含多个任务，比如将不同词法单元的信息收集到符号表中，进行类型检查和其他类型的语义分析，以及产生中间代码。

### 代表性文法

为了便于参考，我们先给出即将在本章中被研究的算法。对于 `while` 或者 `int` 这样的关键字开头的构造进行语法分析相对容易，因为关键字可以引导我们选择适当的文法产生式来匹配输入。因此我们主要关注表达式。因为运算符的结合性和优先级，表达式的处理更具挑战性。

下面的文法指名了运算符的结合性和优先级。
- E 表示一组以+号分割的项所组成的表达式；
- T 表示一组以\*进行分割的因子所组成的项；
- F 表示因子，它可能是括号括起来的表达式，也可能使标识符；

## 上下文无关文法

上下文无关文法，简称文法。在编译器设计中，文法用于组织编译器前端。文法自然的描述了大多数程序设计语言构造的层次化语法结构，例如 if-else 语句通常有以下形式：
$$
\textbf{if}\ (expression)\ statement\ \textbf{else}\ statement
$$
即一个 if-else 语句由关键词 if、左括号、表达式、右括号、一个语句、关键词 else 和另一个语句连接而成。如果我们使用变量 expr 来表示表达式，用变量 stmt 表示语句，那么这个构造规则可以表示为
$$
stmt\to \textbf{if}\ (expr)\ stmt\ \textbf{else} \ stmt
$$
其中箭头 ($\to$) 可以读作“可以具有以下形式”，这样的规则称为*产生式* (production)。
- 在一个产生式中，像关键词 if 和括号这样的词法元素称为*终结符号* (terminal)。
- 像 expr 和 stmt 这样的变量表示终结符号的序列，称为*非终结符号* (nonterminal)。

### 文法定义

一个上下文无关文法 (context-free grammar)由四个元素组成：
1. 一个*终结符号*集合，它们有时也称为词法单元。终结符号是该文法定义的语言的基本符号的集合，是组成串的基本单位。在上面的例子中，终结符号是关键词 if 和 else 以及符号\(和\)。
2. 一个*非终结符号*集合，它们有时也称语法变量。每个非终结符号表示一个终结符号串的结合，是表示串的集合的语法变量。在上面的例子中，stmt 和 expr 是非终结符号。非终结符号给出了语言的层次结构，这种层次结构是语法分析的关键。
3. 在一个文法中，某个非终结符号被指定为*开始符号*。这个符号表示的串集合就是这个文法生成的语言。按照惯例，应当最先列出开始符号的表达式。
4. 一个文法的*产生式*描述了将终结符号和非终结符号组成串的方法。每个产生式由下列元素组成：
	1. 一个被称为*产生式头*或*左部*的非终结符号。这个产生式定义了这个头代表的串集合的一部分。
	2. 符号 $\to$，有时也使用符号 $::=$。
	3. 一个由零个或多个终结符号与非终结符号组成的*产生式体*或*右部*。产生式体中的成分描述了产生式头上的非终结符号所对应的串的某种构造方法。

### 符号表示的约定

为了避免总是声明什么是终结符号，什么是非终结符号，我们在后续对文法符号的表示进行如下约定：
1. 下面的符号是终结符号
	1. 在字母表里排在前面的小写字母，如 a/b/c
	2. 运算符号，如+-\*\/
	3. 标点符号，比如括号、逗号等
	4. 数字 0-9
	5. 黑体字符串，如 $\textbf{id}$ 或者 $\textbf{if}$，每个这样的字符串表示一个终结符号
2. 下面的符号是非终结符号
	1. 在字母表里排在前面的大写字母，如 A、B、C
	2. 字母 S，它出现时通常表示开始符号
	3. 小写、斜体的名字，如 $expr$ 和 $stmt$
	4. 当讨论程序设计语言的构造时，大写字母可以用于表示代表程序构造的非终结符号，比如表达式、项和因子的非终结符号分别是 E、T 和 F。
3. 在字母表中排在后面的大写字母表示文法符号，也就是说它们表示终结符号或者非终结符号。
4. 在字母表中排在后面的小写字母表示终结符号串。
5. 小写希腊字母表示文法符号串。
6. 具有相同的头的一组产生式，例如 $A\to\alpha_1,\quad A\to\alpha_2$，可以写作 $A\to\alpha_1\vert\alpha_2$，我们把 $\alpha_k$ 称为 $A$ 的不同*可选体*。
7. 除非特别说明，否则第一个产生式的头就是开始符号。

### 推导

根据文法推导符号串时，我们首先从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体。可以从开始符号推导到所有的终结符号串的集合称为该文法定义的*语言* (language)。

语法分析 (parsing) 的任务是：接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法。如果不能从文法的开始符号推导得到该终结符号串，则报告终结符号串中包含的语法错误。

如果我们将产生式看作重写规则，就可以从推导的角度精确的描述构造语法分析树的方法。例如，只考虑下面的只有一个非终结符号 E 的文法：
$$
E\to E+E\mid E*E\mid -E\mid (E)\mid \textbf{id}
$$
产生式 $E\to -E$ 表明，如果 $E$ 是一个表达式，那么 $-E$ 也必然是一个表达式。将 $E$ 替换为 $-E$ 的过程写作
$$
E\Rightarrow -E
$$
读作 $E$ 推导出 $-E$。这个推导过程可以证明某一表达式是符合该文法的表达式。

要给出推导的一般性定义，考虑一个文法符号序列中间的非终结符号 $A$，比如 $\alpha A\beta$，其中 $\alpha$ 和 $\beta$ 都是任意的文法符号串。假设 $A\to\gamma$ 是一个产生式，那么我们写作
$$
\alpha A\beta\Rightarrow \alpha\gamma \beta
$$
符号 $\Rightarrow$ 表示通过一步推出。当一个推导序列 $\alpha_1\Rightarrow\alpha_2\Rightarrow\cdots\Rightarrow\alpha_n$ 将 $\alpha_1$ 替换为 $\alpha_n$，我们说 $\alpha_1$ 推导 $\alpha_n$。我们可以使用 $\overset{*}{\Rightarrow}$ 符号来表示*经过零不或者多步推导出*。因此：
1. 对于任何串 $\alpha$，$\alpha \overset{*}{\Rightarrow}\alpha$，并且
2. 如果 $\alpha \overset{*}{\Rightarrow}\beta$ 且 $\beta\Rightarrow\gamma$，那么 $\alpha\overset{*}{\Rightarrow}\gamma$

> 类似的，使用 $\overset{+}{\Rightarrow}$ 表示*经过一步或者多步推导出*。

如果 $S\overset{*}{\Rightarrow}\alpha$，其中 $S$ 是文法 $G$ 的开始符号，我们说 $\alpha$ 是 $G$ 的一个*句型* (sentential form)。请注意，一个句型可能既包含终结符号又包含非终结符号，也可能是空串。文法 $G$ 的一个*句子* (sentence) 是不包含非终结符号的句型，一个文法*生成的语言*是它的所有句子的集合。

因此，一个终结符号串 $w$ 在 $G$ 生成的语言 $L(G)$ 中，当且仅当 $w$ 是 $G$ 的一个句子 ($S\overset{*}{\Rightarrow}w$)。

这种可以由文法生成的语言被称为上下文无关语言。如果两个文法生成相同语言，这两个文法就是等价的。

为了理解语法分析器是如何工作的，我们将考虑在每个推导步骤中，按照如下方式选择被替换的非终结符号的两种推导过程：
1. 在*最左推导* (leftmost derivation) 中，总是选择每个句型的最左非终结符号。如果 $\alpha\Rightarrow\beta$ 是一个推导步骤，且被替换的是 $\alpha$ 中的最左非终结符号，我们写作 $\alpha\underset{lm}{\Rightarrow}\beta$。
2. 在*最右推导* (rightmost derivation) 中，总是选择最右边的非终结符号，此时我们写作 $\alpha\underset{rm}{\Rightarrow}\beta$。

根据我们的表示惯例，每个最左推导式步骤都可以写作 $\omega A\gamma\underset{lm}{\Rightarrow}\omega \delta \gamma$，其中 $\omega$ 只包含终结符号，$A\to\delta$ 是被应用的产生式，而 $\gamma$ 是一个文法符号串。为了强调 $\alpha$ 经过一个最左推导得到 $\beta$，我们写作 $\alpha\overset{*}{\underset{lm}{\Rightarrow}}\beta$。如果 $S\overset{*}{\underset{lm}{\Rightarrow}}\alpha$，那么我们说 $\alpha$ 是当前文法的*最左句型* (left-sentential form)。对于最右推导也有相似的定义，最右推导有时也被称为*规范推导* (canonical derivation)。

### 语法分析树和推导

如果非终结符号 $A$ 有一个产生式 $A\to XYZ$，那么在语法分析树中就可能有一个标号为 $A$ 的内部节点，该节点有三个子节点，从左向右的标号分别为 $X、Y、Z$：
![[Pasted image 20240330212309.png]]
正式的讲，给定一个上下文无关文法，该文法的一颗语法分析树 (parse tree) 是具有以下性质的树：
1. 根节点的标号为文法的开始符号
2. 每个叶子节点的标号为一个终结符号或者 $\epsilon$
3. 每个内部节点的标号为一个非终结符号
4. 如果非终结符号 $A$ 为某个内部节点的标号，并且它的子节点的标号从左向右分别为 $X_1,X_2,\dots,X_n$, 那么必然存在产生式 $A\to X_1X_2\cdots X_n$ 其中 $X_n$ 既可以是终结符号，也可以是非终结符号。

语法分析树是推导的图形表示形式，它过滤掉了推导过程中对非终结符号引用产生式的顺序。语法分析树的每个内部节点表示一个产生式的应用。该内部节点的标号是此产生式投中的非终结符号 $A$, 这个节点的子节点的标号从左到右组成了在推导过程中替换这个 $A$ 的产生式体。

一颗语法分析树的叶子节点的标号既可以是非终结符号，也可以是终结符号。从左到右排列这些符号就可以得到一个句型，它称为这这颗树的*结果*(yield) 或者*边缘* (frontier)。

为了了解推导和语法分析树之间的关系，考虑任意推导 $\alpha_1\Rightarrow\alpha_2\Rightarrow\dots\Rightarrow\alpha_n$，其中 $\alpha_1$ 是单个非终结符号 $A$，对于推导中的每个句型 $\alpha_i$，我们可以构造出一个结果为 $\alpha_i$ 的语法分析树。这个构造过程是对 $i$ 的一次归纳。

基础：$\alpha_1=A$ 的语法分析树就是标号为 $A$ 的单个节点。

归纳步骤：假设我们已经构造出了一棵结果为 $\alpha_{i-1}=X_1X_2\cdots X_k$ 的语法分析树，假设 $\alpha_i$ 是将 $\alpha_{i-1}$ 中的某个非终结符号 $X_j$ 替换为 $\beta=Y_1Y_2\cdots Y_m$ 而得到的句型。也就是说，在这个推导的第 $i$ 步中，对 $\alpha_{i-1}$ 应用规则 $X_j\Rightarrow\beta$，推导出 $\alpha_i=X_1X_2\cdots X_{j-1}\beta X_{j+1}\cdots X_k$。

由于语法分析树和最左/右推导之间存在一对一的关系，因此在接下来的内容中，我们将频繁地通过构造最左推导或者最右推导来进行语法分析。最左推导和最右推导都以一种特定的顺序来替换句型中的符号，因此它们也过滤掉了顺序上的不同。

不难说明，每一棵语法分析树都和唯一的最左推导以及最右推导相关联。

一个文法的语言的另一个定义指任何能够由某棵语法分析树生成的符号串的集合。为了一个给定的终结符号串构建一棵语法分析树的过程称为对该符号串进行语法分析。

### 二义性

在根据一个文法讨论某个符号串的结构时，我们必须非常小心。一个文法可能有多颗语法分析树能够给生成同一个给定的终结符号串。这样的文法称为具有*二义性* (ambiguous)。要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两棵以上的语法分析树的的结果。

因为具有两棵以上语法分析树的符号串通常具有多个含义，所以我们需要为编译引用设计出没有二义性的文法，或者在使用二义性文法时使用附加的规则来消除二义性。

大部分语法分析器都期望文法是无二义性的，否则我们不能为一个句子唯一的选定语法分析树。在某些情况下，经过精心选择的二义性文法也可以带来方便。但同时需要使用消二义性规则来抛弃不想要的语法分析树，只为每个句子留下一棵语法分析树。

### 上下文无关文法和正则表达式

在结束关于文法及其性质的讨论之前，我们要说明文法是比正则表达式表达能力更强的表示方法。每个可以使用正则表达式描述的构造都可以使用文法描述，但是反之不成立。换句话说，每个正则语言都是一个上下文五无关语言，但是反之不成立。

## 设计文法

文法能够描述程序设计语言的大部分语法，比如，在程序中标识符需要先声明然后使用，但是这个要求不能通过一个上下文无关文法来描述。因此，一个语法分析器接受的词法单元序列构成了程序设计语言的超集。编译器的后续步骤必须对语法分析器的输出进行分析，以保证源程序遵守那些没有被语法分析器检查的规则。

本节将讨论如何在词法分析器和语法分析器之间分配工作，然后考虑几个用来使文法更加适用于语法分析的转换方法。其中一个技术可以消除文法二义性，其他基础可以用于改写文法，使得文法适用于自顶向下的语法分析。

### 词法分析和语法分析

语法分析是决定如何使用一个文法生成一个终结符号串的过程。在讨论这个问题时，我们可以想象我们正在构建一个语法分析树，这样可以帮助我们理解分析的过程，尽管在实践中编译器没有真的构造出这棵树。然而，原则上语法分器必须能够构造出语法分析树，否则将无法保证翻译的正确性。

我们之前提到，任何能够使用正则表达式描述的东西都可以使用文法描述。那么为什么我们需要使用正则表达式来定义一个语言的词法语法？理由有多个：
1. 将一个语言的语法结构分为词法和非词法两部分，可以很方便地讲编译器前端模块化，将前端分解为大小适中的两个组件。
2. 一个语言的词法规则通常很简单，我们不需要使用像文法这样功能强大的表示方法来描述这些规则。
3. 和文法相比，正则表达式通常提供了更加简洁且易于理解的表示词法单元的方法。
4. 根据正则表达式自动构造得到的词法分析器的效率要高于根据任意文法自动构造得到的分析器。

不存在一个严格的指导方针来规定那些东西应当放到词法规则中。
- 正则表达式适合描述诸如标识符、常量、关键字、空白这样的语言构造。
- 文法适合描述嵌套结构，比如对称的括号对、匹配的 begin-end，相互对应的 if-then-else 等。这种嵌套结构不能使用正则表达式描述。

### 左递归的消除

递归下降语法分析器有可能陷入无限循环。当出现如下所示的左递归产生式时，分析器就会陷入无限循环：
$$
expr\to expr + term
$$
在这里，产生式体的最左边的符号和产生式头部的非终结符号相同。假设 $expr$ 对应过程决定使用这个产生式，因为产生式的开头是 $expr$，所以 $expr$ 对应的过程将被递归调用。由于只有当产生式体中的一个终结符号被成功匹配时，向前看符号才会发生改变，因此在对 $expr$ 的两次调用之间输入符号没有发生改变。结果，第二次 $expr$ 调用所做的事情和第一次调用所做的完全相同，这意味这会对 $expr$ 进行第三次调用，并不断重复，进入无限循环。

如果一个文法中有一个非终结符号 $A$ 使得对某个串 $\alpha$ 存在一个推导 $A\overset{+}{\Rightarrow} A\alpha$，那么这个文法就是*左递归* 的 (left recursive)。自顶向下语法分析方法不能处理左递归的文法，因此需要一个转换方法来消除左递归。

通过改写有问题的产生式就可以消除左递归。考虑两个产生式：
$$
A\to A\alpha \mid \beta
$$
的非终结符号 $A$，其中 $\alpha$ 和 $\beta$ 是不以 $A$ 开头的终结符号/非终结符号序列。例如，在产生式
$$
expr\to expr + term\mid term
$$
中，非终结符号 $A=expr$，串 $\alpha=+term$，串 $\beta=term$。因为产生式 $A\to A\alpha$ 的右部的最左符号是 $A$ 本身，不断应用这个产生式将在 $A$ 的右边生成一个 $\alpha$ 的序列。当 $A$ 最终被替换为 $\beta$ 时，我们就得到了一个在 $\beta$ 后有 0 个或者多个 $\alpha$ 的序列。

我们可以将 $A\to A\alpha\mid\beta$ 替换为非左递归的产生式：
$$
\begin{aligned}
A&\to\beta A'\\
A'&\to \alpha A'\mid \epsilon
\end{aligned}
$$
这样的替换不会改变从可以从 $A$ 推导到的串的集合。这个规则本身已经足够用以处理很多的文法。该方法是通过消除表达式中的立即左递归而得到的。立即左递归可以使用下面的方式。

## 自顶向下的语法分析

自顶向下的语法分析可以被看作是为输入串构造语法分析树的问题，它从语法分析树的根节点开始，按照先序创建这颗语法分析树的各个节点。自顶向下语法分析也可以被看作寻找输入串的最左推导的过程。

在一个自顶向下语法分析的每一步中，关键问题是确定对一个非终结符号应用哪个产生式。一旦选择了某个产生式，语法分析过程的其余部分将负责将相应产生式体中的终结符号和输入相匹配。

本节首先给出被称为*递归下降语法分析*的自顶向下语法分析的通用形式，这种方法可能需要进行回溯，已找到要应用的正确产生式。

### 递归下降的语法分析

一个递归下降语法分析程序由一组过程组成，每个非终结符号有一个对应的过程。程序的执行从开始符号对应的过程开始，如果这个过程的过程体扫描了整个输入串，它就停止执行并宣布语法分析成功完成。下面是一个自顶向下语法分析器中一个非终结符号对应的典型过程：
```c
void A(){
	// 选择一个产生式, A->X1 X2 X3 ...
	for(i = 1 to k){
		if(X[i] 是一个非终结符号){
			// 调用过程 X[i]
			X[i];
		}else if(X[i] 等于当前的输入符号 a){
			读入下一个输入符号;
		}else{
			raise Error;
		}
	}
}
```

通用的递归下降分析技术可能需要回溯。也就是说，它可能需要重复扫描输入。然而，在对程序设计语言的构造进行语法分析时很少需要回溯，因此需要回溯的语法分析器并不常见。即使在自然语言语法分析这样的场合，回溯也不是很高效，因此人们更加倾向于基于表格的方法。

### FIRST 和 FOLLOW

自顶向下和自底向上语法分析器的构造可以使用和文法 $G$ 相关的两个函数 `FIRST` 和 `FOLLOW` 来实现。在自顶向下语法分析过程中，`FIRST` 和 `FOLLOW` 使得我们可以根据下一个输入符号来选择应用哪个产生式。

`FIRST(α)` 被定义为可从 $\alpha$ 推导得到的串的首符号的集合，其中 $\alpha$ 是任意文法符号串。如果 $\alpha\overset{*}{\Rightarrow} \epsilon$，那么 $\epsilon$ 也在 `FIRST(α)` 中。

对于非终结符号 $A$，`FOLLOW(A)` 被定义为可能在某些句型中紧跟在 $A$ 右边的终结符号的集合。也就是说，