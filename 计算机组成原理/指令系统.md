---
tag:
  - 计算机组成原理
---

# 指令系统

指令 (又称为机器指令)：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一条计算机的所有指令的几何构成该机的**指令系统**，也称为**指令集**。

一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

## 指令格式

### 操作码、地址码的概念

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常要包括操作码字段和地址码字段两个部分。
- 操作码 (OP)：做什么
- 地址码 (A)：对谁做

一条指令可能包含一个或者多个地址码，根据地址码的数目不同，可以将指令分为零地址指令，一地址指令，二地址指令等。
- 零地址指令：
	1. 不需要操作数，如空操作、停机、关中断等。
	2. 堆栈计算机中，两个操作隐含存放在栈顶和次栈顶，计算结果压回栈顶即可。因此堆栈计算机中不需要操作数。
- 一地址指令：$OP+A$
	1. 只需要单操作数，如加一，减一，取反，求补等。记为 $OP(A_1)\to A_1$，完成一条指令需要 3 次访存：取指、读 $A_1$，写 $A_1$。
	2. 需要两个操作数，但其中一个操作数隐含在某个寄存器中 (如 ACC 中)，可以记为 $(ACC)OP(A_1)\to ACC$。完成这样的指令只需要 2 次访存：取指，读 $A_1$。
- 二地址指令：$OP+A_1+A_2$，其中 $A_1$ 为目标操作数，$A_2$ 为源操作数
	1. 常用于需要两个操作数的算术运算，逻辑运算相关指令。指令的含义为 $(A_1)OP(A_2)\to A_1$，完成一条指令需要 4 次访存，即取指、读 $A_1$，读 $A_2$，写 $A_1$。
- 三地址指令：$OP+A_1+A_2+A_3$，其中 $A_1$ 与 $A_2$ 同二地址指令，$A_3$ 表示结果地址。
	1. 常用于需要两个操作数的算术运算、逻辑运算相关指令。指令含义为 $(A_1)OP(A_2)\to A_3$。完成一条指令需要访存 4 次，即取指、读 $A_1$、读 $A_2$、写 $A_3$。
- 四地址指令：$OP+A_1+A_2+A_3+A_4$，其中 $A_4$ 为下址，即下一条指令的地址。

### 指令的分类

#### 按照指令长度分类

下面是指令长度的几个概念：
- 指令字长：一条指令的总长度。
- 机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数。通常和 $ALU$ 直接相关。
- 存储字长：一个存储单元中的二进制代码位数。通常和 $MDR$ 为主相同。

可以分为半字长指令、单字长指令、双字长指令。指令长度是机器字长的多少倍。指令字长会影响取指令所需的时间。

- 定长指令字结构：指令系统中所有的指令的长度相同。
- 变长指令字结构：指令系统中所有的指令的长度不等。

#### 按操作码长度分类

- 定长操作码：指令系统中所有指令的操作码长度都相同。
- 可变长操作码：指令系统中各指令的操作码长度可变。

#### 按操作类型分类

1. 数据传送：
	- LOAD 指令：把存储器中的数据放到寄存器中
	- STORE 指令：把寄存器中的数据放到存储器中
2. 算术逻辑操作
	- 算术：加减乘除、自增自减、求补、浮点运算、十进制运算
	- 逻辑：与或非、异或、位操作、位测试、位清除、位求反
3. 移位操作：算术位移、逻辑位移、循环位移
4. 转移操作：
	- 无条件转移 JMP
	- 条件转移 JZ：结果为 0，JO：结果溢出，JC：结果有进位
	- 调用和返回：CALL 和 RETURN
	- 陷阱 Trap 和陷阱指令
5. 输入输出操作：CPU 寄存器与 IO 端口之间的数据传送

即分为：数据传送类、运算类、程序控制类、输入输出类指令。

### 扩展操作码

扩展操作码 (不定长操作码)：全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。最常见的变长操作码方法是扩展操作码，是操作码的长度随地址码的减少而减少。不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

指令格式：定长指令字结构+可变长操作码。
- 优点：在指令字长有限的前提下仍然保持了比较丰富的指令种类。
- 缺点：增加了指令译码和分析的难度，是控制器的设计复杂化。

在设计扩展操作码指令格式时，必须注意以下两点：
1. 不允许短码长码的前缀。即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。

通常对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能较少指令译码和分析的时间。

> 在实际设计中，设地址长度为 n，上一层留出 m 种状态，下一层可以扩展出 $m\times 2^n$ 种状态。

## 寻址

### 指令寻址

指令寻址即如何确定下一条指令的地址。使用程序计数器 (PC) 来指出下一条指令的地址。每一条指令在执行前都会将 PC 加上当前的指令字长，从而获得下一条指令的位置。
- 顺序寻址：
	- 定长指令字结构：每读入一条指令，$(PC)+指令字长\to PC$
	- 变长指令字结构：
		1. 读入一个字，根据操作码判断这条指令的总字节数 $n$
		2. $(PC)+n\to PC$
		3. 根据指令的类型，CPU 可能还要进行多次访存，每次读入一个字
- 跳跃寻址：跳跃寻址命令将会直接修改 PC 中的指令地址。

### 数据寻址

数据寻址指确定本条指令的地址码指明的真实地址。由于地址在计算机中以相对地址的形式保存，因此我们需要根据起始地址来得到真实地址。下面介绍一些计算机常用的寻址方式。

由于不同的寻址方式需要不同的解读方式，为了区分不同的数据寻址方式，在地址码之前添加一个寻址方式位来标识每个地址的寻址方式。由于一共只有 10 种寻址方式，因此寻址特征需要 4 位表示。

为了描述方便，使用 A 表示形式地址，使用 EA 表示操作数的真实地址，称为有效地址。

#### 直接寻址

直接寻址：指令字中的形式地址就是操作数的真实地址 EA，即 EA=A。直接寻址仅需要两次访存，即取指令，执行指令。

- 优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。
- 缺点：A 的位数决定了该指令的操作数的寻址范围，操作数的地址不易修改。

#### 间接寻址

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA=(A)。

一条指令的执行在不考虑存结果的情况下需要访存 3 次。
- 取指令访存 1 次
- 执行指令访存 2 次

此外，还可以进行多次间接寻址。在多次间接寻址中，每个地址的开头第一位为 0 表示保存的是真实地址 EA，开头第一位为 1 表示保存的仍然是间接地址。

- 优点：可扩大寻址范围 (有效地址 EA 的位数大于形式地址的位数)、便于编制程序 (用间接寻址可以方便地完成子程序返回)。
- 缺点：指令在执行阶段要多次访存 (一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存)

#### 寄存器寻址

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 EA=R，其操作数在由 R 所值的寄存器内。

一条指令的执行只需要取指令访存一次。

- 优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。
- 缺点：寄存器价格昂贵，计算机中寄存器个数有限。

#### 寄存器间接寻址

寄存器间接寻址：寄存器 R 中给出的不是一个操作数，而是操作数所在主存单元的地址。

与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存。(因为操作数在主存中)

#### 隐含寻址

隐含寻址：不是明显的给出操作数的地址，而是指令中隐含着操作数的地址。

- 优点：有利于缩短指令字长。
- 缺点：需要增加存储操作数或隐含地址的硬件。

#### 立即寻址

立即寻址：形式地址 A 就是操作数本身，又称为立即数，一般采用补码的形式。常使用 "\#"表示立即寻址特征。

- 优点：指令执行阶段不访问主存，指令执行时间最短。
- 缺点：A 的位数限制了立即数的范围，如 A 的位数为 n，且立即数采用补码时，可以表示的数据范围为 $-2^{n-1}\sim 2^{n-1}-1$。

#### 偏移寻址

以某一个特定的起点，偏移一定的值的寻址方式。根据偏移的起点选取，可以将偏移寻址分为三类。

偏移寻址在指令执行期间需要访存一次。

##### 基址寻址

基址寻址：将 CPU 中基址寄存器 (BR) 的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 EA=(BR)+A。

这里的基址寄存器实际上就是 [[内存管理#可重定位装入]] 中的重定位寄存器。基址寄存器是面向操作系统的，程序员无法决定基址寄存器中的内容，该内容是由操作系统管理的。

> 在有的计算机内部不会专门设置一个基址寄存器，而是在指令中指明要将那个通用寄存器作为基址寄存器使用。这种时候需要将所有寄存器进行编号，然后使用对应数量的 bit 来存储。

- 优点：
	- 便于程序的浮动，方便实现多道程序并发运行。
	- 可以扩大寻址范围 (基址寄存器的位数大于形式地址 A 的位数)。
	- 用户不必考虑自己的程序存于主存的哪一空间区域，有利于多到程序的设计与编制浮动程序。

##### 变址寻址

变址寻址：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和。即 EA=(IX)+A，其中 IX 可以为变址寄存器，也可以是通用寄存器作为变址寄存器。

区别与基址寄存器，变址寄存器是面向用户的，在程序的执行过程中，变址寄存器的内容可由用户改变 (IX 作为偏移量)，形式地址 A 不变 (作为基地址)。

变址寻址在遍历数组的时候可以简化代码。即在数组的处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任意数据的地址，特别适合编制循环程序。

- 优点：特别适合于编制循环程序。

> 基址&变址复合寻址：将基址寻址方式与变址寻址的方式复合，即在寻址中先进行基址寻址，再在这个基础上在进行变址寻址。多种寻址方式的复合可以理解为复合函数。

##### 相对寻址

相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA=(PC)+A，其中 A 是相对于 PC 所指地址的偏移量，可正可负，补码表示。

- 优点：使得代码在程序内浮动时不用更改跳转指令的地址码。相对寻址广泛用于转移指令。

#### 堆栈寻址

堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针 (SP) 作为操作数地址。

堆栈是存储器 (或专用寄存器组) 中一块特定的按**后进先出**原则管理的存储区，该存储区中被读、写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针 (SP)。
- 硬堆栈：使用寄存器实现堆栈。
- 软堆栈：在主存中划分一个空间作为堆栈。现实中常用这种方式。

## 高级语言和机器级代码

汇编语言内容，51-59 P，暂时跳过。

## CISC  和 RISC

CISC (Complex Instruction Set Computer)，即复杂指令的计算机系统。设计思路为一条指令完成一个复杂的基本功能。代表为 x86 架构，主要用于笔记本、台式机等。

RISC (Reduced Instruction Set Computer)，即精简指令的计算机系统。设计思路为一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能。代表为 ARM 架构，主要用于手机、平板等。

> 80-20 规律：典型程序中 80% 的语句仅仅使用处理机中的 20% 指令。