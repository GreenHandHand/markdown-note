---
tags:
  - 数据结构与算法
---
# 栈、队列和数组

栈、队列和数组是三种最简单的数据结构。

## 栈

栈 (stack) 是只允许在一端进行插入或删除操作的 [[02_Areas/数据结构与算法/线性表|线性表]]。栈的操作特性为**后进先出** (List In First Out, LIFO)。

> [!note] 关于栈的术语
> - 栈顶 (Top)：线性表允许进行插入删除的那一端。
> - 栈底 (Botton)：固定的，不允许进行插入和删除的另一端。
> - 空栈：不含有任何元素的空表。

### 栈的基本操作

|         定义         | 操作     | 解释                          |
| :----------------: | ------ | --------------------------- |
|  `InitStack(&S)`   | 初始化    | 初始化一个空栈                     |
|  `StackEmpty(S)`   | 判断是否为空 | 若栈为空，返回 `true`，否则返回 `false` |
|   `Push(&S, x)`    | 进栈     | 若栈未满，则将 `x` 加入称为新栈顶         |
|   `Pop(&S, &x)`    | 出栈     | 若栈非空，则弹出栈顶元素，用 `x` 返回       |
|  `GetTop(S, &x)`   | 读栈顶元素  | 若栈非空，用 `x` 返回栈顶元素           |
| `DestroyStack(&S)` | 销毁栈    | 销毁栈，并释放栈 `S` 的存储空间          |

> [!note] 栈的数学性质
> 当 $n$ 个不同元素进栈时，出栈元素不同排列的个数为 $\dfrac{1}{n+1}C_{2n}^{n}$。该公式称为卡特兰数公式。

### 栈的顺序存储

栈的顺序存储类型可以描述为
```cpp
#define MaxSize 50
typedef struct {
	ElemType data[MaxSize];
	int top;
}SqStack;
```

顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，可能发生栈上溢。

> [!example] 共享栈
> 共享栈利用了栈底相对位置不变的特性，让两个顺序栈共享一个数组空间，将两个栈的栈底分别设置在共享空间的两段。

### 栈的链式存储

采用链式存储的栈称为栈链，优点是便于多个栈共享存储空间，且不存在栈上溢的情况，通常使用单链表实现。这里规定栈链没有头结点。
```cpp
typedef struct LinkNode{
	ElemType data;
	struct LinkNode* next;
}*LiStack;
```

## 队列

队列 (Queue) 简称为队，也是一种操作受限的线性表，只允许在表的一端进行插入，在表的另一端进行删除。队列的操作特性为**先进先出** (First In First Out, FIFO)。

> [!note] 和队列有关的术语
> - 队头 (Front)：允许删除的一端，又称为队首。
> - 队尾 (Rear)：允许插入的一端。
> - 入队：向队列插入元素。
> - 出队：删除元素。
> - 空队列：不含任何元素的空表。

### 队列的基本操作

|        定义         | 操作    | 解释                           |
| :---------------: | ----- | ---------------------------- |
|  `InitQueue(&Q)`  | 初始化队列 | 构造一个空队列 `Q`                  |
|  `QueueEmpty(Q)`  | 判断队空  | 若队列为空，返回 `true`，否则返回 `false` |
| `EnQueue(&Q, x)`  | 入队    | 若队列未满，将 `x` 加入，使之成为新的队尾      |
| `DeQueue(&Q, &x)` | 出队    | 若队列非空，删除队头元素，并用 `x` 返回       |
| `GetHead(Q, &x)`  | 读对头元素 | 若队列非空，则将队头元素赋值给 `x`          |

### 队列的顺序存储结构

队列的顺序存储结构实现指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 `front` 和队尾指针 `rear`。
```cpp
#define MaxSize 50
typedef struct{
	ElemType data[MaxSize];
	int front, rear;
}SqQueue;
```

> [!warning] 假溢出
> 使用顺序存储结构时，如果使用队头指针指向数组初始地址作为上溢出的条件，会出现假溢出现象。![[Assets/Pasted image 20240724203455.png]]
> 处理这种问题的方法是使用循环队列。

#### 循环队列

为了防止假溢出导致存储空间的浪费，循环队列将存储队列元素的表从逻辑上构造成一个环。当队首指针指向数组的 `MaxSize-1` 时，再前进一个位置就自动回到 0。在计算机中使用取余操作实现。

> [!note] 循环队列的判空和判满
> 显然的，我们可以使用 `Q.front==Q.rear` 来判断队列为空。但是如果队列满时，也有 `Q.front==Q.rear`。为了区分这两种情况，有三种处理方式：
> - 牺牲一个单元来区分队空和队满，即入队时少用一个队列单元。在这种情况下，`(Q.rear+1)%MaxSize==Q.front` 表示队满。
> - 类型中增加 `size` 数据成员，通过 `size` 来指示队列的大小。
> - 类型中增设 `tag` 数据成员，区分是队满还是队空。
> 	- 删除成功时置 `tag=0`，若此时 `Q.front==Q.rear`，则表示队空。
> 	- 插入成功时置 `tag=1`，若此时 `Q.front==Q.rear`，则表示队满。

### 队列的链式存储

队列的链式存储称为链队列，实际上是同时有头指针和尾指针的单链表。
```cpp
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;

typedef struct{
	LinkNode *front, *rear;
}LinkQueue;
```
通常来说，我们使用不带头结点的链表来实现队列。

### 双端队列

双端队列指两端都可以进行插入和删除操作的线性表。双端队列两端的地位是平等的。

> [!tip] 为了便于理解，左端也称为前端，右端也称为后端。

> [!note] 常用限制的双端队列
> 双端队列的使用较为灵活，有时为了可以固定输入、输出的范围，会对双端队列进行一些限制。
> - 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。
> - 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。
> - 若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列退化为两个栈底相邻接的栈。

> [!example] 优先队列
> 实际中更加常用的队列。在优先队列中，每个元素被赋予了优先级，在入队时，元素根据优先级自动排序。在出队时，优先级较高的元素先出队。优先队列具有自动排序的能力，这在实现某些算法是具有巨大的优势。

## 数组和特殊矩阵

数组和矩阵在科学计算中具有举足轻重的地位。在数据结构中，我们主要研究如何使用最小的内存空间来存储同样的一组数据，并方便的提取矩阵中的元素。

> [!note] 和数组有关的术语
> - 数组元素：每个数据元素
> - 下标：每个元素在 $n$ 个线性关系中的序号称为该元素的下标
> - 维界：下标的取值范围

数组是由 $n$ 个类型相同的数据元素构成的有限序列，数组一旦被定义，其维数和维界就不再改变。

> [!note] 数组和线性表的关系
> 数组是线性表的推广。一维数组可以视为一个线性表，二维数组可以视为元素为定长数组的线性表，以此类推。此外，数组的下标一般从 0 开始，而线性表的序号一般从 1 开始。

### 特殊矩阵的压缩存储

在压缩存储中，为多个值相同的元素值分配一个存储空间，对零元素不分配空间。我们一般对于特殊的矩阵使用压缩存储，这些矩阵具有相同的矩阵元素、大量零元素，且这些元素的分布有一定的规律性。

常见的特殊矩阵有对称矩阵，上 (下) 三角矩阵，对角矩阵等。

#### 对称矩阵

在 $n$ 阶对称矩阵中 $A$ 中，对于任意一个元素 $a_{ij}$，都有 $a_{ij}=a_{ji}$。其中的元素可以划分为 3 个部分，即上三角区、主对角线和下三角区。

在对称矩阵中，上三角区的所有元素和下三角区的对应元素相同，因此我们把 $n$ 阶对称矩阵存放在一维数组 `B[n(n+1)/2]` 中，只存储主对角线和下三角部分的元素，可以节省接近一半的空间。

#### 三角矩阵

下三角矩阵中，上三角区的所有元素均为同一变量。其存储思想与对称矩阵类似，不同指出在于存储完下三角区和主对角线上的元素后，紧接着存储上三角区的常量一次。

#### 三对角矩阵

三对角矩阵也称为带状矩阵。对于三对角矩阵中的任意元素 $a_{ij}$，若 $|i-j|>1$，则 $a_{ij}=0$。在这样的矩阵中，所有的非零元素都集中在以对角线为中心的 3 条对角线的区域，其他区域都为零。

该矩阵的压缩存储方式为将 3 条对角线上的元素按行优先方式存储在一维数组中。

#### 稀疏矩阵

矩阵中非零元素的个数 $t$ 远小于矩阵元素个数时，称为稀疏矩阵。此时，我们仅存储非零元素和它所在的行和列，将非零元素和它所在的行和列构成一个三元组 (i, j, a)，使用线性表存储。通过该方式，稀疏矩阵就失去了随机存储的特性。

---
< [[02_Areas/数据结构与算法/线性表|线性表]] | [[02_Areas/数据结构与算法/串]] >