---
tags:
  - 数据结构与算法
---

# 串

字符串简称串，是由零个或者多个字符组成的有限序列，一般记为
$$
S=\text{'}a_{1}a_{2}\cdots a_{n}\text{'}
$$
其中，$S$ 为串名，单引号括起来的字符序列是串的值。

串中字符的个数 $n$ 称为串的长度，$n=0$ 时的串称为空串。

> [!note] 和串有关的术语
> - 子串：串中任意多个连续的字符组成的子序列
> - 主串：包含子串的串称为该子串的主串
> - 位置：字符在串的中的序号

> [!note] 线性表与串的区别
> 串的逻辑结构和 [[02_Areas/数据结构与算法/线性表|线性表]] 极为相似，区别仅在于串的数据对象限定为字符集。
>
> 在基本操作上，串和线性表差别较大。线性的操作的主要对象为单个元素，但是串的基本操作通常以子串为对象，例如查找、插入或者删除子串等。

## 串的基本操作

|               操作               | 名称   | 解释                                               |
| :----------------------------: | ---- | ------------------------------------------------ |
|     `StrAssign(&T, chars)`     | 赋值   | 将 T 赋值为 `chars`                                  |
|        `StrCopy(&T, S)`        | 复制   | 由串 S 复制得到串 T                                     |
|         `StrEmpty(S)`          | 判空操作 | 若 S 为空串，则返回 `True`，否则返回 `False`                  |
|        `StrLength(&S)`         | 求串长  | 返回串 S 的元素个数                                      |
|       `ClearString(&S)`        | 清空操作 | 将 S 清为空串                                         |
|      `DestroyString(&S)`       | 销毁串  | 将串 S 销毁                                          |
|      `Concat(&T, S1, S2)`      | 串联接  | 用 T 返回由 `S1` 和 `S2` 串联成的新串                       |
| `SubString(&Sub, S, pos, len)` | 求子串  | 用 `Sub` 返回串 `S` 的第 `pos` 个字符起长度为 `len` 的子串       |
|         `Index(S, T)`          | 定位操作 | 若主串 `S` 中存在与串 `T` 值相同的子串，则返回它在主串中第一次出现的位置，否则返回 0 |
|       `StrCompare(S, T)`       | 比较操作 | `S>T` 返回值 `>0`，`S=T` 返回值 `0`，`S<T` 返回值 `<0`      |

## 串的存储结构

### 定长顺序存储表示

类似于线性表的顺序存储。c 语言中采用了这种实现方式，我们可以使用一个额外的变量来指示串的长度，或者在字符串的最后使用 `/0` 来标识串的结尾。
```cpp
#define MAX_SIZE 255
typedef struct{
	char ch[MAX_SIZE];
	int length;
}SString;
```

### 堆分配存储表示

堆分配存储表示同样使用一组连续存储单元存放的字符序列，但是它的存储空间是在程序执行过程中动态分配的。
```cpp
typedef struct{
	char* ch;
	int length;
}HString;
```

> [!note] 块链存储表示
> 类似于线性表的链式存储结构，也可以采用链表的方式存储串。由于串具有特殊性，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。

## 串的模式匹配

子串的定位操作通常称为模式匹配，它求的是子串 (模式串) 在主串中的位置。
1. 朴素模式匹配算法；暴力匹配所有与模式串等长的子串。
2. KMP 算法

KMP 算法是对朴素匹配的改进。朴素匹配的最差时间复杂度为 $O(mn)$，但是 KMP 算法可以保证最差时间复杂度为 $O(m+n)$。其基本思想为：
- **避免重复匹配**： 传统模式匹配算法（如朴素匹配）在发现不匹配时会回溯并重新开始匹配，这可能导致效率低下。 KMP 算法利用已匹配的信息来避免这种不必要的回溯。
- **利用部分匹配表**： KMP 算法通过构建一个辅助数组 next（也称为“前缀-后缀”或“部分匹配”表），记录模式串中每个前缀与最长相等后缀的对应关系。
`next[j]` 表示模式串 `P[1..j]` 中最大的相等前后缀的长度（如果没有这样的前后缀，则为 0）。

KMP 算法的主要代码如下：
```cpp
int Index_KMP(string S, string T, int next[]){
	int i = 0, j = 0;
	while(i<=S.length and j<=T.length{
		if(j==0 or S[i]==T[j]){
			i++, j++;
		}else{
			j = next[j];
		}
	}
	if(j>T.length{
		return i-T.length;
	}else{
		return -1;
	}
}
```

> [!warning] next 数组求法
> next 数组的作用：当模式串的第 j 个字符不匹配时，从模式串的第 `next[j]` 继续往后匹配。为了求解 next 数组，需要先清楚前缀、后缀和部分匹配值。
> - 前缀：除最后一个字符外，字符串的所有头部子串。
> - 后缀：除第一个字符外，字符串的所有尾部子串。
> - 部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。
>
> 我们可以通过部分匹配值来计算 next 数组。我们从长度为 1 的前缀开始，计算每个部分匹配值，最后可以得到一个与子串长度相同的部分匹配数组 PM。根据部分匹配数组的定义，next 数组可以计算为：`next[i] = PM[i] + 1`
> 1. `next[1] = 0, next[2] = 1`
> 2. 当第 3 个字符不匹配时，查找 3 之前的最长匹配前缀，填入 `next[3]`。
> 3. 重复，直到 `next` 数组填满。

---
< [[02_Areas/数据结构与算法/栈、队列和数组|栈、队列和数组]] | [[02_Areas/数据结构与算法/树与二叉树|树与二叉树]] >
