---
aliases: 
  - file system
tags:
  - 操作系统
---

# 文件管理

文件 (File) 是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。

在系统运行时，计算机以进程为基本单位进行资源的调度和分配。而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于程序的输入、输出时，还希望可以通过访问、修改和保存文件等，实现对文件的维护管理。这就需要系统提供一个文件管理系统 (File System)。

## 文件

文件是指由创建者所定义的，具有文件名的一组相关元素的集合，可以分为有结构文件和无结构文件。文件可以是数字、字符或者二进制代码，基本访问单元可以是字节或者记录。文件可以长期存储在硬盘中，允许可控制的进程间共享访问，能够被组织为复杂的结构。

> [!tip]
> 在 UNIX 系统中，任何数据都视为文件。所有的 IO 设备也被视为一种特殊的文件，因此访问 IO 设备的方式与访问文件的方式是相同的。

### 文件的属性

除了文件数据外，操作系统还会保存与文件相关的信息，若所有者、创建时间等，这些附加信息称为文件属性或者文件元数据 (meta-data)。文件属性在不同的系统中差别很大，但是通常都包括如下属性：
1. 文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，**同一目录下不允许有重名文件**。
2. 标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
3. 类型：指名文件的类型。
4. 位置：文件存放的路径 (让用户使用)、在外存中的地址 (操作系统使用，对用户不可见)。
5. 大小：指名文件的大小。
6. 创建时间、上次修改时间、文件所有者的信息。
7. 保护信息：对文件进行保护的访问控制信息。

> [!note] 文件的分类
> 为了便于管理文件，将文件分为了若干类型。由于不同系统对于文件的管理方式不同，因此它们的文件分类方法也有很大差异。下面是几种常见的文件分类方法：
> 1. 按照**性质和用途**分类，可以分为系统文件、用户文件和库文件。
> 2. 按照**文件中的数据形式**分类，可以分为源文件、目标文件和可执行文件。
> 3. 按照**存取控制属性**分类，可以分为可执行文件、只读文件和读写文件。
> 4. 按照**组织形式和处理方式**分类，可以分为普通文件、目录文件和特殊文件。

### 文件控制块

与进程管理一样，为了便于文件管理，引入了**文件控制块** (File Control Block, FCB)。文件控制块是用来存放控制文件所需要的各种信息的数据结构，以实现按名存取。文件与 FCB 一一对应。

> [!note] FCB 的内容
> - FCB 的有序集合称为**文件目录**，一个 FCB 就是一个文件目录项。
> - FCB 中包含了
> 	- **文件的基本信息** ：文件名、物理地址、逻辑结构、物理结构等。
> 	- **存取控制信息**： 是否可读、可写，静止访问的用户名单等。
> 	- **使用信息**：如文件的建立时间、修改时间等。

> [!tip]
> 通常一个文件目录也被视为一个文件，称为目录文件。

### 文件的操作

文件属于抽象的数据类型，为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供了一系列的系统调用，实现对文件的创建、删除、读、写、打开和关闭操作。
1. **创建文件**：为新文件分配外存空间，在目录中为之建立一个目录项，目录项记录了新文件名、文件在外存中的地址等信息。
2. **删除文件**：删除文件的过程为，根据文件名查找目录，删除指定文件对应的目录项和文件控制块，然后回收该文件所占用的存储空间。(包括磁盘空间和文件缓冲区)
3. **读文件**：读取文件的过程为，根据文件名查找目录，找到指定的目录项后，从中得到被读文件在外存中的地址。在目录项中，还有一个指针用于对文件进行读操作。
4. **写文件**：写文件的过程为，根据文件名查找目录，找到指定文件的目录项后，再利用目录项中的写指针对文件进行写操作。每当发生写操作时，更新写指针。

> [!note] 文件的打开
> 当用户对一个文件实施多次读写操作时，每次都要从检索目录开始。为了避免重复多次地检索目录，大多数操作系统要求：
> - *当用户首次对某个文件发出操作请求时，需要先调用系统调用 `open` 将该文件打开*。
> 	- 系统维护一个包含所有打开文件信息的表，称为**打开文件表**。
> 	- 打开文件指，系统检索到指定的目录项后，将该目录项从外存复制到内存中的打开文件表的一个表目录中，并讲该表目的索引号 (也称为文件描述符) 返回给用户。
> 	- 当用户再次对文件发出操作请求时，可以通过文件描述符在打开文件表中查找到文件信息，从而节省了大量的检索开销。
> - 当文件不再使用时，可以通过系统调用 `close` 关闭它。
> 	- 系统会从打开文件表中删除这一个表项。

> [!note] 多进程同时打开文件
> 在多个进程同时打开文件的操作系统中，通常采用两级表：
> - **整个系统的打开文件表**，包含与进程无关的信息，比如文件在磁盘上的位置，访问日期和文件大小。
> 	- 一旦有一个进程打开了文件，系统的打开文件表中就会包含该文件条目。
> - **每个进程的打开文件表**，保存进程对文件的使用信息，比如当前文件的读写指针、文件访问权限，并包含指向系统表中适当条目的指针。
> 	- 进程打开文件时，会在自己的打开文件表中增加一个条目，并指向系统表的相应条目。
> 	- 通常，系统打开文件表会为表中的每个文件关联一个打开计数器 (Open Count)，记录有多少进程打开了该文件。
> 	- 当进程不再使用文件时，利用系统调用 `close` 关闭它，会删除单个进程的打开文件表中的相应条目，系统表中的打开计数器也会递减。**当打开计数器为 0 时，表示该文件不再被使用，并且可以从系统表中删除相应条目**。

> [!warning]
> 文件名不必是打开文件表的一部分，文件名仅用于定位 FCB 在磁盘上的位置。在打开文件后，系统会为其分配打开文件表中的索引号，UNIX 使用文件描述符，Windows 使用文件句柄。因此，只要文件未被关闭，所有的文件都是通过文件描述符 (文件句柄) 进行的。
>
> **只要完成了打开文件操作，后面再使用 `read`、`write`、`seek`、`close` 等系统调用时都是使用文件描述符，而不是文件名**。

每个文件都具有如下关联信息：
- **文件指针**：系统跟踪上次读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。
- **文件打开计数**：计数器追踪当前文件打开数量和关闭数量。系统在删除打开目录条目前，必须等待最后一个进程关闭文件。
- **文件磁盘位置**：大多数文件操作系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必每个操作都从磁盘上读取信息。
- **访问权限**：每个进程打开文件都需要有一个访问模式 (创建、只读、读写、添加等)。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的 IO 请求。

> [!example] 与文件操作有关的系统调用
> - **创建文件**：调用操作系统 Create 系统调用，需要提供所需的外存空间大小、文件存放路径、文件名。操作系统主要做了：
> 	- 在外存中找到文件所需的空间
> 	- 根据文件存放路径信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。
> - **删除文件**：调用操作系统 Delete 系统调用，需要提供文件存放路径，文件名。操作系统主要做了：
> 	- 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项
> 	- 根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。
> 	- 从目录表中删除目录项。
> - **打开文件**：使用 open 系统调用打开文件，提供文件存放路径、文件名、对文件的操作类型。操作系统在处理 open 系统调用时，主要做了：
> 	- 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限。
> 	- 将目录项复制到内存中的打开文件表中，并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。
> - **关闭文件**：调用 Close 系统调用关闭打开的文件，主要做了：
> 	- 将进程的打开文件表相应项删除。
> 	- 回收分配给该文件的内存空间等资源。
> 	- 系统打开文件表的打开计数器 count 减 1，若 count=0，则删除对应表项。
> - **读文件**：调用 read 系统调用，将文件数据从外存读入内存，并显示在屏幕上。需要指明文件^[打开文件表中的序号，也称为**文件描述符**] 、读入多少数据、读入的数据放在内存中的什么位置。
> - **写文件**：调用 write 系统调用，将文件数据从外存写回内存。需要指明文件^[打开文件表中的序号，也称为**文件描述符**]、写回多少数据、写回外存的数据放在内存中的什么位置。
^fileOperation

### 文件保护

为了防止文件共享可能会导致文件被破坏或者未经核准的用户修改文件，文件系统必须控制用户对文件的存取。为此，必须在文件系统中建立相应的文件保护机制。实现方式可以是**口令保护、加密保护、访问控制**等方式。

> [!note] 口令保护
为一个文件设置一个口令，用户请求访问时必须提供口令。
> - 优点：保存口令的空间开销不多，验证口令的时间开销也很小。
> - 缺点：正确的口令存放在系统内部，不够安全。

> [!note] 加密保护
> 使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密。
> - 优点：保密性强，不需要在操作系统中存储密码。
> - 缺点：编码、译码需要花费一定的时间。

解决访问控制最常用的方法是根据用户身份进行控制。实现基于身份访问的最为普通的方式为在每个文件的 FCB 中增加一个访问控制列表 (Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。
- 优点：可以使用复杂的访问方法
- 缺点：长度无法预计并且可能会导致复杂的空间管理。

> [!note] 精简的 ACL
> 精简 ACL 可以解决 ACL 长度无法预计的文件。精简的 ACL 可以采用**拥有者、组和其他**三种用户类型。其中每种用户使用多个 0、1 描述其对于特定类型的权限。
> 1. 拥有者。创建文件的用户。
> 2. 组。一组需要共享文件，且具有类似访问的用户。
> 3. 其他。系统内的所有其他用户。
>
> 优点：实现灵活，可以实现复杂的文件包含功能。

> [!tip] 用户访问权限与用户优先级
> - 用户访问权限：用于文件保护，限制用户对文件的访问。
> - 用户优先级：用于调度，当用户同时提出请求时，先满足哪一个用户。

### 文件的逻辑结构

所谓**逻辑结构**，就是指在用户看来，文件内存的数据应该是如何组织起来的。而**物理结构**(又称为存储结构) 指在操作系统看来，文件中的数据是如何放在外存中的。

> [!tip] 逻辑文件系统的功能
> 1. 文件按名存取
> 2. 文件目录组织管理
> 3. 将文件名转换为文件描述符或者文件句柄
> 4. 存储保护

#### 逻辑结构

按逻辑结构，文件可以划分为无结构文件和有结构文件两大类：
- **无结构文件**：由一些二进制或字符流组成，又称为**流式文件**。对于流式文件的访问，时通过读写指针来指出下一个要访问的字节，然后顺序读取的。*例如文本文件的访问，无结构文件的由于没有结构，因此访问只能通过顺序搜索的方式*。
- **有结构文件**：由一个以上的记录构成的文件，又称**记录式文件**。*例如数据库表*。根据各条记录的长度 (占用存储空间) 是否相等，又可以分文定长记录和可变长记录两种。
	- 定长记录：文件中所有记录的长度是相同的，各数据项都在记录中的相同位置，具有相同长度。
		- 定长记录检索的速度快，方便用户对文件进行处理，广泛用于数据处理中。
	- 变长记录：文件中各记录的长度不一定相同，只能顺序查找，速度慢。

有结构文件按照组织形式可以分为顺序文件、索引文件、索引顺序文件。
1. **顺序文件**：文件中的记录一个接一个顺序排列 (逻辑上)，记录可以是定长或者可变长的。各个记录在物理上可以顺序存储或链式存储。主要有两种排列方式：
	- **串结构**：记录之间的顺序与关键词无关，通常是按照存入的先后时间进行排序的，检索时需要从头开始依次查找，比较费时。
	- **顺序结构**：记录之间的顺序按关键词顺序排列，对于定长记录的顺序文件，检索时可以采用折半查找，效率较高。
2. **索引文件**：对于定长的顺序文件，要查找第 $i$ 条记录，可以直接根据偏移计算得到对应的地址，实现随机存取。但是对于变长记录的顺序文件，无法通过这种方式实现随机存取。为了实现类似的随机存取，可以建立一张**索引表**，为主文件的每个记录在索引表中分别设置一个索引表项，其中包含指向记录的指针和记录长度，按照关键词排序。
	- 索引表本身也是一个定长的顺序文件，可以实现随机存取，从而加快了记录的检索速度。
	- 索引文件由于需要配置索引表，且每个记录都要有一个索引项，因此增加了存储开销。
3. **索引顺序文件**：是索引文件和顺序文件的结合，使用 [[02_Areas/数据结构与算法/查找#分块查找|分块查找]] 的方式。
	- 最简单的索引顺序文件使用一级索引，先将变长记录顺序文件中的所有记录分为**若干组**，然后为文件建立一张索引表，并为**每组中的第一个记录建立一个索引项**，其中包含该记录的关键字和指向该记录的指针。
	- 索引顺序文件中，组与组之间的关键字必须有序，组内的关键字可以无序。
	- 检索时，先查找索引表，找到该记录所在的组，然后在组中使用顺序查找，就能很快找到记录。
4. **直接文件**(散列文件)：给定记录的键值，或者通过散列函数转换的键值直接决定记录的物理地址，使用 [[02_Areas/数据结构与算法/查找#散列表|散列表]] 的方式查找记录。

> [!note] 索引顺序文件的查找效率分析
> 对于含有 $N$ 条记录的顺序文件，查找某个关键字的记录时，平均需要查找 $N/2$ 次。在索引顺序文件中，假设 $N$ 条记录分为了 $\sqrt{ N }$ 组^[使用这个值的理由可以参考 [[02_Areas/数据结构与算法/查找#分块查找|分块查找]] 的内容]，索引表中有 $\sqrt{ N }$ 个表项，每组有 $\sqrt{ N }$ 条记录，在查找某关键字的记录时，
> - 先顺序查找索引表，平均 $\sqrt{ N }/2$ 次
> - 然后在主文件对应的组中查找，平均需要 $\sqrt{ N }/2$ 次
> - 因此共需要查找 $\sqrt{ N }$ 次。

#### 文件间的组织方式

用户可以自己创建一层一层的目录 (文件夹)，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了。目录也是一种特殊的有结构文件 (由记录组成)。

> [!note]
> 为了实现文件目录的方式，操作系统需要提供：
> 1. 创建文件：图形化界面在创建文件时需要调用，即 `create` 系统调用。
> 2. 读文件：即 `read` 系统调用。将文件数据读入内存，才能让 CPU 处理。
> 3. 写文件：即 `write` 系统调用。将更改过的文件数据写回外存。
> 4. 删除文件：即 `delete` 系统调用，将文件从外存中删除。
> 5. 打开文件：`open` 系统调用，读写文件之前需要打开文件。
> 6. 关闭文件：`close` 系统调用，读写文件结束之后需要关闭文件。

## 文件目录

FCB 的有序集合称为文件目录，一个 FCB 就是一个文件目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置、所有权等。
- 从用户的角度来看，目录在用户所需要的文件名和文件之间提供一种映射，实现按名存取。

为了控制目录，操作系统需要提供：
1. 搜索：当用户要使用一个文件时，系统根据文件名搜索目录，找到该文件对应的目录项
2. 创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项
3. 删除文件：当删除一个文件时，需要在目录中删除对应的目录项
4. 显示目录：用户可以请求显示目录的内容，如显示目录中的所有文件及相应属性
5. 修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项

### 目录结构

1. **单级目录结构**：早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。
	- 当建立一个新文件时，必须检索所有的目录项，以确保没有重名现象。
	- 单级目录实现了按名存取，但是不允许文件重名，且查找速度慢。因此单级目录不适用于多用户操作系统。
2. **两级目录结构**：早期的多用户操作系统采用两级目录结构，分为**主文件目录**(Master File Directory, MFD) 和**用户文件目录**(User File Directory, UFD)。
	- 主文件目录项：记录用户名及相应用户文件目录所在的存储位置。
	- 用户文件目录项：记录该用户所有文件的 FCB。
	- *当用户想要对其文件进行访问时，只需要先搜索该用户对应的 UFD，然后在用户文件目录中查找对应的文件*。
	- 优点：两级目录结构提高了检索速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。
	- 缺点：两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。
3. **树形目录结构**：当用户要访问某个文件时，用文件的路径名标识文件。
	- **文件路径名**是一个字符串，由从根目录出发到所找文件通路上所有目录名与数据文件名用分隔符链接而成。从根目录出发的路径成为绝对路径，系统中的每个文件都有唯一绝对路径名。
	- 由于一个进程在运行时，其访问的文件大多局限于一个范围，于是为每个进程设置了一个当前目录 (又称为工作目录)，此时进程对各文件的访问都只需要相对于当前目录进行。当用户要访问某个文件时，可以使用**相对路径名**标识文件。
	- 优点：
		- 可以很方便地对文件进行分类，层次结构清晰，也能够更有效进行文件的管理和保护。
		- 在树形目录中，不同性质、不同用户的文件，可以分配呈现在系统目录树的不同层次或不同子树中，很容易赋予不同的存取权限。
	- 缺点：
		- 在树形目录中查找一个文件，需要按路径名逐级访问中间子节点，增加了磁盘访问次数，影响查询速度。
		- 不便于实现文件的共享。
4. **无环图目录结构**：在树形结构的基础上，增加一些指向同一个节点的有向边，使整个目录称为一个有向无环图。可以更加方便的实现多个用户间的文件共享。
	- 可以用不同的文件名指向同一个文件，甚至可以指向同一个目录。
	- 需要为每个共享节点设置一个**共享计数器**，用于记录此时有多少个地方在共享节点。用户提出删除节点的请求时，只是删除该用户的 FCB，并使共享计数器减 1，并不会直接删除共享节点。

### 索引节点

> [!note] 文件目录的查找过程
> 当文件很多时，文件目录会占用大量的盘块。在查找目录的过程中，需要先将存放在目录文件的第一个盘块中的目录调入内存，然后用给定的文件名逐一比较，若未找到指定文件，还需要将下一盘块中的目录项调入内存，逐一比较。

从上面的文件目录的查找过程中，我们可以发现，在检索目录的过程中，只用到了文件名，文件的其他描述信息不会用到。仅当找到了一个目录项时，才从该目录项中读出该文件的物理地址。

**索引节点**是对 FCB 的改进。由于查找各级目录的过程中，只需要用到文件名这一个信息，因此可以将文件的其他信息保存在索引节点中，目录表中只保存文件名与指向索引节点的指针。这样做可以通过让目录瘦身来提升效率。

存放在外存中的索引节点称为**磁盘索引节点**，当索引节点放入内存后称为内存索引节点。相比之下内存索引节点中需要增加一些信息，比如文件是否被修改 (脏位)，此时有几个进程正在访问文件等。

> [!note] 索引节点与文件容量的关系
> 假设一个 FCB 的大小为 64B，盘块大小为 1KB，则每个盘块中可以存放 16 个 FCB(FCB 必须连续存放)，若一个文件目录共有 640 个 FCB，则查找文件平均需要启动磁盘 20 次。而在 Unix 中，一个目录索引项只占 16B，其中 14B 是文件名，2B 是索引节点号。在 1KB 的盘块中，可以存放 64 个目录项。这样，查找文件的平均启动磁盘数就减少到原来的 1/4，大大节省了系统的开销。

> [!note] 磁盘索引节点
> 每个文件具有唯一的一个磁盘索引节点，存放在磁盘上，主要包括以下内容：
> - 文件主标识符：拥有该文件的个人或小组的标识符。
> - 文件类型：包括普通文件、目录文件或特别文件。
> - 文件存取权限：各类用户对该文件的存取权限。
> - 文件物理地址：每个索引节点中含有 13 个地址项 (`iaddr(0)~iaddr(12)`)，它们以直接或者间接方式给出了数据文件所在的盘块的编号。
> - 文件长度：指以字节为单位的文件长度。
> - 文件链接计数：在本文件系统中所指向该文件的指针计数。
> - 文件存取时间：本文件最近被进程存取、修改的时间及索引节点最近被修改的时间。

> [!note] 内存索引节点
> 当文件被打开时，要将磁盘索引节点复制到内存的索引节点中，以便以后使用。内存索引节点在磁盘索引节点的基础上，增加了
> - 索引节点号：用于标识内存索引节点
> - 状态：指示节点是否上锁或者被修改
> - 访问计数：每当有一个进程要访问该节点时，计数加 1。访问结束后计数减 1。
> - 逻辑设备号：文件所属文件系统的逻辑设备号。
> - 链接指针：设置分别指向空闲链表和散列队列的指针。

### 文件共享

文件共享使多个用户共享同一个文件，系统中只需要保留该文件的一个副本。若系统不能提供共享功能，则每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。

使用无环图目录，可以实现文件共享。当建立链接关系时，必须将被共享文件的物理地址 (盘块号) 复制到相应目录。如果某个用于向该文件添加新数据，且需要增加新盘块，那么这些新增盘块只出现在执行操作的目录中，对其他共享用户是不可见的。

#### 基于索引节点的共享方式 (硬链接)

硬链接是基于 [[#索引节点]] 的共享方式，由于检索文件时只需要用到文件名，因此可以将除了文件名之外的其他信息放到索引节点中。这样目录项就只需要包含文件名、索引节点指针。

> [!note]
> 在索引节点中设置一个链接计数变量 count 用于链接到本索引节点上的用户目录项数。若某个用户决定删除这个文件，则只需要将 count 值减 1。只有 count=0 时，才会真正删除文件。

#### 基于符号链接的共享方式 (软链接)

软链接创建了一个新的 link 型的文件，类似于快捷方式。该文件会根据其中记录的路径，层层查找目录，最终找到索引节点。

> [!note]
> - 对于软链接，删除原来的文件会导致软链接失效。
> - 软链接访问速度慢于硬链接。

## 文件物理结构 (文件分配方式)

文件的物理结构就是研究文件分配在硬件中的实现，即文件数据在物理存储设备上如何分布和组织的。这主要涉及到：
1. 文件的分配方式：对磁盘非空闲块的管理。本节先对该内容进行讨论。
2. 文件存储空间管理：对磁盘空闲块的管理。这一部分在 [[#空闲空间管理]] 中讨论。

> [!note]
> 文件分配对应于文件的物理结构，是指如何为文件分配磁盘块，常用的文件分配方式有三种：连续分配、链接分配、索引分配。

> [!note] 磁盘块
> 类似于内存分页，磁盘中的存储单元也被分为一个个块，称为**磁盘块**。在很多的操作系统中，磁盘块的大小与内存块、页面的大小相同。
> - 内存与磁盘之间的数据交换 (即读写操作、磁盘 IO) 都是以块为单位进行的。即每次读入一块，或每次写出一块。
> - 于是文件的逻辑地址也可以表示为 (逻辑块号，块内地址) 的形式。用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。

> [!tip] 簇
> 在一些操作系统中，为了改善磁盘使用效率，将多个相邻的扇区合并为簇，对文件存储空间分配是以簇为单位进行的。此时，操作系统为每个文件分配的空间大小只能是簇的整数倍。*在包含簇的文件系统中，存储单元的分配是以簇为单位的*。
>
> 实际上，簇就是文件块，在 Windows 系统中称为簇，在 Unix 系统中称为磁盘块。

### 连续分配

连续分配方式要求每个文件在磁盘上占有一组连续的块。磁盘地址重新定义了磁盘上的一个线性排序，这种排序使进程访问磁盘时需要的寻道数和寻道时间最小。这种方式与 [[02_Areas/操作系统/内存管理#动态分区分配]] 方法非常相似，只是连续分配是以块为单位，而动态分区分配是以地址为单位。

在这种方式中，文件目中需要记录存放的**起始块号、长度** (总共占用几个块)。
- 通过这种方式，用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项 (FCB)
- 物理块号=起始块号 + 逻辑块号。当逻辑块号大于长度时，不合法。

> [!note] 连续分配特点：
> 优点：
> 1. 由于可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问 (随机访问)。
> 2. 连续分配的文件在顺序读写时速度最快，磁头移动距离最小。
>
> 缺点：
> 1. 物理上采用连续分配的文件不方便拓展。
> 2. 物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片。可以用紧凑来处理碎片，但是需要耗费很大的时间代价。
> 3. 为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动。

### 链接分配

链接分配采用离散分配的方式，可以为文件分配离散的磁盘块，分为隐式链接和显式链接两种。
- **隐式链接**：目录中记录了文件存放的起始块号和结束块号，除了文件的最后一个盘块外，每个盘块都存有指向文件下一个盘块的指针，**这些指针对于用户是透明的**。对于 i 号逻辑块，隐式链接通过顺序读取 1 到 i-1 块从而找到第 i 号逻辑块。
	- 优点：很方便文件拓展。不会有外部碎片文件，外存利用率高。
	- 缺点：
		- 采用链式分配 (隐式链接) 方式的文件只支持顺序访问，不支持随机访问，查找效率低。
		- 指向下一个盘块的指针也需要耗费少量的存储空间。
		- 存在稳定性问题，文件盘块中的任何一个指针出现问题，都会导致文件数据的丢失。
- **显式链接**：目录中记录了文件存放的起始块号和结束块号。把用于链接文件各物理块的指针显式地存放在内存的一张链接表中，该表在整个磁盘中仅设置一张，称为**文件分配表** (File Allocation Table, FAT)，每个表项中记录每一个物理块的下一个物理块号。目中只需要记录文件的起始块号。
	- 一个磁盘仅设置一个 FAT，开机时读入内存，并常驻内存。FAT 的各个表项在物理上连续存储，并且长度相同，因此物理块号是隐含的。
		- FAT 的表项与全部磁盘块一一对应，并且使用一个特殊的数字 (-1) 表示文件的最后一块。
		- 可以使用 -2 (或者其他) 表示一个盘块是空闲的。当进程请求系统分配磁盘块时，系统只需要从 FAT 中找到 -2 的表项进行分配即可。*因此，FAT 不仅可以用于管理已分配的磁盘空间，也可以用于管理未分配的磁盘空间，可以用于空闲管理*。
	- 优点：
		- 方便文件拓展，不会产生外部碎片。
		- 支持顺序访问、随机访问。
		- FAT 常驻内存，因此检索是直接在内存中进行的，明显减少了访问磁盘的次数。
	- 缺点：文件分配表 FAT 需要占用一定的存储空间。

> [!note] 链式分配的特点
> 1. 消除了磁盘的外部碎片，提高了磁盘的利用率。
> 2. 便于动态地为文件分配盘块，因此无需事先知道文件的大小。
> 3. 文件的插入、删除和修改也非常方便。

> [!tip]
> - 隐式链接分配中，文件的最大大小取决于存储块中的链接指针的最大寻址空间。
> - 显式链接分配中，文件的最大大小取决于 FAT 表的大小。而 FAT 表的范围取决于 FAT 中物理块号的表示范围。*例如，使用 FAT 表中使用 2B 表示物理块号，则 FAT 表的大小最大为 $2^{16}\times 2B$。*

### 索引分配

显式链接分配中，在内存中保存了一张指向磁盘空间所有盘块的 FAT 表。事实上，在打开某个文件时，只需要将该文件对应的盘块的编号调入内存即可，完全没有必要将这个 FAT 调入内存。

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块 (类似 [[02_Areas/计算机组成原理/指令系统#间接寻址|间接寻址]] 方式)。索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。目录中需要记录文件的索引块是几号磁盘块。
- 可以使用固定长度表示物理块号，因此索引表中的逻辑块号可以是隐含的。
- 优点：
	- 支持随机访问、文件拓展也很容易实现。
	- 不会产生外部碎片。
- 缺点：索引表占用一定的存储空间。

> [!tip]
> FAT 表通常存放在文件系统一个或多个固定的盘块上，这时在文件系统初始化时，就已经决定了。在这些盘块中，索引表按照数组的方式排列，每个文件对应的 FCB 中包含有指向其 FAT 所在的位置。

> [!note] 索引分配的主要问题
> 每个文件必须使用一个索引块。
> - 当文件很小时，比如只有数个盘块，该方式任然需要为其分配一个索引块，此时索引块的利用率很低。
> - 当文件很大时，若其盘块号需要占用若干索引块，虽然可以使用链接指针将其链接起来，但是效率较低。

> [!note] 多级索引分配方式
> 为了解决前述的文件过大时会占用过多索引块的问题，应该为这些索引块再建立一级索引，称为主索引。原理类似于 [[02_Areas/操作系统/内存管理#两级页表|两级页表]] 的机制。
> - 优点：极大的增加了对大型文件的查找速度。
> - 缺点：当访问一个盘块时，启动磁盘的次数随着索引级数增加而增多。

> [!note] 混合索引分配方式
> 为了更加全面地照顾到小型、中型和特大型文件，可以采用**混合索引分配**方式。
> - 对于小文件，直接将它们的每个盘块地址直接放入 FCB 中，这样可以直接从 FCB 中获得盘块地址，相当于 [[02_Areas/计算机组成原理/指令系统#直接寻址|直接寻址]] 方式。
> - 对于中型文件，可以采用单级索引分配，先从 FCB 中找到索引表，然后从索引表中获得该文件的盘快地址，相当于 [[02_Areas/计算机组成原理/指令系统#间接寻址|一次间接寻址]] 方式。
> - 对于大型文件，可以采用多级索引分配。

> [!tip] UNIX 分配方式
> 在 UNIX 中，使用混合索引分配方式，其 FCB 设置了 13 个直接地址项用于提高小文件的检索速度。*加入每个盘块的大小为 4KB，当文件不大于 52KB 时，便可以直接从 FCB 中读出该文件的全部盘块号*。

## 文件系统

文件系统 (File System) 提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。文件系统有两个不同的设计问题：
- 定义文件系统的用户接口，它涉及了定义文件及其属性、所允许的文件操作、如何组织文件的目录结构。
- 创建算法和数据结构，以便映射逻辑文件系统到物理外存设备。

> [!note] 文件系统层次
> 1. **IO 控制层**：包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息。设备驱动程序将输入的命令翻译成底层硬件的特定指令，硬件控制器利用这些指令使得 IO 设备与系统交互。设备驱动告诉 IO 控制器对设备的什么位置采取什么动作。
> 2. **基本文件系统**：向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块。每个物理块由磁盘地址标识。该层也管理内存缓冲区，并保存各种文件系统、目录和数据块的缓存。在进行磁盘块传输前，分配合适的缓冲区，并对缓冲区进行管理。管理它们对于系统性能的优化至关重要。
> 3. **文件组织模块**：组织文件及其逻辑块和物理块。文件组织模块可以将文件的逻辑块地址转换为物理块地址，每个文件的逻辑块从 0 到 N 编号，它与数据的物理块不匹配，因此需要通过转换来定位。文件组织模块还包括空闲空间管理器，以跟踪未分配的块，根据需求提供给文件组织模块。
> 4. **逻辑文件系统**：用于管理文件系统中的元数据信息。元数据包括文件系统的所有结构，而不包括实际数据 (或文件内容)。逻辑文件系统管理目录结构，以便更具给定文件名为文件组织模块提供所需要的信息。它通过文件控制块来维护文件结构。逻辑文件系统还负责文件保护。

### 文件系统布局

文件存放在磁盘上，多数磁盘被划分为一个或者多个分区 (文件卷)，每个分区中有一个独立的文件系统。一个文件系统的布局为：
1. **主引导记录**(Master Boot Record, MBR)，位于磁盘的 0 号扇区，用来引导计算机。
	- MBR 的后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区。
	- 当计算机启动时，BIOS 读入并执行 MBR，MBR 做的第一件事就是确定活动分区，读入它的第一个块，即引导块^[操作系统启动的内容参考 [[02_Areas/操作系统/操作系统基本原理概论#操作系统引导|操作系统引导]]]。
2. **引导块**(boot block)：MBR 执行引导块中的程序后，该程序负责启动该分区中的操作系统。每个分区都是统一从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后在该分区安装一个操作系统。Windows 系统称之为分区引导扇区。
3. **超级块**(super block)：包含文件系统的所有关键信息，在计算机启动时，或者在文件系统首次使用时，超级块会被读入内存。超级块中典型信息包含分区的块的数量、块的大小、空闲块的数量和指针、空闲的 FCB 的数量和 FCB 指针等。
4. **文件系统中空闲块的信息**：可以使用位示图或指针链接的形式给出。
	- 在空闲块信息的后面，可以跟着一个 $i$ 节点，说明文件的方方面面。
	- 接着可以是根目录，最后是存放的其他目录和文件。

> [!example]-
> 下面是一个可能的文件系统布局
> $$
\begin{array}{|c|c|c|c|c|c|}
\hline\small\text{MBR} & \small\text{分区表} & \small\text{磁盘分区 1} & \small\text{磁盘分区 2} & \cdots & \small\text{磁盘分区 n}\\ \hline
\end{array}
> $$
> 其中每个磁盘分区的结构可以如下：
> $$
\begin{array}{|c|c|c|c|c|c|}
\hline\small\text{引导块} & \small\text{超级块} & \small\text{空闲空间管理} & \small\text{i 节点} &\small \text{根目录} & \small\text{文件和目录}\\ \hline
\end{array}
> $$

> [!tip] 主引导扇区
> 硬盘的主引导扇区由三个部分组成：
> - 主引导程序 (也称主引导记录，MBR)，用于系统启动时将控制转交给某个活动分区。
> - 分区表：给出每个分区的起始地址与结束地址。
> - 结束标识：通常为 AA55。

### 空闲空间管理

一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分 2 个分区，每个分区都可以有独立的文件系统。包含文件系统的分区通常称为卷 (volume)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成的 RAID 集。

> [!note]
> 在一个卷中，存放文件的空间 (文件区) 和 FCB 的空间 (目录区) 是分离的，由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的卷中的文件。卷在提供文件服务前，必须由对应的文件程序进程初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块。

文件存储设备分为许多大小相同的物理块，并以块为单位交换信息。因此，文件存储设备的管理实质上是对空闲块的组织、分配与回收问题。

#### 空闲表法

空闲表法属于连续分配方式，它与内存的 [[02_Areas/操作系统/内存管理#动态分区分配|动态分区分配]] 类似，为每个文件分配一块连续的存储空间。*适合用于连续分配的物理结构*。
- 系统为外存的所有空闲区建立一张空闲表，每个空闲表对应一个空闲表项，其中包含表项序号、该空闲区的第一个空闲盘块号、该空闲区的空闲盘块数等信息。
- 再将所有空闲区按照起始盘块号递增的次序排列。

> [!note] 盘块的分配与回收
> - 分配：与内存的 [[02_Areas/操作系统/内存管理#动态分区分配算法|动态分区分配算法]] 类似，也是采用首次适应法、最佳适应算法等。
> - 回收：考虑回收区是否与空闲盘块表中插入点的前区和后区相邻接，对相邻接者进行合并。

#### 空闲链表法

空闲链表法是将所有空闲盘区拉成一条空闲链，可以分为空闲盘块链和空闲盘区链两种方式。

> [!note] 空闲盘块链
> 将磁盘上的所有空闲空间以盘块为单位拉成一条链。每个盘块都有指向下一个空闲盘块指针。*适用于离散分配的物理结构*。
> - 用户请求分配存储空间时，系统从链首开始，依次摘下适当数量的空闲盘块分配给用户。
> - 用户释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。
>
> 空闲盘块链具有以下特点：
> - 优点：分配和回收过程简单。
> - 缺点：在为一个文件分配盘块时可能要重复操作多次，效率低。此外，由于是以盘块为单位的，因此空闲盘块链会很长。

> [!note] 空闲盘区链
> 以盘区为单位组成一条空闲链，每个盘区包含若干相邻的盘块，每个盘区含有下一个空闲盘区的指针和本盘区的盘块数。*适用于连续分配和离散分配两种物理结构*。为一个文件分配多个盘块时效率更高。操作系统保存链头、链尾指针。
> - 分配：若某文件申请 K 个盘块，则可以采用首次使用、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配。若没有合适的连续空闲块，也可以将不同盘区的盘块分配给同一个文件。
> - 回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。
>
> 空闲盘区链的特点：
> - 优点：分配与回收的效率较高，且空闲盘区较短。
> - 缺点：回收与分配的过程复杂。

#### 位示图法

位示图利用二进制的一位来表示磁盘中一个盘块的使用情况，每一个二进制对应一个磁盘上的一个盘块。例如，用 0 表示盘块空闲，用 1 表示盘块已分配。位示图一般使用连续的字表示，字中的每一位对应一个盘块，因此可以使用 (字号，位号) 对应一个盘块号。*适用于连续分配和离散分配两种物理结构*。
- 分配：若文件需要 K 个块，首先，顺序扫描位示图，找到 K 个相邻或者不相邻的 0。然后根据字号、位号算出对应的盘块号，将相应盘块分配给文件。最后将相应位设置为 1。
- 回收：首先，根据回收的盘块号计算出对应的字号、位号。然后，将相应二进制为设置为 0。

> [!note] 位示图法的特点
> - 优点：很容易在位示图中找到一个或一组相邻接的空闲盘块。由于位示图很小，因此可以保存在内存中，从而节省很多开销。
> - 缺点：位示图大小会随着磁盘容量增加而增大，因此常用于小型计算机。

#### 成组链接法

在大型文件系统中，空闲表法和空闲链表法可能无法高效运作，因为空闲表或空闲链表的规模可能过大，无法完整地存储在一个盘块中。成组链接法通过结合这两种方法，克服了这一问题，确保空闲块的管理更加灵活。

> [!note] 超级块
> 文件系统中专门保留一个磁盘块作为超级块，它存储了与空闲块相关的关键信息。当系统启动时，超级块会被加载到内存中，并需要确保内存中的超级块数据与外存中的数据保持一致。超级块的主要作用是：
> 1. 保存当前组中剩余的空闲盘块数。
> 2. 记录每个空闲块的编号。
> 3. 第一个空闲块指向下一组空闲块信息（即下一个超级块的位置）。

1. 分配过程：
	- **常规分配**：当需要分配空闲块时，首先从内存中的超级块记录的空闲块中进行分配。
	- **组切换**：当当前组的空闲块分配完毕时（即分配到第一个空闲块时），需要从该空闲块中读取下一组的超级块信息，并将其内容复制到当前超级块中。之后，继续从新组中进行分配。
2. 回收过程
	- **插入空闲块**：如果当前超级块中尚有空闲空间，则将回收的空闲块插入超级块的记录中。
	- **超级块满**：当超级块的空闲块记录已满时，需将当前超级块的内容复制到一个新回收的空闲块中，并将这个新的空闲块作为新的超级块，同时更新超级块中的指针，指向新回收块。

> [!example]-
> ![[Assets/文件管理-1.png#center|成组链接法|800]]

## 虚拟文件系统

虚拟文件系统 (VFS) 屏蔽了不同文件系统的差异和操作细节，向上为用户提供了文件操作的统一调用接口。当用户程序访问文件时，通过 VFS 提供的统一调用函数^[[[#^fileOperation|文件操作]]] 来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。

> [!note]
> 虚拟文件系统采用了面向对象的思想，抽象出了一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只需要实现这些接口，即可安装使用。

为了实现虚拟文件系统，系统抽象了四种对象类型。
1. 超级块对象：表示一个以安装 (挂载) 的特定文件系统。*超级块对象对应于磁盘上特定扇区的文件系统超级块，用于存储已安装文件系统的元信息*。
	- 需要实现的方法：分配 `inode`，销毁 `inode`，读 `inode`，写 `inode` 等。
2. 索引节点对象：表示一个特定的文件。*索引节点和文件是一一对应的关系，只有当文件被访问时，才在内存中创建索引节点对象，每个索引节点对象会复制磁盘索引节点包含的一些数据*。
	- 需要实现的方法：创建新索引节点、创建硬链接、创建新目录等。
3. 目录项对象：表示一个特定的目录项。*目录项对象是一个路径的组成部分，它包含指向关键索引节点的指针，还包含指向父目录和指向子目录的指针*。
	- 不同于前面两个对象，目录项对象在磁盘上没有对应的数据结构，而是 VFS 在遍历路径的过程中，将它们逐个解析成目录项对象的。
4. 文件对象：表示一个与进程相关的已打开文件。*通过系统调用 `open` 打开一个文件之后，会创建一个文件对象。与文件的关系类似进程与程序的关系。*
	- 文件对象仅是进程视角上代表已打开的文件，它反过来指向其索引节点。
	- 文件对象包含与该文件相关联的目录项对象，包含该文件的文件系统、文件指针等，还包含在该文件对象上的一系列操作函数。

> [!note]
> 对于用户来说，不需要关心不同文件系统的具体实现细节，只需要对一个虚拟的文件操作界面进行操作。VFS 对每个文件系统的所有细节进行抽象，使得不同的文件系统在系统中运行的进程看来都是相同的。

> [!warning]
> 严格来说，VFS 并不是一种实际的文件系统，它只存在于内存中，不存在于任何外存空间。VFS 在系统启动时建立，在系统关闭时消亡。

### 文件系统的挂载

如文件在使用前需要打开那样，文件系统在使用前必须先安装，也称为挂载 (Mounting)。将设备中的文件系统挂载到某个目录后，就可以通过这个目录来访问设备上的文件。

Windows 系统维护一个拓展的两级目录结构，用驱动器字母表示设备和卷。访问时，操作系统先找到相应文件系统的指针，并遍历该设备的目录结构，以查找指定的文件。在启动时，Windows 自动发现所有设备，并安装所有找到的文件系统。

UNIX 使用系统的根文件系统，它是在系统启动时直接安装的。除了根文件系统，其他所有文件系统需要先挂载到根文件系统中的某个目录后才能访问。安装文件系统的这个目录称为安装点，同一个设备可以有多个安装点，但是一个安装点只能挂载一个设备。

> [!tip]
> Linux 中，可以通过命令
> ```shell
> mount -t ext2 /dev/fd0 /flp
> ```
> 来将 `/dev/fd0` 上的 `ext2` 文件系统通过 `mount` 命令安装到 `/flp` 目录。可以使用命令 `umount` 命令卸载文件系统。

< [[02_Areas/操作系统/内存管理|内存管理]] | [[02_Areas/操作系统/输入输出管理|输入输出管理]] >
