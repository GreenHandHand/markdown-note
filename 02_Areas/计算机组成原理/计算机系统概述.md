---
tags:
  - 计算机组成原理
  - 概述
---

# 计算机系统概述

本节是对计算机组成原理内容的概述，介绍计算机系统中包含的各个部件。

## 计算机系统层次结构

硬件系统和软件系统共同构成了一个完整的计算机系统。
- **硬件**指有形的物理设备，是计算机系统中实际物理装置的总称。
- **软件**指在硬件上运行的程序和相关的数据及文档。

### 计算机硬件

现代的计算机都是基于冯诺依曼提出的存储程序的概念，以此概念为基础的各类计算机称为*冯诺依曼机*，其特点如下：
1. 采用存储程序的工作方式。
2. 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备组成。
3. 指令和数据以同等的地位存储在存储器中，形式上没有区别。
4. 指令和数据均使用二进制代码表示。
5. 指令由操作码和地址码组成，操作码指出操作的类型，地址码输出操作数的地址。

> [!note] 存储程序的基本思想
> 将事先编制好的程序和原始数据送入主存储器后才能执行。一旦程序被执行，就无须操作人员的干预，计算机会自动逐条执行指令，直到程序执行结束。

> [!warning] 冯诺依曼机的基本工作方式为**控制流驱动**方式，而数据流则被驱动来完成任务。

> [!note] 计算机中的各个功能部件
> 1. **输入设备**：将程序与数据以机器可以识别和接受的方式输入计算机。*一般而言，我们会基于一个协议来处理数据 (其实就是驱动软件)，最常用的输入设备包括键盘、鼠标、扫描仪等*。
> 2. **输出设备**：将计算机处理的结果以人们可以接受的形式输出。*同输入设备，常见的有显示器、打印机等*。
> 3. **存储器**：存储器包含**主存储器**(也叫内存或者主存) 和**辅助存储器**(也称为外存储器或者外存)。CPU 可以直接访问主存，而外存用于辅助计算机存储更多的数据，其具体的工作原理参照 [[02_Areas/计算机组成原理/存储系统|存储系统]]。*外存一般使用硬盘*。地址译码器一般包含在存储器中，但是现代很多的 CPU 都集成了地址译码器。
> 4. **运算器**：运算器是计算机中的执行部件，用于进行算术运算^[加、减、乘、除等] 和逻辑运算^[与、或、非、异或、比较、移位等]。运算器的核心是**算术逻辑单元** (ALU)，还包含一些重要的寄存器，例如*累加器 (ACC)，商乘寄存器 (MQ)、操作数寄存器 (X)，变址寄存器 (IX)、基址寄存器 (BR) 等*。
> 5. **控制器**：控制器是整个计算机的指挥中心，由控制器指挥各个部件协调的进行工作。*在控制器中，我们使用程序计数器 (PC)、指令寄存器 (IR) 和控制单元 (CU) 来控制程序的执行*。

> [!tip]
> 我们一般将运算器和控制器集成到同一个芯片上，称为 [[02_Areas/计算机组成原理/中央处理器|中央处理器]] (也就是我们常说的 CPU)。CPU 和主存储器共同构成主机，即一台计算机实际上只需要这两个部件就可以运行程序。除了主机之外的其他硬件设备 (如 IO 设备、外存等) 统称为**外部设备**，简称为外设。

> [!tip] 这一节我们仅简单了解计算机包含哪一些组件，具体的工作原理到具体的章节再学习。

### 计算机软件

软件按照其功能划分，可以分为系统软件和应用软件：
1. 系统软件：一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。*系统软件包含 [[02_Areas/操作系统/操作系统基本原理概论|操作系统]]、[[00_Inbox/数据库/数据库系统引论#数据库管理系统|数据库管理系统]]、[[00_Inbox/编译原理/编译器简介|语言处理程序]]、分布式软件系统、网络软件系统、标准库程序、服务性程序等*。
2. 应用软件：指用户为了解决某个应用领域的各类问题而编制的程序。

> [!note]- 程序员的分类 (不重要)
> 在本学科范畴内，编写诸如操作系统、编译程序等各种系统软件的人员称为*系统程序员*，而利用计算机支持的系统软件来编写解决具体应用问题的人员称为*应用程序员*。

> [!note] 编程语言的级别
> 1. 机器语言：也称为二进制代码语言，是机器唯一可以直接识别和执行的语言。*计算机可以参照机器语言进行寻址、运算与存储等操作*。
> 2. 汇编语言：汇编语言是使用英文单词或其缩写替代二进制的指令代码，更加容易被人们记忆和理解。机器在执行汇编语言之前，需要经过一个称为*汇编程序*的系统软件，翻译为机器语言后，才能在计算机的硬件系统上执行。
> 3. 高级语言：例如 C 语言、java 语言等，是为了方便程序设计人员写出解决问题的处理方案和解题过程的语言。*这些高级语言通常要经过编译程序，编译为汇编语言程序，然后再经过汇编程序得到机器语言程序之后才能执行；或者一些汇编程序可以直接生成机器语言程序。*

> [!seealso] 翻译程序
> 在计算机中，对语言进行翻译的程序有三种，它们分别对应三种类型的语言：
> 1. 汇编程序 (汇编器)：对应汇编语言，将汇编语言翻译为机器语言。
> 2. 解释程序 (解释器)：对应解释型语言，将语句逐条翻译为机器指令，然后执行。
> 3. 编译程序 (编译器)：对应编译型语言，将代码翻译为汇编语言或者机器语言。

在计算机中，软件和硬件具有的能力是相同的，即*一个功能，使用硬件实现和使用软件实现在用户的角度是相同的*。但是由于硬件实现的速度快、代价高，因此我们往往使用硬件实现一些最基本的算术运算、逻辑运算的功能，其他的大部分功能通过软件的扩充实现。

### 计算机系统的层次结构

一台计算机是一个软硬件的综合体，有着复杂的软件和硬件系统。通过捋情形计算机的多层次结构，可以从各种角度看到机器的有机联系，以便构成合理、高效的计算机系统。

关于计算机系统层次结构的分层方式，目前尚无统一的标准。这里根据抽象程度低到高给出一种划分方式：
1. 微程序机器 M0 (微指令系统)：由硬件直接执行微指令。
2. 传统机器 M1 (用机器语言的机器)：用微程序解释机器指令。
3. 虚拟机器 M2 (操作系统机器)：用机器语言解释操作系统。*从这一级别开始计算机开始配备软件*。
4. 虚拟机器 M3 (汇编语言机器)：用汇编程序翻译成机器语言程序。
5. 虚拟机器 M4 (高级语言机器)：用编译程序翻译成汇编语言程序。

> [!example]- 计算机的层次结构
> ![[Assets/计算机系统概述-1.png#center|400]]

> [!note]
> 没有配备软件的纯硬件系统称为*裸机*，第 3 层到第 5 层称为*虚拟机*。虚拟机只对该层的观察者存在，对于某层的观察者而言，只能通过该层语言来了解和使用计算机，而不关系下层是如何工作的。
>
> 软硬件的交界面就是*指令集体系结构*(ISA)，ISA 定义了一台计算机可以执行的所有指令的集合。可以看出，ISA 是软件能够执行的所有操作，也就是*软件可见部分*。

> [!tip] 在计算机组成原理中，我们主要讨论 M0 和 M1 两个级别，不考虑软件部分。而在操作系统中，我们主要考虑 M2、M3、M4 这些内容。

## 计算机系统的工作原理

现代的计算机都是基于冯诺依曼架构的，即使用**存储程序**的工作方式。

在开始执行程序之前，我们需要将程序所含的指令 (和数据) 按顺序存储在内存中，并使 PC 指向第一条指令所在的地址。随后的工作流程主要分为四个步骤：
1. 根据 PC 中的内容，访问内存，取出当前需要执行的指令，存放到 IR 中。
2. 同时 PC 值加上指令的长度 (一般称为 PC+1)，即指向下一个指令所在的地址 (这里忽略了跳转指令)。
3. 根据 IR 中的内容，取出对应地址的操作数并执行对应的指令。

> [!note] PC 寄存器和 IR 寄存器
> - 程序计数器 (PC) 用来存放当前欲执行指令的地址，具有自动加 1 的功能，即执行一条指令后，会自动指向下一条指令的地址，它与主存储的 MAR^[存储器地址寄存器，用于寻址，存放经过地址译码后找到的存储单元] 之间有一条直接通路。
> - 指令寄存器 (IR) 用于存放当前的指令，其内容来自主存储器中的 MDR^[存储器数据寄存器，用于暂存要从存储器中读取的值]。

> [!note] MAR 寄存器和 MDR 寄存器
> - MAR (Memory Address Register) ：主存地址寄存器，用来保存数据被传输到的位置的地址或者数据来源的地址。其中记录的是一个地址，因此 MAR 的长度为地址码长度。
> - MDR (Memory Data Register) ：主存数据寄存器，用来要被写入地址单元或者从地址单元读出的数据。其中记录的是一个数据，因此 MDR 的长度为存储字长。
>
> *需要注意的是，MAR 与 MDR 虽然集成在 CPU 中，但是不属于控制器和运算器，是用于平衡主存与寄存器存取速度差异而引入的寄存器。*

^MarMdr

> [!tip] 跳转指令的执行
> 上述过程是通过硬件实现的，因此根据 PC 访问内存后，PC 中的内容将会自动加一。在这之后的下一个时钟周期，我们才会执行 IR 中的指令，此时如果 IR 中的是跳转指令，则再次修改 PC 的值。这样，下一次根据 PC 取指令的时候就可以跳转到其他的指令执行了。

> [!example] 具体的执行过程描述
> 下面以取数指令 (送到运算器的 ACC 寄存器中) 为例子说明一个指令的具体执行过程：
> 1. 取指令：PC -> MAR -> M -> MDR -> IR </br> 根据 PC 取指令到 IR。*具体来说，将 PC 的内容送到 MAR，MAR 中的内容直接送地址线，同时控制器将读信号送到读/写信号线，主存根据地址线和读信号，从指定存储单元读出指令，送到数据线上，MDR 从数据线接收指令信息，并传送到 IR 中。*
> 2. 分析指令：OP (IR) -> CU </br> 指令译码并送出控制信号。*具体来说，控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR 中是取数指令，因此读控制信号被送到总线的控制线上。*
> 3. 执行指令：Ad (IR) -> MAR -> M -> MDR -> ACC </br> 取数指令。*具体的，将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线，同时控制器将读信号送读/写线信号线，从主存储器中读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。*

### 从源程序到可执行文件

在计算机中编写的 C 语言程序，都必须被转换为一系列的低级机器指令。这些指令按照一种被称为**可执行目标文件**的格式打包，并以二进制磁盘文件的形式存放起来。以 GCC 编译器为例，将 C 语言翻译为可执行文件有四个步骤：
1. **预处理阶段**：预处理器 (cpp) 对 C 程序中的宏命令进行处理。*例如将 `#include` 中的内容插入到文件中，或者 `#define` 替换代码中的字符串*。通过该步骤将输出一个 `.i` 文件。
2. **编译阶段**：编译器 (ccl) 对预处理后的源程序进行编译，生成一个汇编语言源程序 `.s` 文件。
3. **汇编阶段**：汇编器 (as) 将 `.s` 文件翻译为对应的机器语言指令，把这些指令打包成**一个可重定位目标文件**`.o`，它是一种二进制文件。
4. **链接阶段**：链接器 (ld) 将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，简称**可执行文件**。

## 计算机的性能指标

### 机器字长

通常说的*某 16 位或 32 位机器*中的 16、32 就是指**机器字长**，简称为**字长**。字长是指计算机进行一次整数运算所能处理的二进制数据的位数，通常与 CPU 的寄存器、ALU 有关。因此，字长一般等于通用寄存器的位数或者 ALU 的宽度。字长越长，数的表示范围越大，计算精度越高。

> [!tip] 计算机的字长一般为字节 (8 位) 的整数倍。

> [!example] 机器字长与下面的说法等价：
> - 机器指令的位数
> - 数据运算的基本单位长度
> - CPU 定点运算的数据通路宽度
> - 通用寄存器的位数
> - 能够同时处理的二进制数的位数
> - ALU 位数

> [!example]
> 需要区分字和字长的概念，其中字长是指 CPU 内部用于整数运算的数据通路的宽度，因此字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度，它反映了计算机处理信息的能力。而字是用来表示被处理信息的单位，用于度量数据类型的宽度。*例如 x86 机器中将一个字定义为了 16 位*。
> - 指令字长：一个指令字中包含的二进制代码的位数，可能与机器字长不同，因此 IR 中的数据与机器字长不一定相同。
> - 存储字长：一个存储单元存储的二进制代码的位数。

> [!tip] 各种字长汇总
> 1. **机器字长**：这是指 CPU 一次能够处理的二进制数据的位数，它决定了运算精度，与 CPU 内部的寄存器位数有关，并影响计算机的运算速度。机器字长通常也反映了 CPU 内部数据通路的宽度以及运算器进行定点数运算的能力。例如，在 64 位的处理器中，CPU 可以在一个时钟周期内处理 64 位的数据。
> 	- 机器字长等价于 ALU（算术逻辑单元）的宽度和通用寄存器（GPRs）的位数。
> 2. **指令字长**：这指的是机器指令中二进制代码的总位数，包括操作码和操作数地址的信息。指令字长并不一定总是等于机器字长；它可以是固定长度或变长的，取决于具体的设计。对于某些体系结构，如 Intel 8086，其指令格式可以是 1 到 6 个字节不等，从而支持从简单的单字节指令到更为复杂的多字节指令。
> 	- 指令字长通常对应于指令寄存器（IR）的位数，因为 IR 用于保存当前正在执行的指令。
> 3. **存储字长**：这表示存储器中一个存储单元所能存储的二进制代码的长度。存储字长可以是 8 位、16 位、32 位等，并且必须是字节（8 位）的整数倍。早期计算机中，存储字长往往与机器字长相匹配，但随着技术的发展，两者之间不再强制一致。例如，一台拥有 64 位机器字长的系统可能会有 32 位的存储字长。
> 	- 存储字长通常与总线宽度相同，因为它决定了每次内存访问能传输的数据量。
> 4. **MAR(Memory Address Register，内存地址寄存器) 位数**：MAR 的位数决定了可以直接寻址的内存空间大小。换句话说，MAR 的位数代表了可访问的存储单元数量，即 `2^(MAR位数)` 个存储单元。例如，如果 MAR 为 32 位，则理论上可以寻址超过 4GB 的内存空间。MAR 位数等同于地址总线上的线数，因为它用来指定要访问的具体内存位置。
> 	- **虚拟地址与物理地址**：现代计算机系统中，程序通常运行在虚拟地址空间中，通过 MMU（内存管理单元）将其转换为物理地址。这意味着 MAR 实际使用的位数可能小于地址总线的位数，因为后者是针对物理地址设计的。
> 5. **MDR(Memory Data Register，内存数据寄存器) 位数**：MDR 用于临时存放从内存读取的数据或将要写入内存的数据。它的位数等于存储字长，意味着每个存储单元的数据宽度。例如，当 MDR 为 16 位时，这意味着每个存储单元可以容纳 16 位的数据。因此，MDR 位数不仅等价于存储字长，还反映了数据总线的宽度，因为数据在 CPU 和内存之间的传输也是基于这个宽度来进行的。
> 	- **Cache 行宽度**：在现代处理器中，为了加速内存访问，常使用缓存机制。缓存行（cache line）是指一次从主存加载到 Cache 中的最小数据单位，其宽度一般大于存储字长，例如常见的 64 字节 Cache 行。

### 数据通路带宽

**数据通路带宽**指数据总线一次所能传送信息的位数。这里的数据通路宽度指外部数据总线的宽度，它与 CPU 内部的数据总线宽度可能不同。

> [!note] 各个子系统通过数据总线连接形成的数据传送路径称为数据通路。

### 主存容量

主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可以用字数×字长 (例如 512K×16 位) 来表示存储容量。

> [!note] 乘法表示的含义
> 使用乘法表示主存容量时，MAR 的位数反映了存储单元的个数，MDR 的位数反映了存储单元的字长。例如，MAR 有 16 位，表示 $2^{16}=65536$，即此存储体内有 $65546$ 个存储单元 (一般称为 64K 内存)，若 MDR 为 32 位，则表示存储容量为 64K × 32 位。

### 运算速度

1. 吞吐量和响应时间：
	- 吞吐量：指系统在单位时间内处理请求的数量。*系统吞吐量主要取决于主存储器的存取周期*。
	- 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。*通常包括 CPU 时间 (运行一个程序所花费的时间) 与等待时间 (用于磁盘访问、存储器访问、IO 操作等时间)*。
2. 主频和 CPU 时钟周期
	- CPU 时钟周期：机器内部主时钟脉冲信号的宽度，它是 CPU 工作的最小时间单位。
	- 主频 (CPU 时钟频率)：机器内部主时钟的频率，即时钟周期的倒数。*它是衡量机器速度的重要参数，对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快*。
3. CPI (Cycle Per Instruction)：执行一条指令所需的时钟周期数。*CPI 主要取决于指令集的设计、计算机系统的结构，这些基本的设计会影响一条指令执行所需要的时钟周期数*。CPI 与时钟频率无关。
4. IPS (Instructions Per Second)：每秒执行多少条指令，IPS=主频/CPI。
5. CPU 执行时间：指运行一个程序所花费的时间。
6. MIPS (Million Instructions Per Second)：每秒执行多少百万条指令。
7. FLOPS (Floating-point Operations Per Second)：每秒执行多少次浮点运算。

> [!note]
> 1. 计算机的时钟周期一般是以相邻状态单元间组合逻辑电路的最大延迟为基准确定的，或者也可以由指令流水线的每个流水段的最大延迟时间确定。
> 2. CPU 时钟周期=1/主频，主频通常以 Hz 为单位。
> 3. 不同指令的时钟周期数可能不同，因此对于一个程序或者一台机器来说，其 CPI 指该程序或者该机器指令集中的所有指令执行所需的平均时钟周期数，此时 CPI 是一个平均值。
> 4. CPU 执行时间=程序的总 CPU 时钟周期数/主频=(指令条数 × CPI) / 主频。**该式表明，CPU 的性能主要取决于主频、CPI 和指令条数**。
> 	- 更改指令集可以减少程序所含的指令条数，但是同时可能引起 CPU 结构的调整，从而可能增加时钟周期的宽度 (降低主频)。
> 5. MIPS =指令条数/(执行时间 × $10^{6}$)=主频/(CPI× $10^{6}$)
> 	- MIPS 对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也不同。
> 6. 更多的浮点数运算指标包括：MFLOPS ($10^{6}$)，GFLOPS ($10^{9}$)，TFLOPS ($10^{12}$)，PFLOPS ($10^{15}$) 等等向上类推。

> [!tip] 常用单位
> 计算机常用单位包括：
> - M，$10^{6}$ 或 $2^{20}$
> - G，$10^{9}$ 或 $2^{30}$
> - T，$10^{12}$ 或 $2^{40}$
> - P，$10^{15}$
> - E，$10^{18}$
> - Z，$10^{21}$
>
> 可以使用口诀**美国突破二战**记忆，即 MGTPEZ，按照 $10^{3}$ 递增。

> [!tip]
> 尽管提高 CPU 的主频（即处理器的速度）曾经是提升性能的有效方法，但在今天，由于主频已经达到非常高的水平，这种方法面临新的挑战。比如，更高的主频会导致更多的热量产生，这对散热系统提出了更高要求；同时，硅材料的物理极限也限制了进一步的频率提升。因此，在现代 CPU 设计中，单纯依赖增加主频来提升性能已不再是最优选择。相反，通过开发更高效的并行处理架构，比如多核心技术和更好的任务分配策略，可以更有效地增强 CPU 的整体性能。

### 基准程序

基准程序 (Benchmarks) 是专门用来进行性能评价的一组程序，能够很好的反映机器在运行实际负载时的性能，可以通过在不同的机器上运行相同的基准程序，比较在不同机器上的运行时间，从而评测其性能。

> [!note]
> 使用基准程序来进行计算机评测也存在一些缺陷，例如基准程序的性能如果依赖于某一小段短代码，那么硬件系统设计人员就可以针对这些代码片段进行特殊的优化，使得这段代码的执行速度非常快。

> [!note] 几个专业术语
> 1. 系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。
> 2. 兼容：指软硬件的通用性，即运行在某个型号的计算机系统中的软、硬件也能够应用与另一个型号的计算机系统时，称这两个型号的计算机在硬件上或者软件上存在兼容性。
> 3. 固件：将程序固化在 ROM 中组成的部件称为固件。这是一种具有软件特性的硬件，吸收了软件、硬件的优点，其执行速度快于软件，灵活性由于硬件。*常用于操作系统的中一些启动代码、主板中的 BIOS 等程序*。

> [!tip]
> 基准程序一般能够反映机器性能的好坏，但是不绝对。

| [[02_Areas/计算机组成原理/数据的表示和运算|数据的表示和运算]] >
