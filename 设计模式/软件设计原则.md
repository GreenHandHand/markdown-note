---
tags:
  - 设计模式
---

# 软件设计原则

 一个优秀的软件设计应当满足：
 
 - **代码复用**： 无论是开发何种软件产品，成本和时间都是最重要的两个维度。代码复用是减少开发成本时最常用的方法之一。与其反复从头开发，不如在新对象中重写已有代码。
 - **拓展性**：需求是变化的，想法是变化的，因此在设计程序架构时，所有有经验的开发者会尽量选择支持未来任何可能变更的方式。

对于一个项目而言，这里给出了几个通用的软件设计原则。绝大部分的设计模式都是遵循这些原则的。

## 封装变化的内容

> [!definition|原则一] 找到程序中变化的内容并将其与不变的内容区分开。

该原则的主要目的是将变更造成的影响最小化。封装包含两个层次：
1. **方法层面的封装**：将容易发生变化的代码封装到一个方法中，与其他不变的部分隔离。当代码变得过于复杂时，也可以更加方便地将其移动到独立的类中。
2. **类层面的封装**：避免让一个方法的职责过于复杂，将所有的这些内容抽取到一个新类中。

## 面向接口开发

> [!definition|原则二] 面向接口进行开发，而不是面向实现；依赖于抽象类型，而不是具体类型。

如果无需修改就可以拓展，那就可以说这样的设计是灵活的。当你需要两个类进行合作时，可以让其中一个类依赖于另一个类。但是实际上，我们可以采用一种更加灵活的方式处理：
1. 确定一个对象对另一个对象的确切需求，即它需要执行哪些方法。
2. 在一个新的接口或抽象类中描述这些方法。
3. 让被依赖的类实现该接口。
4. 让有需求的类依赖这个接口，而不依赖具体的类。

## 组合优于继承

> [!definition|原则三] 组合优于继承。

继承虽然是类之间最明显、最便捷的代码复用方式，但是继承在程序中包含了大量的类时，就会引起一些难以解决的困难：
- 子类不能减少父类的接口：你需要实现父类中的所有抽象方法，即使它们没什么用。
- 在重写方法时，需要确保新行为与基类中的版本兼容：因为子类的所有对象都可能被传递给父类对象为参数的代码。
- 继承打破了父类的封装：因为子类可以访问父类内部的内容。
- 子类与父类紧密耦合：父类的任何修改都可能会破坏子类的功能。

**组合**是替代继承的一种方法。继承代表类之间的*是*关系，而组合代表类之间的*有*关系。

> [!note] 这个原则也适用于聚合。
> 一个对象可以引用另一个对象，但是不管理其生命周期。

## SOLID 原则

SOLID 代表五条原则，由 Robert C·Martin 在《敏捷软件开发：原则、模式与实践》中首次提出。SOLID 是让软件设计易于理解、更加灵活和更易维护的五个原则的简称。当你对于重构复杂的代码摸不着头脑时，回顾这五个原则可以帮助你写出简洁清晰的代码。

### 单一职责原则

> [!definition|原则四] 单一职责原则 (*Single Responsibility Principle*)
> 修改一个类的原因只能有一个。

尽量让每个类只负责软件中的一个功能，并将该功能完全封装在类中。

### 开闭原则

> [!definition|原则五] 开闭原则 (*Open/Closed Principle*)
> 对于拓展，类应该是*开放*的；对于修改，类则应该是*封闭*的。

该原则的主要理念是在实现新功能时保持已有的代码不变。
- 开放：如果你可以对一个类进行拓展，可以创建它的子类或对其做任何事情，那么这个类就是开放的。
- 封闭：如果某个类已做好了充分的准备并可供其他类使用，其接口定义后不会再被修改，那么该类就是封闭的。

### 里氏替换原则

> [!definition|原则六] 里氏替换原则 (*Liskov Substitution Principle*)
> 当你拓展一个类时，记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。

这意味着子类必须保持父类行为的兼容。在重写一个方法时，需要对基类行为进行拓展，而不是将其完全摧毁。

替换原则主要要求我们在编写代码时预测子类是否能与父类的代码兼容。该原则对子类重写方法提出了形式要求：
1. 子类方法的参数类型必须与父类的参数类型相匹配，或更加抽象。
2. 子类方法的返回值类型必须与父类方法的返回值类型、或者其子类别相匹配。
3. 子类中的方法不应该抛出基础方法与其之外的异常类型。
4. 子类不应该加强其前置条件。
5. 子类不能削弱其后置条件。
6. 父类的不变量必须保留。
7. 子类不能修改父类中的私有成员变量。

### 接口隔离原则

> [!definition|原则七] 接口隔离原则 (*Interface Segregation Principle*)
> 客户端不应该被强迫依赖于其不使用的方法。

尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。

### 依赖倒置原则

> [!definition|原则八] 依赖倒置原则 (*Dependency Inversion Principle*)
> 高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。

在设计软件时，我们可以辨别出不同层次的类：
- **低层次的类**实现基础操作，例如磁盘读写、传输网络数据和连接数据库等。
- **高层次的类**包含复杂业务逻辑以及指导低层次类执行特定操作。

一般的想法是先设计低层次的类，然后才开发高层次的类。当你在新系统上开发原型时，这很常见。由于低层次的东西还没有实现或者不确定，你甚至无法确定高层次能实现哪些功能。如果采用这种方法，业务逻辑类会更加依赖于底层原语类。

依赖倒置原则建议改变这种依赖方式，先定义低层次接口，高层次依赖于低层次接口，而低层次的类则实现这些接口，从而倒置了原始的依赖关系。

---

< [[设计模式/设计模式概述|设计模式概述]] | [[设计模式/工厂方法|工厂方法]] >
