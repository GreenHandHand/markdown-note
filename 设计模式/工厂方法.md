---
tags:
  - 设计模式
  - 创建型模式
aliases:
  - 虚拟构造函数
  - Virtual Constructor
  - Factory Method
---

# 工厂方法

> [!definition|Definition] 工厂方法模式
> 定义一个创建对象的接口，但由子类决定要实例化的具体类。工厂方法使一个类的实例化延迟到其子类。

> [!info] 别名：虚构造函数（Virtual Constructor）、工厂方法（Factory Method）

![[image/工厂方法.png]]

## 核心思想

工厂方法模式的核心思想是**封装对象创建的变化**。当一个类不知道它所必须创建的对象的类时，或者当一个类希望由它的子类来指定所创建的对象时，就可以使用工厂方法。它通过引入一个抽象的**工厂**概念，将**产品**的实例化过程从客户端代码中分离出来，从而实现了良好的解耦。

## 结构

一个典型的工厂方法模式包含以下四个核心角色：

1. **产品 (Product)**
    - 定义了工厂方法所创建的对象的通用接口。所有具体的产品都必须实现这个接口。
    - *例如：一个 `Button` 接口，定义了所有按钮都应具备的 `render()` 和 `onClick()` 方法。*
2. **具体产品 (Concrete Product)**
    - 是产品接口的具体实现。这些是工厂方法实际创建出来的对象。
    - *例如：`WindowsButton` 和 `MacButton` 是 `Button` 接口的两种具体实现，它们各自有不同的外观和行为。*
3. **创建者 (Creator)**
    - 声明了返回产品对象的工厂方法 `factoryMethod()`。该方法的返回类型必须是产品接口 (`Product`)。
    - 创建者类也可以包含依赖于抽象产品接口的业务逻辑。它将具体产品的创建细节委托给子类来完成。
    - 这个类通常是抽象的 (接口、trait)，不能被直接实例化。
4. **具体创建者 (Concrete Creator)**
    - 重写 (Override) 基类中的工厂方法，使其返回一个指定类型的具体产品 (`Concrete Product`)。
    - 每个具体创建者都对应一种或一类具体产品。客户端代码直接与具体创建者交互，以获得特定的产品实例。
    - *例如：`WindowsDialog` 创建者会重写工厂方法以返回一个 `WindowsButton` 实例，而 `MacDialog` 则会返回一个 `MacButton` 实例。*

## 使用场景

- ✅ 当代码中无法预先确定要创建的具体类时。
- ✅ 当希望通过扩展已有框架来生成对象时（例如：插件式架构、UI 组件工厂）。
- ✅ 当希望将对象的创建与使用解耦时，使得客户端代码无需关心具体类名与构造细节。
- ✅ 当对象的创建逻辑较复杂，可能需要复用、缓存或条件控制时。

> [!note]
> 许多设计工作的初期都会使用工厂方法，因为工厂方法较为简单。随后演变成使用抽象工厂、原型或生成器。
>
> 工厂方法是模板方法的一种特殊形式，同时，工厂方法可以作为大型模板方法中的一个步骤。

## 实现步骤

1. 定义一个通用的产品接口，声明所有产品必须实现的方法。
2. 创建多个实现该接口的具体产品类。
3. 在创建者类中声明一个工厂方法，返回产品接口类型。
4. 创建者的子类重写该工厂方法，返回不同的具体产品。
5. 客户端通过调用创建者的方法使用产品，而无需直接依赖具体产品类。

## 伪代码

```rust
// 产品接口：按钮
trait Button:
    fn render()
    fn on_click()

// 具体产品：HTML 按钮
impl Button for HtmlButton:
    fn render()        // 显示 HTML 样式按钮
    fn on_click()      // 设置标志为点击 + 打印消息

// 具体产品：Windows 按钮
impl Button for WindowsButton:
    fn render()        // 显示 Windows 样式按钮
    fn on_click()      // 打印点击消息

// 抽象工厂接口
trait Dialog:
    fn create_button() -> dyn Button

// 具体工厂：HTML 对话框
impl Dialog for HtmlDialog:
	fn create_button() -> dyn Button     // 返回 HtmlButton 实例
		HtmlButton::new()

// 具体工厂：Windows 对话框
impl Dialog for WindowsDialog:
    fn create_button() -> dyn Button     // 返回 WindowsButton 实例
	    WindowsButton::new()
```

## ✔️ 优点

- **降低耦合度**
    - 将产品的创建过程与使用产品的客户端代码解耦。客户端代码只依赖于抽象的产品和创建者接口，而不需要关心具体的产品是如何被创建的。
- [[设计模式/软件设计原则#单一职责原则|单一职责原则]]
    - 将产品创建的逻辑集中到一个地方（各个具体创建者子类中），使得代码结构更清晰，更易于维护和调试。
- [[设计模式/软件设计原则#开闭原则|开闭原则]]
    - 当需要引入新的产品类型时，只需创建新的具体产品类和具体创建者子类即可，无需修改现有的客户端代码或抽象层代码，符合开闭原则，提高了系统的可扩展性。

## ✖️ 缺点

- **增加代码复杂度**
    - 为了实现该模式，需要引入大量的接口和子类（每个产品都需要一个对应的创建者子类）。这可能会导致类的数量剧增，从而增加整个系统的复杂度和理解难度。对于简单的场景，这可能是一种“过度设计”。

## 实现

> [!example]- Rust 实现：跨平台按钮的工厂方法模式
>
> ```rust
> // 定义产品接口：所有按钮必须实现的功能
> pub trait Button {
>     fn render(&self);
>     fn on_click(&mut self);
> }
> 
> // 定义创建者接口：提供一个工厂方法来创建产品
> pub trait Dialog {
>     fn create_button(&self) -> Box<dyn Button>;
> }
> ```
>
> ```rust
> // HTML 平台：具体产品和具体创建者
> use crate::gui::{Button, Dialog};
> 
> pub struct HtmlDialog;
> 
> pub struct HtmlButton {
>     is_clicked: bool,
> }
> 
> impl Button for HtmlButton {
>     fn render(&self) {
>         println!("<button clicked='{}'>HTML Button</button>", self.is_clicked);
>     }
> 
>     fn on_click(&mut self) {
>         self.is_clicked = true;
>         println!("HTML Button Clicked");
>     }
> }
> 
> impl Dialog for HtmlDialog {
>     fn create_button(&self) -> Box<dyn Button> {
>         Box::new(HtmlButton { is_clicked: false })
>     }
> }
> ```
>
> ```rust
> // Windows 平台：另一套产品与创建者实现
> use crate::gui::{Button, Dialog};
> 
> pub struct WindowsDialog;
> pub struct WindowsButton;
> 
> impl Button for WindowsButton {
>     fn render(&self) {
>         println!("[Windows Button]");
>     }
> 
>     fn on_click(&mut self) {
>         println!("Windows Button Clicked");
>     }
> }
> 
> impl Dialog for WindowsDialog {
>     fn create_button(&self) -> Box<dyn Button> {
>         Box::new(WindowsButton)
>     }
> }
> ```
>
> ```rust
> // 工厂方法的客户端逻辑
> use crate::gui::{Dialog, Button};
> use crate::html_dialog::HtmlDialog;
> use crate::windows_dialog::WindowsDialog;
> 
> pub fn get_dialog() -> Box<dyn Dialog> {
>     if cfg!(windows) {
>         Box::new(WindowsDialog)
>     } else {
>         Box::new(HtmlDialog)
>     }
> }
> 
> pub fn run_app() {
>     let dialog = get_dialog();
>     let mut button = dialog.create_button();
> 
>     // 客户端逻辑仅依赖接口，不关心具体产品
>     button.render();
>     button.on_click();
> }
> ```
>
> ```rust
> fn main() {
>     dialog_rendering::run_app();
> }
> ```

---

< [[设计模式/软件设计原则|软件设计原则]] | [[设计模式/抽象工厂|抽象工厂]] >
