---
tags:
  - 计算机图形学
---

# 着色

着色 (*Shading*) 在计算机图形学中表示为片元添加纹理与材质 (*materials*) 的过程。它通过模拟光线与物体表面的相互作用，为模型带来明暗、颜色和质感。

>[!note] 着色与阴影
>着色 (*shading*) 与阴影 (*shadow*) 不同。着色虽然会为物体添加上明暗细节，但它只考虑物体与光源的相互作用（局部光照），不会考虑不同物体之间的相互遮挡。阴影则正是处理这种遮挡关系所产生的视觉效果。

## Blinn-Phong 反射模型

Blinn-Phong 反射模型 (Blinn-Phong Reflectance Model) 是一种效果良好且计算高效的经验性光照模型。在该模型中，我们抽象出以下五大要素来描述光照：
1. **着色点 (Shading point):** 对于每一个平面，我们将其抽象为一系列着色点的集合。
2. **观察方向 (View direction):** 观察者所在的方向，使用单位向量 $\vec{v}$ 表示。
3. **法线方向 (Surface normal):** 平面的法线方向，使用单位向量 $\vec{n}$ 表示。
4. **光照方向 (Light direction):** 光照方向，使用单位向量 $\vec{l}$ 表示。
5. **表面参数 (Surface parameter):** 照射平面的各种参数，例如颜色、粗糙度等。

>[!example]-
>![[image/着色.png]]

一个物体的光照可以简单地由下面三种光照组成：
- 漫反射 (*Diffuse reflection*)
- 镜面反射、高光 (*Specular highlight*)
- 环境光 (*Ambient lighting*)

### 漫反射

从一个简单的例子开始：对于一个粗糙的物体，我们从任何角度观察都不会改变它的固有颜色，但在不同位置，其颜色的明暗程度有所区别。

这种现象的原因是，一个现实物体的表面总是凹凸不平的。当光线照射到该表面时，会向任意方向产生反射。然而，由于物体表面相对于光源的角度不同，导致单位面积接收到的光照能量不同，从而产生了明暗差异。

因此，我们将漫反射抽象为一种光线照射到着色点时，会向所有方向均匀散射的光照。其接收的光照数量（亮度）由**照度**来表示。

>[!info] 照度与光照强度
>照度是物理学中描述单位面积上所接收的光通量大小的量。它取决于光源的发光强度以及被照体与光源之间的距离，并呈现平方反比的规律。
> $$
> I_{r} = k\dfrac{I}{r^{2}}
> $$

>[!note] 朗伯余弦定理
>朗伯余弦定理 (Lambert’s cosine law) 定量描述了光照角度与照度之间的关系。
>
>![[image/着色-1.png]]
>
> 1. 当垂直照射时，平面会接收到照度为 $I$ 的光照。
> 2. 当入射角度为 60° 时，平面会接收到照度为 $0.5I$ 的光照。
> 3. 一般而言，当入射角度为 $\theta$ 时，每单位面积接收到的照度满足关系：$I\cos \theta = \vec{I}\cdot \vec{n}$。

根据朗伯余弦定理，我们可以得到漫反射光的经验公式：
$$
L_{d}=k_{d}(I/r^{2})\max(0, \mathbf{n}\cdot \mathbf{l})
$$
其中：
- $k_{d}$ 表示**漫反射系数**。对于灰度图，使用标量，其值越大越明亮。对于彩色图像，通常使用一个三维向量，表示 RGB 三种颜色的漫反射系数，通过不同组合可呈现不同颜色。
- $I/r^{2}$ 表示光照强度，其中 $I$ 是光源发出的光照强度，$r$ 是着色点与光源的距离。对于多个光源，只需将它们各自的漫反射光照求和即可。
- $\vec{n}\cdot \vec{l}$ 是法线向量与入射方向向量的点积，即夹角的余弦值。当点积为正时，光照强度与夹角的余弦成正比。当点积为负时，表示物体背朝光源，不存在光线照射，因此漫反射光为 0。
- 从上述公式可以看出，漫反射的光照与观察方向无关，只与光源和表面法线有关。

### 镜面反射

从一个例子开始：当我们看向光滑的物体时，根据我们观察的角度不同，物体上会出现一个非常亮的小点，这就是镜面反射导致的高光。

在中学物理中我们学过，当光线照射到镜面时，会沿着相同的角度反射，即「入射角等于出射角」。高光的形成正是因为在特定区域上，光线经过镜面反射后，正好反射到了观察者的方向。由于镜面反射对光照强度的损耗较小，因此出现了一个局部亮度远高于其他区域的高光。

在 Blinn-Phong 模型中，我们认为，当观察方向距离镜面反射的出射光越近时，我们观察到的高光越明显，并使用余弦相似度来衡量。

![[image/着色-4.png]]

直接计算反射向量 $\vec{R}$ 是复杂的，因此在 Blinn-Phong 模型中，我们不计算出射向量与观察向量的余弦，而是使用**半程向量 (half vector)** $\mathbf{h}$ 与法线向量 $\mathbf{n}$ 的余弦。在几何上，当 $\mathbf{h}$ 与 $\mathbf{n}$ 对齐时，反射向量 $\vec{R}$ 与观察向量 $\vec{v}$ 也对齐。同时，半程向量的计算要简单得多。

![[image/着色-3.png]]

半程向量的计算公式如下（这是一个单位向量）：
$$
\mathbf{h} = \frac{\mathbf{l} + \mathbf{v}}{\lVert \mathbf{l}+\mathbf{v} \rVert }
$$
在计算出半程向量后，我们使用下面的公式计算高光：
$$
\begin{aligned}
L_{s} &= k_{s}(I/r^{2})\max(0, \cos \alpha)^{p} \\
&= k_{s}(I/r^{2})\max(0, \mathbf{n}\cdot \mathbf{h})^{p}
\end{aligned}
$$
其中：
- $k_{s}$ 表示**镜面反射系数**，一般要远高于漫反射系数。
- $\vec{n}\cdot \vec{h}$ 表示半程向量与法线向量的余弦相似度。

>[!note] $p$ 的含义
>指数 $p$ 被称为**高光指数 (shininess)**。通过增大指数 $p$，可以让高光在边缘处衰减得更快，高光区域更小，从而模拟更光滑的材质。
>
>![[image/着色-5.png]]
>
>通过调整 $k_{s}$ 和 $p$，我们可以得到不同材质需要的高光效果：
>
>![[image/着色-6.png]]

### 环境光

除了之前考虑的漫反射和镜面反射，还有许多未考虑到的光照因素，例如光线在场景中的多次反射。由于这些光照通常强度较弱，Blinn-Phong 模型将其概括为**环境光**，并使用一个常数表示。
$$
L_{a}=k_{a}I_{a}
$$
其中 $k_{a}$ 是物体的环境光反射系数，$I_{a}$ 是环境光强度。

---

Blinn-Phong 反射模型就是上述三种光照的求和：
$$
\begin{aligned}
L&=L_{d}+L_{s}+L_{a} \\
&=k_{d}(I/r^{2})\max(0, \mathbf{n\cdot l}) + k_{s}(I/r^{2})\max(0, \mathbf{n\cdot h})^{p} + k_{a}I_{a}
\end{aligned}
$$

## 着色频率

着色公式可以计算出空间中每个点的颜色，但出于计算成本考虑，我们通常选择不同的着色频率：
- **对每个三角形着色 (Flat shading, Face):** 认为一个三角形的颜色唯一，对每个三角形进行一次着色。
- **对每个顶点着色 (Gouraud shading, Vertex):** 计算每个顶点的法线向量，对每个顶点进行着色，并使用插值的方式计算每个三角形的颜色。
- **对每个像素点着色 (Phong shading, Pixel):** 使用插值的方式计算出每个像素点对应位置的法线向量，然后为每个像素点进行单独着色。

三种着色方式所需的计算量不同，对不同面数的几何体，着色效果也不同。面数越多的几何体，三种着色方式的效果越接近。

![[image/着色-8.png|三种着色频率与几何体面数对着色结果的影响]]

>[!note] 补充说明
> - **计算顶点的法线向量:** 对于顶点交汇处，通常采用平均法线的方式，将相邻的所有法线向量求均值后再单位化：
> $$
> N_{v} = \frac{\sum_{i}N_{i}}{\left\lVert\sum_{i}N_{i}\right\rVert }
> $$
> - **计算每个像素的法线向量:** 通常采用**重心坐标插值方法 (Barycentric interpolation)**。

## 渲染管线

在实践中，我们将渲染过程抽象为一系列具有明确输入与输出的渲染管线。一个渲染管线是从三维空间坐标开始，将其一步步转换为显示器上像素点的过程。

一个典型的图像渲染管线包括：
1. **顶点处理 (Vertex Processing):** 模型变换，[[计算机图形学/变换#视图变换|视图变换]]，[[计算机图形学/变换#投影变换|投影变换]]。
2. **三角形处理 (Triangle Processing):** 将模型转换为三角形图元。
3. **[[计算机图形学/光栅化|光栅化]] (Rasterization):** 采样三角形，生成片元。
4. **片元处理 (Fragment Processing):** 处理光栅化得到的片元，包含 [[计算机图形学/光栅化#深度缓冲|深度测试]]、着色和纹理映射 (Texture mapping)。
5. **显示帧处理 (Framebuffer Operations):** 将片元颜色写入帧缓冲区并进行最终处理。

>[!info] 着色器 Shader
>在顶点处理和片元处理阶段，我们通常使用着色器 (*Shader*) 进行描述。着色器是一种强大的工具，它通过并行化的方式描述顶点与片元的处理过程。一种常见的着色器语言是 GLSL。

## 纹理

纹理 (Texture) 是一种附着在模型表面的图像，在渲染时表现出不同的颜色。通过将 2D 的纹理映射到 3D 模型的顶点上，从而将对应的区域显示到对应的三角形上。

纹理通常使用 $(u,v)$ 坐标系，单位为文素 (texel)，范围是 `[0, 1] x [0, 1]`。我们将模型的每个顶点对应到纹理坐标上的一个坐标位置，从而在渲染时快速查找对应的参数。

>[!note] 术语 footprint
>footprint 在计算机图形学中表示一个像素所代表的空间大小。当我们说 pixel footprint，我们表述的含义是这个像素对应到文素空间中的 $(u, v)$ 的范围。这里的 footprint 是一个范围，表示像素在模型上覆盖的范围区域。

### 重心坐标插值

要将纹理映射到三角形上，我们需要计算出三角形中的每个点对应纹理中的哪个位置。为了节约内存，我们只记录三角形的三个顶点，并使用插值来计算其内部点。

重心坐标插值 (Barycentric Coordinates) 是一种广泛应用于三角形插值的方式。根据三角形的性质，我们可以使用下面的公式表示三角形内部的任何点：
$$
\begin{aligned}
(x, y) = &\alpha A + \beta B + \gamma C \\
&\alpha + \beta + \gamma = 1
\end{aligned}
$$
其中，$\alpha,\beta,\gamma>0$。对于三角形 $\triangle ABC$ 内部的任意一点 $(x, y)$，我们可以利用重心坐标系 $(\alpha, \beta, \gamma)$ 来表示。

>[!note] 重心坐标的几何意义
>重心坐标可以利用面积的比值计算：
> $$
> \begin{aligned}
> \alpha &=\dfrac{\text{S}(\triangle PBC)}{\text{S}(\triangle ABC)} \\
> \beta &=\dfrac{\text{S}(\triangle PCA)}{\text{S}(\triangle ABC)} \\
> \gamma &=\dfrac{\text{S}(\triangle PAB)}{\text{S}(\triangle ABC)} \\
> \end{aligned}
> $$
>
>![[image/着色-9.png|重心坐标的几何意义]]

在计算机图形学中，我们通常已知三角形的三个顶点和内部像素点。要计算出对应的 $\alpha,\beta,\gamma$，可以利用下面的公式：
$$
\begin{aligned}
\alpha &= \dfrac{-(x-x_{B})(y_{C}-y_{B})+(y-y_{B})(x_{C}-x_{B})}{-(x_{A}-x_{B})(y_{C}-y_{B})+(y_{A}-y_{B})(x_{C}-x_{B})} \\
\beta &= \dfrac{-(x-x_{C})(y_{A}-y_{C})+(y-y_{C})(x_{A}-x_{C})}{-(x_{B}-x_{C})(y_{A}-y_{C})+(y_{B}-y_{C})(x_{A}-x_{C})} \\
\gamma &= 1 - \alpha - \beta
\end{aligned}
$$
对于三个顶点的任意属性 $(V_{A}, V_{B}, V_{C})$，我们可以利用重心坐标计算出对应点的值：
$$
V=\alpha V_{A} + \beta V_{B} + \gamma V_{C}
$$
这里的 $V$ 可以是任何值，包括纹理坐标、颜色、法线等。

>[!warning]
>重心坐标在经过投影操作后会发生变形，因此不能直接用于插值计算深度。在深度测试中，我们通常需要使用**修正的重心坐标插值**公式。

>[!example] 应用纹理
>要将纹理应用在光栅化得到的片元上，其基本流程为：
> 1. 计算每个像素坐标 $(x, y)$ 对应的纹理坐标 $(u, v)$。
> 2. 使用重心坐标插值采样得到对应的颜色。
> 3. 根据颜色设置对应的片元参数（例如 Blinn-Phong 反射模型中的 $k_{d}$）。

### 纹理放大

当纹理较小，无法覆盖整个模型表面时，我们需要对其进行**放大** (Texture Magnification)。这实际上是将纹理图像还原到原始空间后，对其进行重新采样。常用的方法有：
1. **最近邻 (Nearest):** 对于每个采样点，使用材质中最接近的点。
2. **双线性插值 (Bilinear):** 对于每个采样点，使用材质中最接近的 4 个点的双线性插值。
3. **三立方插值 (Bicubic):** 对于每个采样点，使用材质中最接近的 16 个点的三立方插值。

>[!note] 双线性插值
>双线性插值在计算机图像处理中广泛应用于放大图像。它通过在两个维度上进行三次一维线性插值来实现。我们通常定义一维线性插值为：
> $$
> \text{lerp}(x,v_{0},v_{1}) = v_{0} + x(v_{1} - v_{0})
> $$
>
>双线性插值实际上就是进行了三次线性插值：
> $$
> \begin{aligned}
> u_{0} &= \text{lerp}(s, u_{00}, u_{01}) \\
> u_{1} &= \text{lerp}(s, u_{10}, u_{11}) \\
> f(x, y) &= \text{lerp}(t, u_{0}, u_{1})
> \end{aligned}
> $$
>
>![[image/着色-10.png|双线性插值示意图]]

### 纹理缩小

当纹理过大，覆盖的屏幕像素区域很小，需要对其进行**缩小**(Texture Minification)。此时，如果简单地对纹理进行采样，会导致严重的**走样 (Aliasing)** 问题，表现为远处物体的纹理出现摩尔纹或闪烁、近处物体产生锯齿。

走样问题的原因是采样频率过低。一个屏幕像素对应了纹理上的一个大区域，如果仅取区域中的一点进行采样，就会丢失纹理细节，产生视觉伪影。

>[!tip] 不使用超采样的原因
>在 [[计算机图形学/光栅化#抗锯齿|光栅化]] 中，通过超采样的方式可以缓解走样问题。超采样确实能有效减少走样。通过在一个像素内进行多次采样并平均，它可以更真实地模拟像素覆盖区域的平均颜色，从而产生更平滑、更自然的图像。但是，超采样的代价非常大，要获得足够好的效果，可能需要非常多的采样点，这会极大地增加渲染的负担。

直接超采样虽然质量好，但面对高度缩小的纹理时，因为信号频率太高，需要极高的采样频率，导致计算成本过高。与光栅化不同，此时我们已经拥有了原始的纹理图像，我们可以考虑针对不同距离的像素，使用不同的范围进行平均。

这里通常使用**多级渐远纹理 (Mipmap)** 技术。Mipmap 是一种数据结构，广泛应用于计算机图形学中的各种范围查询中。它允许我们进行*快速、近似的方形区*域查询。

Mipmap 技术只能应用于大小为 2 的指数的图像上。在存储材质时，我们将将其进行预处理，存储为一个图像金字塔。金字塔中的每层图像都是原来的 $1/4$ 大小，将长宽同时减半。我们将金字塔从大到小分别命名为 $D=0,1,2,\cdots$，直到图像的大小为 $1\times 1$ 为止。当我们需要查询屏幕上一个像素点的纹理时，可以直接从 Mipmap 上查询得到，这是 $O(1)$ 时间复杂度的。

>[!note] 计算层级 $D$
>我们可以通过差分的方式计算一个像素对应的层级。
>
>![[image/着色-11.png|像素空间与文素空间]]
>
>要计算出一个像素在文素空间上对应的区域大小，我们将其与周围的像素点在文素空间中对应的坐标差分即可。
> 1. 对于点 $u_{00}$，我们取该点竖直方向相邻点 $u_{01}$ 与水平方向相邻点 $u_{10}$。
> 2. 分别计算竖直与水平方向上文素的微分，并取较大的一方。$L=\max(\sqrt{ (du/dx)^{2}+(dv/dx)^{2} }, \sqrt{ (du/dy)^{2}+(dv/dy)^{2} })$
> 3. 取对数得到层级 $D=\log_{2}L$

>[!note] 三线性插值
>一般而言计算得到的层级 $L$ 不会是一个整数。如果采用最近邻方法，得到的层级过度不平滑。一般而言，我们会利用最接近的两个层级对应的点进行插值。具体方法是，先在相邻的两个方向上利用双线性插值得到对应点的纹理，然后再在层级之间进行一次插值得到最终结果。
>
>![[image/着色-12.png]]

>[!note] 各向异性过滤
>三线性插值可以很好的缓解走样现象，但是由于 mipmap 只能查询方形区域，对于一些细条形的纹理显示效果很差。这是由于这些细条形的问题近似为方形区域时得到误差太大，造成远处物体显示模糊。各项异性过滤通过沿着两个坐标轴的方向进行下采样，保存更多的数据，以此来查询条形区域。
>
>![[image/着色-13.png|Mipmap的模糊原因]]
>
>![[image/着色-14.png|各项异性过滤]]
>
>各项异性过滤保存了一张原来图像 9 倍大小的图 (长宽各 3 倍)，在查询时，根据两个方向上的梯度进行查询。与三线性插值占用的 4/3 倍大小的空间，各项异性过滤使用更多的空间换取了更好的效果。

>[!info] 在这方面还有很多改进，例如 EWA 过滤通过保存很多椭圆形的 mipmap，通过多次查询可以查询不规则的区域。这是使用更多的时间换取了更好的效果。

### 纹理的应用

纹理在很多的方面都有应用。在现代的 GPU 中， 应用纹理就是对内存中的图像进行范围查询。下面是一些比较重要的应用。
- 环境光照 (environment lighting)。使用纹理可以模拟环境光照，只需要将环境光的反射内容提前记录在纹理中，就可以实时计算模拟出镜面的效果。
- 法线贴图、凹凸贴图 (normal/bump texture)。贴图除了可以记录颜色信息，还可以记录其他数据。法线贴图通过记录法线信息，凹凸贴图记录局部高度变化信息，来影响模型着色的结果，可以在简单的几何体上实现复杂的显示效果。
- 程序化噪声 (3D Procedual Noise)：通过程序实时生成噪声，并直接嵌入到 3 维模型的几何结构中。这种方法的优点是无限分辨率，内存占用小且易于控制。常用于地形生成、自然纹理等。
- 预计算着色：在渲染之前先计算并存储光照、阴影、反射等信息在纹理中，然后在渲染时直接应用到物理的表面。尤其适合用于静态场景或者光照不变的场景。
- 三维纹理渲染与体渲染 (3D Texture and Volume Rendering)：三维纹理是一种在三维空间中定义的颜色或密度数据数组（如体素数据），不同于 2D 纹理仅映射到表面，3D 纹理可以描述物体内部结构。体渲染是一种可视化 3D 纹理数据的技术，常用于医学成像（如 CT、MRI）、科学可视化和云/烟雾模拟。通过 3D 纹理，可以在切片、投影或光线投射过程中获取内部材质信息，实现逼真的内部结构展示。

>[!note] 凹凸贴图
>凹凸贴图可以在不添加三角形的情况下为模型添加更多的细节。具体而言，凹凸贴图存储了一个额外的高度图，在着色的过程中，对于每一个片元，在计算其位置时还要加上一个高度，使得法线的计算发生偏移，从而影响着色。
>
>一个具体的扰动计算过程如下：
> 1. 对于一个片元，建立一个局部的片元坐标系，片元的法线向量为 $n(p)=(0,0,1)$。
> 2. 计算这个片元所在高度图的梯度：$(-dp/du,-dp/dv,1)$
