---
tags:
  - 计算机图形学
---

# 光栅化

**光栅化**（*Rasterization*）是将几何图元（通常是三角形）从**标准视口体** (*Canonical View Volume*, CVV)（即 $[-1, 1]^3$ 的立方体空间）转换到屏幕像素坐标系，并将其表示为一系列**片元** (*Fragments*) 的过程。每个片元都包含了位置、颜色、深度和纹理坐标等信息，是构成最终像素颜色的基本单元。

## 视口变换

在所有几何变换的最后一步，我们需要将位于规范观察体积中的坐标映射到最终的显示屏幕上。**视口变换** (*Viewport Transform*) 的核心任务就是将 x 和 y 坐标从 `[-1, 1]^2` 转换到**屏幕坐标** (*Screen Coordinates*) `[0, width] x [0, height]`。

屏幕是由离散的像素点构成的阵列。**像素** (*Pixel*, Picture Element) 是图像显示的基本单位。在计算机内存中，屏幕上的图像通常被存储为一个二维数组（帧缓冲），显示器会读取这个数组来呈现画面。

为了将连续的 NDC 空间映射到离散的像素网格，视口变换首先将 `[-1, 1]^2` 的范围平移和缩放到 `[0, width] x [0, height]` 的屏幕空间。通常约定，一个像素 `(x, y)` 的中心位置对应于屏幕坐标系中的 `(x + 0.5, y + 0.5)`。

该变换可以通过以下矩阵实现：

$$
M_{\text{viewport}} = \begin{bmatrix}
w/2 & 0 & 0 & w/2 \\
0 & h/2 & 0 & h/2 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

这是一个简单的缩放与平移操作。在此步骤中，我们暂时忽略 Z 坐标，它将被用于后续的深度测试。

## 三角形

在现代计算机图形学中，几乎所有的三维模型最终都会被**三角化** (*Triangulated*)，即分解为三角形的集合。选择三角形作为基本图元有以下几个关键优势：
1.  **最简多边形**: 三角形是构成多边形的最基本单元。
2.  **必然共面**: 三角形的三个顶点必然定义一个唯一的平面。
3.  **凸多边形**: 三角形一定是凸多边形，这极大地简化了内外判断等计算。
4.  **易于插值**: 三角形内部任意点的属性（如颜色、法线、纹理坐标）都可以通过其顶点的属性进行线性插值（通过重心坐标）。
5.  **表示简洁**: 仅需存储三个顶点即可完整描述一个三角形。

因此，光栅化的核心问题可以简化为：如何高效地判断哪些像素中心点落在一个三角形内部。

## 三角形的光栅化

在完成视口变换后，三角形的顶点就拥有了屏幕坐标。下一步是确定这个三角形覆盖了哪些像素。这个过程本质上是一种**采样** (*Sampling*)。

最直观的方法是遍历屏幕上的每个像素，判断其中心点是否位于三角形内部。

> [!note] 判断点在三角形内部
> 由于三角形是凸多边形，我们可以利用**叉乘**的性质来判断一个点是否在其内部。对于三角形 ▲ABC 和任意点 P：
> 1.  计算向量 $\overrightarrow{AB}$ 与 $\overrightarrow{AP}$ 的叉乘。
> 2.  计算向量 $\overrightarrow{BC}$ 与 $\overrightarrow{BP}$ 的叉乘。
> 3.  计算向量 $\overrightarrow{CA}$ 与 $\overrightarrow{CP}$ 的叉乘。
>
> 如果这三个叉乘结果的 Z 分量符号相同（都为正或都为负，具体取决于顶点顺序），则点 P 位于三角形内部。这等价于判断点 P 是否始终位于三条边的“同一侧”。
>
> $$ \text{sign}(\overrightarrow{AB} \times \overrightarrow{AP}) = \text{sign}(\overrightarrow{BC} \times \overrightarrow{BP}) = \text{sign}(\overrightarrow{CA} \times \overrightarrow{CP}) $$

一个朴素的实现如下：

```rust
// 遍历屏幕上每一个像素
for x in 0..width {
	for y in 0..height {
		// 判断像素中心 (x + 0.5, y + 0.5) 是否在三角形内
		if (inside_triangle(tri, x + 0.5, y + 0.5)) {
			// 如果在，则该像素被三角形覆盖
			paint_pixel(x, y, tri_color);
		}
	}
}
```

> [!note] 边界问题 (Edge Cases)
> 如果一个像素中心恰好落在两个三角形共享的边上，我们需要一个一致的规则来决定它属于哪个三角形，以避免一个像素被绘制两次或被遗漏。图形 API（如 OpenGL 和 DirectX）通常有明确的“填充规则”来处理这种情况。

> [!tip] 性能优化
> 遍历整个屏幕的效率极低。实际应用中会采用更高效的算法：
> 1.  **包围盒 (Bounding Box)**: 只需遍历该三角形的最小包围盒内的像素，可以极大减少不必要的判断。
> 2.  **扫描线算法 (Scanline Algorithm)**: 逐行扫描，计算每条扫描线与三角形的交点，然后填充两个交点之间的像素。

## 抗锯齿

用离散的像素点来表示连续的几何边缘，必然会产生信号失真，这种现象称为**走样** (*Aliasing*)。在视觉上，走样表现为图形边缘的**锯齿** (*Jaggies*)、微小物体在移动时闪烁（摩尔纹）等问题。 **抗锯齿** (*Anti-Aliasing*, AA) 或称**反走样**，是一系列用于减轻或消除走样现象的技术。

要从根本上理解走样，需要引入信号处理的视角^[也可以参考 [[计算机视觉/图像滤波|图像滤波]]]。我们可以将屏幕上连续的图像看作一个二维信号。而光栅化过程中的像素采样，就是以固定的频率对这个连续信号进行采样。根据**傅里叶分析** (*Fourier Analysis*)，任何信号都可以分解为不同频率正弦波的叠加。傅里叶变换可以将信号从**时域/空域** (*Spatial Domain*) 转换到**频域** (*Frequency Domain*)。

$$
F(\omega) = \int_{-\infty}^{\infty} f(x)e^{-2\pi i\omega x} \, \text{d}x
$$

对于二维图像，其离散傅里叶变换 (DFT) 为：
$$
F(u,v) = \sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)\cdot e^{-2\pi i(ux/M + vy/N)}
$$
根据**奈奎斯特采样定理** (*Nyquist Sampling Theorem*)^[可以看看计算机网络的视角 [[计算机网络/物理层#^1c59e2|奈奎斯特采样定理]]]，如果采样频率低于信号最高频率的两倍，采样后的信号将无法完整还原出原始信号，高频信息会“混叠”到低频部分，导致失真，这就是走样。

![[image/光栅化.png|上图直观展示了采样频率过低导致无法还原原始信号]]

> [!example] 图像的频率分解
> 我们可以通过傅里叶变换来直观理解图像的频率构成。^[图谱中的两条线是由于我们将图像视为周期性的，将图像拼接在一起来模拟周期性，这导致在两个图像的连接处发生了很大的变化]
> ![[image/光栅化-1.png|左图是原图，右图是其频谱图。中心区域是低频信息（图像的平滑部分），外围是高频信息（图像的边缘和细节）。]]
>
> - **高通滤波 (High-pass Filter)**: 只保留高频信息，图像只剩下边缘和噪声。^[我们可以通过 [[计算机视觉/边缘检测#边缘检测|边缘检测]] 来获取图像的边缘信息，这其实是一种高通滤波]
> ![[image/光栅化-2.png]]
> - **低通滤波 (Low-pass Filter)**: 只保留低频信息，图像边缘被模糊，细节丢失。^[典型的低通滤波器是 [[计算机视觉/图像滤波#分离卷积|高斯滤波器]]。]
> ![[image/光栅化-3.png]]

**卷积定理** (*Convolution Theorem*) 指出：两个函数在时域/空域的卷积等价于它们在频域的乘积。利用这一定理可以发现，对信号进行采样，等价于在频域上将原始信号的频谱进行无限复制。

![[image/光栅化-5.png|800]]

如果采样率不足，复制的频谱就会发生重叠，如下图所示，从而导致走样。

![[image/光栅化-6.png|800]]

抗锯齿的本质思路是：**在采样前，先进行低通滤波，移除会导致走样的高频信息。** 通俗地讲，就是**先模糊，再采样**。

![[image/光栅化-8.png]]

> [!warning] 为什么不能先采样再模糊？
> 如果先采样，走样已经发生（频域上的频谱已经重叠）。此时再进行模糊（低通滤波），虽然能让图像变模糊，但无法消除已经混叠在一起的错误频率信息，锯齿依然存在，只是变得模糊了。

## MSAA

**多重采样抗锯齿** (*Multisample Anti-Aliasing*, MSAA) 是一种高效且经典的抗锯齿技术。它通过在单个像素内部署多个采样点（子样本）来实现。

MSAA 的工作流程如下：
1.  对于每个像素，在内部设置多个子采样位置（例如 2x, 4x, 8x）。
2.  对每个子样本，都进行独立的**深度测试 (Z-Test)** 和**模板测试 (Stencil-Test)**，以判断该子样本是否被三角形覆盖。
3.  **但是，昂贵的着色计算（Fragment Shader）只对每个像素执行一次。**
4.  最终像素的颜色，是根据其内部被三角形覆盖的子样本数量，将像素颜色与背景色进行混合加权得到的。例如，如果 4 个子样本中有 2 个被三角形覆盖，则最终颜色为 `50% * 三角形颜色 + 50% * 背景色`。

> [!note] 性能与权衡
> MSAA 的核心优势在于，它只增加了光栅化阶段的覆盖率和深度测试的计算量（与子样本数成正比），而没有成倍增加着色器的计算量。这使得它比简单的**超级采样抗锯齿** (*Super-Sampling Anti-Aliasing*, SSAA) 高效得多。
>
> 例如，4x MSAA 意味着每个像素有 4 个子样本，深度测试的开销大约是原来的 4 倍，但片元着色器的计算量基本不变。而 4x SSAA 则需要对 4 个虚拟的“子像素”都完整地执行一次着色，计算量是原来的 4 倍。

> [!tip] 其他抗锯齿方法
> 1.  **FXAA (Fast Approximate AA)**: 快速近似抗锯齿。一种后处理技术，它分析渲染完成的图像，寻找并平滑其中的锯齿边缘。速度快，但效果有时不如 MSAA 精确。
> 2.  **TAA (Temporal AA)**: 时间性抗锯齿。利用前面几帧的信息来平滑当前帧，通过抖动采样位置在时间维度上累积更多的采样信息，在静态画面下效果极佳，但可能在物体快速移动时产生鬼影。

## 深度缓冲 (Depth Buffering)

当场景中存在多个物体时，它们可能会在屏幕上发生重叠。我们需要一种机制来决定哪个物体应该显示在前面。**深度缓冲** (*Depth Buffer*) 算法（也称 **Z-Buffer**）是解决这个**可见性问题** (*Visibility Problem*) 的标准方法。

该算法维护一个与帧缓冲同样大小的二维数组，称为**深度缓冲区**。其中每个元素记录了对应像素位置上，当前离摄像机最近的物体的深度值。

算法流程如下：
1.  在开始渲染一帧前，用一个“无限远”的值来初始化深度缓冲区中所有的深度值。
2.  对于光栅化产生的每一个片元 `(x, y)`，读取其深度值 `z`。
3.  将片元的深度值 `z` 与深度缓冲区中 `(x, y)` 位置存储的深度值 `z_buffer[x][y]` 进行比较。
4.  **如果 `z < z_buffer[x][y]`** (假设 Z 值越小代表离摄像机越近)，说明该片元比之前记录的任何片元都更靠前。
5.  此时，更新帧缓冲中 `(x, y)` 的颜色为该片元的颜色，并同时更新深度缓冲区 `z_buffer[x][y] = z`。

```rust
struct Point(f16, f16, f16);

struct Triangle {
	vertices: [Point; 3],
	color: (u16, u16, u16),
}

for triangle in all_triangles {
	for Point(x, y, z) in tasterize(triangle.vec) {
		if z > z_buffer[x][y] {
			frame_buffer[x][y] = triangle.color;
			z_buffer[x][y] = z;
		}
	}
}
```

> [!note] 并行处理与 Z-Fighting
> - Z-Buffer 算法的一大优点是它与绘制顺序无关，因此非常适合在 GPU 上进行大规模并行处理。
> - **深度冲突 (Z-Fighting)**: 由于深度缓冲区精度有限，当两个物体的表面非常接近时，它们的深度值可能经过计算后变得无法区分，导致在渲染时这些表面交错闪烁。这是 Z-Buffer 算法的一个常见问题。

---

< [[计算机图形学/变换|变换]] | [[计算机图形学/着色|着色]] >
