---
tags:
  - 编译原理
---

# 中间代码生成

在将给定源语言的一个程序翻译为特定的目标机器代码的过程中，一个编译器可能构造出一系列中间表示。高层的表示接近与源语言，而底层的表示接近与目标机器。语法树是高层的表示，它刻画了源程序的自然的层次性结构，并且适用于静态类型检查这样的处理。

不同的编译器对中间表示的选择和设计各有不同，中间表示可以是一种真正的语言，也可以由编译器的各个处理阶段共享的多个内部数据结构组成。

## 语法树的变体

语法树中的各个节点代表了源程序中的构造，一个节点的所有子节点反映了该节点对应构造的有意义的组成成分。为表达式构造无环有向图 (Directed Acyclic Graph，以后简称 DAG) 指出了表达式中的公共子表达式。

## 三地址代码

在三地址代码中，一条指令的右侧最多有一个运算符。也就是说，不允许出现组合的算术表达式。因此，如 $x+y*z$ 这样的表达式会被拆分为：
$$
\begin{aligned}
t_1&=y*z\\t_2&=x+t_1
\end{aligned}
$$
由于三地址代码拆分了多运算符算术表达式以及控制流语句的嵌套结构，所以适用于目标代码的生成和优化。

### 地址和指令

三地址代码基于两个概念：地址和指令。

地址可以具有如下性质：
- 名字：为了方便起见，我们允许源程序的名字作为三地址代码中的地址。在实现中，源程序中的名字被替换为指向符号表条目的指针。关于该名字的所有信息均被存放在该条目中。
- 常量：在实践中，编译器常会处理很多不同类型的常量和变量。
- 编译器生成的临时变量：在每次需要临时变量时产生一个新名字是必要的。这在优化编译器时更加重要。

下面给出几种常见的三地址指令形式：
1. 形如 `x = y op z` 的赋值指令，其中 op 是一个双目运算符或者逻辑运算符。x y z 是地址。
2. 形如 `x = op y` 的赋值指令，其中 op 是一个单目运算符。
3. 形如 `x = y` 的复制指令。
4. 无条件转移指令 `goto L`，下一步要执行的指令是带有标号 L 的三地址指令。
5. 形如 `if X goto L` 或者 `if False X goto L` 的条件转移指令。
6. 形如 `if X relop y goto L` 的条件转移指令。
7. 过程调用和返回通过下列指令来实现：
	1. `param x` 进行参数传递。
	2. `call p, n` 和 `y = call p, n` 分别进行过程调用和函数调用，n 表示参数数量，用于区分嵌套调用函数时的参数。
	3. `return y` 是返回指令，其中 y 表示返回值
8. 带下标的复制指令 `x = y[i]` 和 `x[i] = y`。
9. 形如 `x = &y`、`x = *y` 或者 `*x=y` 的指针赋值命令。

### 四元式表示

上面对三地址指令的描述信息说明了各类指令的组成部分，但是没有描述这些指令在某个数据结构中的表示方式。在编译器中，这些指令可以实现为对象、或者带有运算符字段和分量字段的记录。

四元式、三元式和间接三元式是三种这样的描述方式。

一个四元式 (quadruple) 有四个字段，分别为 `op`, `arg1`, `arg2`, `result`。字段 `op` 包含了一个运算符的内部编码，例如三地址指令 $x=y+z$ 相应的四元式中，`op` 中存放 `+`，`arg1` 存放 `y`，`arg2` 存放 `z`，`result` 存放 `x`。下面是这个规则的一些特例：
1. 单目运算符和复制指令不使用 `arg2`。
2. 像 `param` 这样的运算既不使用 `arg2`，也不使用 `result`。
3. 条件或非条件转移指令将目标标号放入 result 字段。

### 三元式表示

一个三元式 (triple) 只有三个字段，分别为 `op`, `arg1`, `arg2`。使用三元式时，我们将用运算 `x op y` 的位置来表示他们的结果，而不是用一个显示的临时名字表示。

间接三元式 (indirect triple) 包含了一个指向三元式的指针的列表，而不是列出三元式序列本身。

### 静态单赋值形式

静态单赋值形式 (SSA) 是另一种中间表示形式，它有利于实现某些类型的代码优化。SSA 和三地址代码的区别主要体现在：
1. SSA 中的所有赋值都是针对于具有不同名字的变量
2. SSA 使用一种被称为 $\varphi$ 函数的表示规则将 x 的两处定义合并起来。

## 类型的声明

## 表达式的翻译

在本节中，考虑从表达式到三地址代码的翻译。一个带有多个运算符的表达式将被翻译为最多包含一个运算符的指令序列。

### 表达式中的运算

