---
tags:
  - 设计模式
  - 创建型模式
aliases:
  - Abstract Factory
---

# 抽象工厂

> [!definition|Definition] 抽象工厂
> 提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。

![[Assets/抽象工厂.png]]

## 核心思想

抽象工厂模式是 [[00_Inbox/设计模式/工厂方法|工厂方法模式]] 的进一步扩展，允许创建**同一产品族**中的所有对象，而无需暴露其具体实现。它通过一组工厂方法，统一生成属于同一系列的多个产品。

## 结构

抽象工厂模式通常包含以下四个核心角色：

1. **抽象产品（Abstract Product）**
    - 声明系列中各个产品的通用接口。
    - 每个产品维度（如按钮、复选框）对应一个抽象产品接口。
2. **具体产品（Concrete Product）**
    - 实现抽象产品接口，定义具体的产品行为。
    - 同一系列中的产品实现风格一致，但彼此功能独立。
3. **抽象工厂（Abstract Factory）**
    - 声明一组创建抽象产品的方法。
    - 每个方法对应一个产品维度。
4. **具体工厂（Concrete Factory）**
    - 实现抽象工厂接口，生成特定系列的产品实例。
    - 每个具体工厂对应一个特定产品族，只负责创建该系列中的产品。

> [!note]
> 尽管具体工厂会创建特定产品，但其返回类型必须是抽象产品接口。这样可以保证客户端代码仅依赖于抽象接口，与具体产品和工厂解耦，从而便于扩展与替换。

## 使用场景

- ✅ 当系统需要独立于产品的创建过程与使用过程。
- ✅ 当系统需要与多个系列的产品对象协同工作，但不希望依赖其具体类时。
- ✅ 当希望通过配置或运行环境灵活切换产品族时（如跨平台 GUI）。

## 实现步骤

1. 绘制产品族矩阵：列表示产品维度（按钮、复选框），行为表示不同系列（Windows、Mac 等）。
2. 为每种产品维度定义抽象接口，声明其核心功能。
3. 实现每个系列下的具体产品，实现对应的接口。
4. 定义抽象工厂接口，包含创建所有产品的方法。
5. 为每个产品系列实现一个具体工厂，生成该系列下的所有具体产品。
6. 在应用程序中，根据配置或平台选择合适的具体工厂，并通过该工厂创建产品。

## 伪代码

![[Assets/抽象工厂-1.png|跨平台 UI]]

```rust
trait GUIFactory:
	type B: Button
	type C: CheckBox
	
	fn createButton() -> Self::B
	fn createCheckBox() -> Self::C

impl GUIFactory for WinFactory:
	type B = WinButton
	type C = WinCheckBox
	fn createButton() -> Self::B:
		WinButton::new()
	fn createCheckBox() -> Self::C:
		WinCheckBox::new()

impl GUIFactory for MacFactory:
	type B = MacButton
	type C = MacCheckBox
	fn createButton() -> Self::B:
		MacButton::new()
	fn createCheckBox() -> Self::C:
		MacCheckBox::new()

trait Button:
	fn paint(&self)

trait CheckBox:
	fn paint(&self)

impl Button for WinButton:
	fn paint(&self)               // 调用 Windows API 绘制按钮

impl Button for MacButton:
	fn paint(&self)               // 调用 macOS API 绘制按钮

impl CheckBox for WinCheckBox:
	fn paint(&self)               // 调用 Windows API 绘制复选框

impl CheckBox for MacCheckBox:
	fn paint(&self)               // 调用 macOS API 绘制复选框

fn main() {
	let factory = if cfg!(windows) {
		WinFactory::new()
	} else if cfg!(macos) {
		MacFactory::new()
	} else {
		panic!("Unknown system!");
	}

	let button = factory.createButton();
	let check_box = factory.createCheckBox();
}
```

## ✔️ 优点

- **保证产品一致性**
    - 同一工厂创建的产品天然属于同一系列，具有一致的风格与兼容性。
- **解耦客户端与具体产品**
    - 客户端只依赖于抽象接口，不关心具体类名与创建逻辑。
- [[00_Inbox/设计模式/软件设计原则#单一职责原则|单一职责原则]]
    - 产品创建逻辑集中在工厂类中，职责清晰，易于维护。
- [[00_Inbox/设计模式/软件设计原则#开闭原则|开闭原则]]
    - 新增产品系列时，只需添加新的具体产品和具体工厂类，无需修改现有客户端逻辑。

## ✖️ 缺点

- **类数量增加**
    - 每新增一种产品或产品族，都需要添加多个类（抽象产品、具体产品、具体工厂），会增加系统复杂度。
- **难以支持新产品维度**
    - 若要为产品族添加新产品（如“滑块”），必须修改所有工厂接口及其实现类，违背开闭原则。

## 实现

> [!example]- Rust 实现：跨平台 GUI 的抽象工厂模式
>
> ```rust
> pub mod mac_gui;
> pub mod win_gui;
> 
> pub trait Button {
>     fn paint(&self);
> }
> 
> pub trait CheckBox {
>     fn paint(&self);
>     fn check(&mut self);
> }
> 
> pub trait GUIFactory {
>     type B: Button;
>     type C: CheckBox;
> 
>     fn create_button(&self) -> Self::B;
>     fn create_check_box(&self) -> Self::C;
> }
> ```
>
> ```rust
> use crate::*;
> 
> pub struct MacButton {
>     title: String,
> }
> 
> pub struct MacCheckBox {
>     id: usize,
>     is_check: bool,
> }
> 
> pub struct MacGUIFactory;
> 
> impl MacButton {
>     pub fn new(title: String) -> Self {
>         Self { title }
>     }
> }
> 
> impl Button for MacButton {
>     fn paint(&self) {
>         println!("Button: {}", self.title);
>     }
> }
> 
> impl MacCheckBox {
>     pub fn new(id: usize) -> Self {
>         Self {
>             id,
>             is_check: false,
>         }
>     }
> }
> 
> impl CheckBox for MacCheckBox {
>     fn paint(&self) {
>         println!("CheckBox: id={}", self.id);
>     }
>     fn check(&mut self) {
>         self.is_check = true;
>     }
> }
> 
> impl GUIFactory for MacGUIFactory {
>     type B = MacButton;
>     type C = MacCheckBox;
> 
>     fn create_button(&self) -> Self::B {
>         MacButton::new("MacButton".into())
>     }
> 
>     fn create_check_box(&self) -> Self::C {
>         MacCheckBox::new(1)
>     }
> }
> ```
>
> ```rust
> use crate::*;
> 
> pub struct WinButton {
>     title: String,
> }
> 
> pub struct WinCheckBox {
>     id: usize,
>     is_check: bool,
> }
> 
> pub struct WinGUIFactory;
> 
> impl WinButton {
>     pub fn new(title: String) -> Self {
>         Self { title }
>     }
> }
> 
> impl Button for WinButton {
>     fn paint(&self) {
>         println!("Button: {}", self.title);
>     }
> }
> 
> impl WinCheckBox {
>     pub fn new(id: usize) -> Self {
>         Self {
>             id,
>             is_check: false,
>         }
>     }
> }
> 
> impl CheckBox for WinCheckBox {
>     fn paint(&self) {
>         println!("CheckBox: id={}", self.id);
>     }
>     fn check(&mut self) {
>         self.is_check = true;
>     }
> }
> 
> impl GUIFactory for WinGUIFactory {
>     type B = WinButton;
>     type C = WinCheckBox;
> 
>     fn create_button(&self) -> Self::B {
>         WinButton::new("WindowsButton".into())
>     }
> 
>     fn create_check_box(&self) -> Self::C {
>         WinCheckBox::new(0)
>     }
> }
> ```
>
> ```rust
> use static_dispatch::{
>     Button, CheckBox, GUIFactory, mac_gui::MacGUIFactory, win_gui::WinGUIFactory,
> };
> 
> fn render(factory: impl GUIFactory) {
>     let button = factory.create_button();
>     button.paint();
> 
>     let check_box = factory.create_check_box();
>     check_box.paint();
> }
> 
> fn main() {
>     if cfg!(windows) {
>         render(WinGUIFactory);
>     } else {
>         render(MacGUIFactory);
>     };
> }
> ```

---

< [[00_Inbox/设计模式/工厂方法|工厂方法]] |
