---
tags:
  - 数据库
---

# 数据库并发控制

多事务执行方式 :
1. **串行执行**：每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后才能运行，不能充分利用系统资源和数据库资源。
2. **交叉并发方式**：并行事务的并操作轮流交叉运行，是单处理机系统中的并发方式，能够减少处理机的空闲时间，提高系统的效率。
3. **同时并发方式**：多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务。

## 并发事务

> [!info] 原子性、一致性、隔离性、持续性，简称事务的 [[00_Inbox/数据库/数据库恢复技术#事务的特征|ACID 特性]]。

事务并发执行可能会存取不正确的数据，破坏事务的**隔离性**和数据库的**一致性**，带来以下数据不一致性：
1. 丢失更新
2. 不可重复读
3. 读“脏”数据

这种数据库的不一致性是由并发操作引起的，主要原因是并发操作破坏了事务的隔离性。并发控制机制要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，避免造成数据的不一致性。

### 丢失更新

事务 1 和事务 2 从数据库中读入同一数据并修改，导致事务 2 的提交破坏了事务 1 提交的结果，丢失事务 1 的修改被丢失。

![[Assets/数据库并发控制-1.png|300]]

### 不可重复读

T1 读取数据后，T2 对同一数据执行更新操作，使 T1 再次读取该数据时，得到与前一次不同的值。

![[Assets/数据库并发控制-2.png|300]]

> [!note] 三类不可重复读
> T1 读取某一数据后：
> 1. T2 对其做了修改，当 T1 再次读取该数据时，得到与前一次不同的值。
> 2. T2 删除了其中部分记录，当 T1 再次读取数据时，某些记录消失。
> 3. T2 插入了一些记录，当 T1 再次按相同条件度数据时，多了一些记录。
>
>  后两种不可重复读有时也叫*幻影现象*。

### 读脏数据

- T1 修改某一数据，并将其写回磁盘。
- T2 读取同一数据后，T1 由于某种原因被撤消，这时 T1 已修改过的数据恢复原值。
- T2 读到的数据就与原数据库中的数据不一致，是不正确的数据，又称为脏数据。

![[Assets/数据库并发控制-3.png|300]]

## 封锁及封锁协议

### 封锁

封锁是实现并发控制的一个非常重要的技术，其概念大致如下：
- 事务 T 在对某个数据对象操作之前，先向系统发出请求，对其加锁。
- 加锁后，事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他的事务不能更新此数据对象。

> [!note] 一个事务对某个数据对象加锁后究竟拥有了什么样的控制由封锁的类型决定。
> 1. **共享锁**（Share lock，简记为 **S 锁**，又称**读锁**）
>    - 若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读取数据 A，不能写数据 A
>    - 其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。
> 2. **排他锁**（eXclusive lock，简记为 **X 锁**，又称**写锁**）
>    - 若事务 T 对数据对象 A 加上 X 锁，则事务 T 可以读取和修改数据 A。
>    - 其他事务都不能在对 A 加任何类型的锁，直到 T 释放 A 上的 X 锁。

> [!note] 锁的相容矩阵
> ![[Assets/数据库并发控制-4.png|300]]
> - 列表示事务 T1 已经获得的数据对象上的锁的类型。
> - 行表示事务 T2 对同数据对象发出的封锁请求。
> - Y 表示相容请求，N 表示不相容请求。

### 封锁协议

> [!note] 封锁协议
> 运用封锁方法时，对数据对象加锁时需要约定一些规则。
> - 何时申请封锁
> - 封锁时间
> - 何时释放封锁等

1. **一级封锁协议**：事务 T 在修改数据 A 前必须先对其加 X 锁，直到事务结束才释放。
	- 一级封锁协议在读数据时不加锁，所以不能保证可重复度和不读“脏”数据。
2. **二级封锁协议**： 在一级封锁协议基础上，事务 T 在读数据 A 之前必须先对其加 S 锁，读完后即可释放 S 锁。
	- 增加二级封锁协议的目的是防止读“脏”数据，但是不能保证避免不可重复读的问题。因为事务 T 在读数据 A 之前加上的 S 锁，读完后就释放了，以后再读时有可能数据发生了变化。
3. **三级封锁协议**：在二级封锁协议基础上，某一事务施加的 S 锁要保持到该事务结束才能释放。
	- 增加三级封锁协议的目的是避免不可重复读。

### 活锁和死锁

封锁技术可以有效的解决并行操作的一致性问题，但也带来一些新的问题：
- **活锁**：指某个事务由于请求封锁，但总也得不到锁而长时间处于等待状态^[这在操作系统中称为饥饿现象]。
- **死锁**：指在同时处于等待状态的两个或多个事务中相互封锁了对方请求的资源，使得没有任何一个事务可以获得足够的资源运行完毕，而永远等待下去^[[[02_Areas/操作系统/进程管理#死锁]]]。

> [!note] 避免活锁的方法
> 先来先服务策略 (FCFS)：
> - 当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队。
> - 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

解决死锁的思路：
- 预防死锁
- 允许死锁的发生，其进行死锁的诊断与解除

#### 死锁的预防

产生死锁是由于两个或者多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，出现循环等待。预防死锁的发生就是要破坏产生死锁的条件。

> [!note] 预防死锁的方法
> - **一次封锁法**：相当于操作系统中的，破坏请求和保持条件。
> - **顺序封锁法**：相当于操作系统中的，破坏了循环等待条件。

##### 一次封锁法

将事务在执行过程中可能要封锁的数据对象全部加锁^[[[操作系统/进程管理#破环请求和保持条件]]。

> [!note] 存在的问题
> - 将以后用到的全部数据加锁，势必扩大了封锁的范围，从而降低了系统的并发度
> - 数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能变成封锁对象，所以很难是事先精确地确定每个事务所要封锁的数据对象。

##### 顺序封锁法

预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实行封锁^[[[02_Areas/操作系统/进程管理#破环循环等待条件]]]。

> [!note] 存在的问题
> - 数据库系统中可封锁的数据对象极其众多，并且随数据的插入、删除等操作而不断地变化，要维护这样极多而且变化的资源的封锁顺序非常困难，成本很高，**维护成本高**。
> - 事务的封锁请求可以随着事务的执行而动态地决定,很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁，**难于实现**。

#### 死锁的检测与恢复

由 DBMS 的并发控制子系统定期检测系统中是否存在死锁，一旦检测到死锁，就要设法接触死锁。
- 选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务能继续运行下去。
- 与 [[02_Areas/操作系统/进程管理#死锁的检查和解除]] 同理。

##### 超时法

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

> [!note] 特点
> - 优点：实现简单。
> - 缺点：若实现设置得太短，有可能误判。若时限设置得太长，死锁发生后不能及时发现。

##### 等待图法

用等待图动态反映所有事务的等待情况。等待图是一个有向图 $G=(V, U)$
- $V$ 为结点的集合，每个结点表示正在运行的事务。
- $U$ 为边的集合，每条边表示事务等待的情况。
- 若 $V1$ 等待 $V2$，则在它们之间画一条有向边，从 $V1$ 指向 $V2$。
- 并发控制子系统周期性地（比如每个 1 min）检测等待图，如果发现途中存在回路，则表示系统中出现了死锁。

## 并发调度的可串行性

计算机系统对并行事务中并行操作的调度是随机的，而不同的调度可能会产生不同的结果^[[[02_Areas/操作系统/操作系统基本原理概论#异步|异步性]]]。我们认为，将所有事务串行起来的调度策略是正确的调度。

> [!definition|Definition] 可串行化调度
> 多个事务的并发执行是正确的，当且仅当并发执行的结果与这些事务按照某一串行顺序执行的结果相同，这种调度策略被称为可串行化调度。

> [!note] 可串行化是并发事务正确调度的准则，可串行性是并行事务正确性的唯一准则。
> 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

### 冲突可串行化调度

> [!definition|冲突] 指不同的事务对同一数据的读写操作和写写操作，其他操作是不冲突操作。

> [!note] 冲突的性质
> - 不同事务的冲突操作不能交换。
> - 同一事务的两个操作不能交换。

> [!definition|Definition] 冲突可串行化
> 如果一个调度 S 在保证冲突操作次序不变的情况下，能通过交换两个事务非冲突操作的顺序得到另一个调度 S'，则称调度 S 和 S' **冲突等价**。如果调度 S' 是串行的，称调度 S 为**冲突可串行化调度**。

> [!note]
> 冲突可串行化是可串行化的充分条件。**如果一个调度是冲突可串行化的，则一定是可串行化的调度。**

## 两段锁协议

两段锁协议 (Two-Phase Locking，简称 2PL) 是最常用的一种封锁协议。在两段锁协议中，所有事务必须分两个阶段对数据项加锁和解锁：
1. 在对任何数据进行读、写操作之前，事务必须要获得对该数据的封锁。
2. 在释放一个封锁之后，事务不再获得任何其他封锁。

> [!note] 两段锁协议是保证并发调度是可串行的封锁协议。

在两段锁协议中，事务分为两个阶段：
1. 第一阶段是获得封锁，也称为扩展阶段
   - 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。
2. 第二阶段是释放封锁，也称为收缩阶段。
   - 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。

> [!note]
> 事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。可串行化的调度中，不一定所有事务都符合两段锁协议。

> [!note] 两段锁协议与防止死锁的一次封锁法的关系
> - 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议。
> - 两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务**可能发生死锁**。

## 多粒度封锁

在前面的封锁协议中，都是以所操作的数据项作为封锁单元。但实际上，根据需要可以封锁较大或较小的数据单元。封锁的对象的大小称为封锁的**粒度**。
- 在关系数据库中，封锁的单元可以是
	- 逻辑单元：属性列、元组、表和数据库。
	- 物理单元：数据页、索引页、数据库存储空间等。

|    属性    |     |     |
| :------: | :-: | :-: |
|  封锁的粒度   |  大  |  小  |
| 系统被封锁的对象 |  少  |  多  |
|   需要的锁   |  少  |  多  |
|   系统开销   |  小  |  大  |
|   并发度    |  低  |  高  |

选择封锁粒度要对系统开销与并发度进行权衡。
- 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位。
- 需要处理大量元组的用户事务：以关系为封锁单位。
- 只处理少量元组的用户事务：以元组为封锁单位。

多粒度封锁机制中允许事务选择各种大小的粒度作为封锁单元，不同封锁粒度可以使用多粒度树表示。
- 以树型结构来表示多级封锁粒度。
- 根节点是整个数据库，表示最大的数据粒度。
- 叶节点表示最小的数据粒度。

### 多粒度封锁协议

- 允许多粒度树中的每个结点被独立地加锁。
- 对一个结点加锁意味着这个结点的**所有后裔结点**也被加以同样类型的锁。
- 在多粒度封锁中一个数据对象可能以两种方式封锁，封锁效果是一样的。
	- 显式封锁：直接加到数据对象上的封锁。
	- 隐式封锁：由于其上级结点加锁而使该数据对象加上了锁。

系统检查封锁冲突时，不仅要检查显式封锁，还要检查隐式封锁。对某个数据对象加锁时系统检查的内容：
- 该数据对象有无显式封锁与之冲突。
- 所有上级结点检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突，即检查是否有上级结点的封锁。
- 所有下级结点检查本事务的隐式封锁是否与该数据对象上的显式封锁冲突，即将所有下级节点封锁。

### 意向锁

如果对一个结点加**意向锁**，则说明该节点的下层结点正在被加锁。对任意结点加锁时，必须先对其上层节点加意向锁。
- **意向共享锁** (Intent Share Lock，简称 **IS 锁**)
	- 如果对一个数据对象加 IS 锁，表示它的后裔结点拟 (意向) 加 S 锁。例: 要对某个元组加 S 锁，则要先对关系和数据库加 IS 锁
- **意向排它锁** (Intent Exclusive Lock，简称 **IX 锁**)
	- 如果对一个数据对象加 IX 锁，表示它的后裔结点拟 (意向) 加 X 锁。例: 要对某个元组加 X 锁，先要对关系和数据库加 IX 锁
- **共享意向排它锁** (Share Intent Exclusive Lock，简称 **SIX 锁**)
	- 如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 SIX = S + IX。例：对某个表加 SIX 锁，则表示该事务要读整个表（所以要对该表加 S 锁），还会更新个别元组（所以要对该表加 IX 锁）

具有意向锁的多粒度封锁方法要求：
- 申请封锁时应该按自上而下的次序进行。
- 释放封锁时应该按自下而上的次序进行。

> [!note] 引入意向锁的目的
> 提高对某个数据对象加锁时系统的检查效率。

> [!example] 意向锁的相容矩阵
> ![[Assets/数据库并发控制-5.png]]

> [!tip]- 锁的强度的偏序关系
> ![[Assets/数据库并发控制-6.png]]
> - 锁的强度是指它对其他锁的排斥程度
> - 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

> [!note] 多粒度封锁的优点
> - 提高了系统的并发度。
> - 减少了加锁和解锁的开销。
> - 在实际的数据库管理系统产品中得到广泛应用。

---
< [[00_Inbox/数据库/数据库恢复技术|数据库恢复技术]] | [[00_Inbox/数据库/关系数据库设计理论|关系数据库设计理论]] >
