---
tags:
  - 数据库
---

# 数据库完整性

数据库的完整性指数据的正确性和相容性，防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。

> [!tip] 对比 [[00_Inbox/数据库/数据库的安全性|数据库的安全性]]
> - 数据库的完整性主要防范对象：不合语义的、不正确的数据。
> - 数据库的安全性主要防范对象：非法用户和非法操作。

数据库的完整性是一种语义概念，防止数据库中存在不合语义的、不正确的数据，以保证数据库中数据的质量。为了保证数据库的完整性，DBMS 必须提供：
- 提供定义完整性约束条件的机制
- 提供完整性检查的方法
- 违约处理

> [!note|noIndent] 完整性约束条件
> 完整性约束条件是加在数据上的语义约束条件，它一般是对数据库中数据本身的某种语义限制、数据间的逻辑约束和数据变化时所遵循的规则等，表达了给定的 [[00_Inbox/数据库/数据模型|数据模型]] 中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态及状态的变化。
>
> 根据数据对象的的大小可以分为：
> 1. 列级约束：主要是对属性的数据类型、数据格式和取值范围、精度等的约束。
> 2. 元组约束：一个元组由若干属性组成，元组级约束就是元组中各个属性之间的约束关系。
> 3. 关系约束：关系约束是指一个关系的各个元组之间、或者多个元组之间存在的各种联系或约束。常见的关系约束有实体完整性约束、参照完整性约束、函数依赖约束、统计约束等。
>
> 根据数据对象的状态可以分为：
> 1. 静态约束：某个确定的状态时数据的约束条件。例如数据的取值范围、数据类型。
> 2. 动态约束：从一个状态到另一个状态时新旧值之间的约束条件。例如年龄的修改只能增加不能减小。

## 实体完整性

实体完整性规则规定：
- 主键的值不能取空值
- 主键的值唯一

在 [[00_Inbox/数据库/SQL|SQL]] 中我们可以通过 `CREATE TABLE` 与 `PRIMARY KEY` 来定义数据库的完整性约束：
- 单属性构成的主键可以通过定义为列级约束条件，定义为表级约束条件两种方法。
- 对多个属性类构成的主键可以通过定义为表级约束条件。

为了实现实体完整性，系统将自动在主键属性上创建唯一索引来强制唯一性约束。

> [!example]
> ```sql
> CREATE TABLE Student(
> 	Sno CHAR(9) PRIMARY KEY, /* 列级定义主键 */
> 	Sname CHAR(20) NOT NULL,
> 	Ssex CHAR(2)
> );
> 
> CREATE TABLE Student(
> 	Sno CHAR(9),
> 	Sname CHAR(20) NOT NULL,
> 	Ssex CHAR(2),
> 	PRIMARY KEY(Sno) /* 表级定义主键 */
> )
> 
> CREATE TABLE SC(
> 	Sno CHAR(9) NOT NULL,
> 	Cno CHAR(9) NOT NULL,
> 	Grade SMALLINT,
> 	PRIMARY KEY (Sno, Cno) /* 只能在表级定义上 */
> )
> ```

> [!note] 完整性检查与违约处理
> 定义表的主键后，每当对该表插入一条记录或者对主键进行更新操作时，DBMS 自动进行实体完整性的检查，即检查：
> - 主键是否唯一：如果不唯一，则拒绝操作。
> - 检查主键的各个属性值是否为空：如果有空值，则拒绝操作。

## 参照完整性

参照完整性规则规定：
- 外键的值要么为空，要么只能取被参照的对象的值

在 SQL 中，我们可以通过在 `CREATE TABLE` 中用 `FOREIGN KEY` 来定义列为外键，使用 `REFERENCES` 来指明外键参照的是哪些表的主键。

> [!example]
> ```sql
> CREATE TABLE SC(
> 	Sno CHAR(9) NOT NULL,
> 	Cno CHAR(4) NOT NULL,
> 	Grade SMALLINT,
> 	PRIMARY KEY (Sno, Cno),
> 	FOREIGN KEY (Sno) REFERENCES Student(Sno),
> 	FOREIGN KEY (Cno) REFERENCES Course(Cno)
> );
> ```

### 参照完整性检查

对被参照表中的主键操作：
- **插入**：要求插入值满足主键限制即可，不影响其它表
- **修改**：可能会影响与该主键相关的参照表的外键值。当相应的外键值存在时，策略有三：
	- 不允许修改被参照表中的主键值
	- 改变对应参照表的所有外键值，使之与主键一致
	- 对相应的外键值置空
- **删除**：可能会影响与该主键相关的参照表的外键值。若相应的外键值存在时，策略有三：
	- 不允许删除被参照表的主键值
	- 级联删除参照表中相应外键值所在的行
	- 对相应的外键值置空

对参照表中的外键操作：
- **插入**：要求插入的外键值应参照被参照表中的主键值或者置空
- **修改**：要求修改的外键值应参照被参照表中的主键值
- **删除**：不需要参照被参照表中的主键值，不影响其他表

### 参照完整性违约处理

数据库管理系统提供了不同的违约处理策略供用户选择：
- 拒绝操作（NO ACTION）执行，一般为默认策略
- 级联（CASCADE）操作
- 设置为空值（SEL NULL）操作，对于参照完整性，除了应该定义外键，还应定义外键列是否允许空值

当对参照表或被参照表的操作违反了参照完整性时，系统选择默认策略，即拒绝执行。如果想让系统采用其他策略，则必须要显示的加以说明。

在 SQL 中在 `CREATE TABLE` 中的外键后使用 `ON <操作> <违约处理操作>` 来显示定义指定操作的违约处理方式。

## 用户定义的完整性

用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求，由 RDBMS 提供，而不必由应用程序承担。
- 属性上的约束条件：UNIQUE、NOT NULL、CHECK 约束、DEFAULT 等。
- 元组上的约束条件：用 CHECK 短语定义元组上的约束条件，即元组级的限制

插入元组或者修改属性的值使，RDBMS 检查约束条件是否被满足，如果不满足则拒绝执行。

## 完整性约束命名子句

SQL 提供了完整性约束命名子句 CONSTRAINT，用来对完整性约束条件命名，从而可以灵活的增加或者删除一个完整性约束条件。

```mysql
CONSTRAINT <完整性约束条件名> <完整性约束条件>
```

其中完整性约束条件包括 `PRIMARY KEY`，`FOREIGN KEY`，`NOT ALL`，`UNIQUE`，CHECK 短语等。

> [!example]
> ```sql
> CREATE TABLE Student(
> 	Sno NUMERIC(5)
> 	CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999),
> 	Sname CHAR(20)
> 	CONSTRAINT C2 NOT NULL,
> 	Sage NUMERIC(3)
> 	CONSTRAINT C3 CHECK (Sage < 30),
> 	Ssex CHAR(2)
> 	CONSTRAINT C4 CHECK (Ssex IN ('男', '女')),
> 	CONSTRAIN StudentKey PRIMARY KEY(Sno)
> );
> /* 使用 ALTER TABLE 修改表中的完整性约束 */
> ALTER TABLE Student DROP CONSTRAINT C1;
> ALTER TABLE Student ADD CONSTRAINT C1 CEHCK (Sno BETWEEN 99000 AND 99999);
> ```

## 触发器

数据库系统一般提供两种主要机制来实现业务规则和数据完整性：
- **约束**：DBMS 提供定义完整性约束条件的机制，在检测出违反约束条件的操作后，进行相应的违约处理。
- **触发器**：用户定义在关系数据表上的一类有*事件驱动*的特殊过程，用编程的方法实现复杂的业务规则。
	- 触发器比约束更加灵活，可以实现一般的数据完整性约束实现不了的复杂的完整性约束，具有更加精细和更加强大的数据控制能力。
	- 触发器在对表发出 `UPDATE`，`INSERT`，`DELETE` 语句时自动执行，可用触发器完成很多数据库完整性保护功能。

> [!note] 触发器的优点
> - 实现复杂的业务规则
> - 实现比 CHECK 约束更复杂的数据完整性
> - 比较数据修改前后的状态
> - 维护非规范化数据

### 定义触发器

在 SQL 中使用 `CREATE TRIGGER` 命令创建触发器

```mysql
CREATE TRIGGER <触发器名>
	{BEFORE|AFTER} <触发事件> ON <表名>
	FOR EACH {ROW|STATEMENT}
	[WHEN <触发条件>]
	BEGIN
		<触发动作体>；
	END;
```

> [!note] 参数
> - **表名**：触发器的目标表。
> - **触发事件**：`INSERT`，`DELETE`，`UPDATE`，或者是这几个事件的组合，如 `INSERT OR DELETE` 或者 `UPDATE OF <列,...>` 等。
> - `BEFORE` 和 `AFTER` 表示在触发事件完成之前或之后判断是否满足条件并进行执行。
> - **触发器类型**：`FOR EACH {ROW|STATEMENT}` 分别表示行级触发器和语句级触发器：
> 	- 行级触发器：对每一个修改的元组都会触发触发器的检查和执行。
> 	- 语句级触发器：只在 SQL 语句执行时候进行触发条件的检查和触发器的执行，只触发一次。
> - 触发条件：触发条件为真，触发动作体才执行，如果省略则总是执行。
> - 触发动作体：
> 	- 触发动作体是满足触发条件后，执行的一系列数据库操作。
> 	- 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化

> [!example]
> 定义一个 `BEFORE` 行级触发器，为教师表 `teacher` 定义完整性规则：教授的工资不得低于 4000 元，如果低于 4000 元则自动改为 4000 元。
> ```sql
> CREATE TRIGGER insert_or_update_sal
> BEFORE INSERT OR UPDATE ON Teacher
> FOR EACH ROW
> BEGIN
> 	IF (:new.Job='教授') AND (:new.Sal < 4000) THEN
> 		:new.Sal := 4000;
> 	END IF;
> END
> ```

> [!note] 触发器特殊语法
> 1. 伪记录：在行级触发器中，可以使用 `:new` 表示即将插入或更新后的新行，`:old` 表示更新前的原行或删除的行。它们允许我们在触发器内部访问和修改这些数据。
> 2. 控制流语句：可以使用一些控制语句，例如 `IF`、`CASE`、`WHEN LOOP` 和 `FOR LOOP` 等。
> 3. 变量声明：可以在触发器内部声明变量，并使用 `:=` 进行赋值操作。
> 4. DML 操作：在触发器内部可以嵌套进行 DML 操作，但是要避免递归触发的问题。

> [!note]
>   触发器的执行是由触发事件激活的，并有数据库服务器自动执行。 如果在一张表上定义了多个触发器，则按照 BEFORE，SQL，AFTER 的顺序执行。

### 删除触发器

删除触发器的 SQL 语法：

```mysql
DROP TRIGGER <触发器名> ON <表名>；
```

其中触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。

---
< [[00_Inbox/数据库/数据库的安全性|数据库的安全性]] | [[00_Inbox/数据库/数据库恢复技术|数据库恢复技术]] >
