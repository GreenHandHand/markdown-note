---
tags:
  - 数据库
---

# 关系数据库

关系数据库是支持关系模型的数据库系统。

> [!note] 关系模型的组成
> [[00-笔记/数据库/数据模型|数据模型]] 通常由数据结构、数据操作、完整性约束构成。对应关系模型就是关系数据结构，关系操作集合，关系完整性约束。

## 关系模型的基本概念

关系理论是以集合代数理论为基础的，因此，我们可以用集合代数给出二维表的关系定义。

> [!note] 集合代数基本概念
> 1. 域：一组具有相同数据类型的值的集合。例如自然数、整数、{男, 女}、{0, 1}。
> 2. 笛卡尔积^[笛卡尔积的意义是所有集合的域中的值的组合的集合，该集合不能重复]：对于一组集合 $D_{1},D_{2},\cdots,D_{n}$ (可以重复)，它们的笛卡尔积定义为
> $$
> D_{1}\times D_{2}\times\cdots\times D_{n}=\{ \left( d_{1},d_{2},\cdots,d_{n} \right) \mid d_{i}\in D_{i}, i=1,2,\cdots,n \}
> $$
> 1. 元组：笛卡尔积中的每个元素 $(d_{1},d_{2},\cdots,d_{n})$ 称为一个 $n$ 元组，或者简称元组。
> 2. 分量：笛卡尔积元素 $d_{1},d_{2},\cdots,d_{n}$ 中的每一个 $d_{i}$ 称为一个分量。

### 关系

> [!definition|Definition] 关系
> 关系是笛卡尔积的子集，$D_1 \times D_2 \times \dots \times D_n$ 的任意一个子集称为 $D_1,D_2,\dots,D_n$ 上的一个关系。其中 $N$ 称为关系的目或度。

> [!note] 基本表示
> - 元组和属性：
> 	- 关系中的每一行对应一个元组，通常用 $t$ 表示。
> 	- 每一列对应一个域，关系中的列被称为属性，每一列用属性名表示。$t[A_i]$ 表示元组 $t$ 在属性 $A_i$ 上的值。
> - 一元关系与二元关系：当 $n=1$ 时，称该关系为一元关系；当 $n=2$ 时，称该关系为二元关系
> - 在数据库中，我们规定：
> 	- 无限关系在数据库中无意义，因此限定关系代数数据模型中的关系必须是有限集合
> 	- 通过为关系的每列增加一个属性名的方法取消元组的有序性。

> [!note] 规范化的关系的性质
> 1. **列是同质的**：每一列的分量是统一类型的数据，来自同一个域
> 2. **不同的列可出自同一个域**：其中的每一列称为一个属性，不同的属性要给予不同的属性名
> 3. **列的顺序无所谓**：列的次序可以任意交换
> 4. **各个元组是不同的**：即关系中不允许出现重复元组
> 5. **行的顺序无所谓**：即行的次序可以任意交换
> 6. **分量必须取原子值**：这是规范条件中最基本的一条

### 关系模式与关系数据库

- **关系模式**是对关系的描述，关系模式一般简记为关系名和属性名的集合 $R(A_1,A_2,\dots,A_n)$ 或仅用关系名 $R$ 表示，如图书关系模式可以描述为 $图书(书号，书名，作者，单价，出版社)$。
- 关系的值是元组的集合，称为关系。
- 关系模式和关系统称为关系，通过上下文加以区别。

> [!definition|Definition] 关系数据库
>   - 关系模式的集合称为**关系数据库模式**，是对数据库中所有数据逻辑结构的描述，表示为 $R=\{R_1,R_2,\dots,R_p\}$
>   - 关系数据库模式中的每个关系模式上的关系的集合称为关系数据库，表示为 $d=\{r_1,r_2,\dots,r_p\}$，其中 $r_i$ 是对应关系模式 $R_i$ 上的一个关系

### 键

为了区分不同元组，用其中一个或者多个属性值标识，能够唯一标识元组的属性或属性组称为关系的**键**。

> [!definition|Definition] 键
> 设关系模式 $R(U),K\subseteq U$，$r$ 是 $R$ 上的任意一种关系，若对 $r$ 中任意两个不同的元组 $t_{1}$，$t_{2}$，满足：
> 1. $t_1[K] \neq t_2[K]$
> 2. 不存在 $K'\subset K$ 而使得 $t_1[K]\neq t_2[K]$
>
> 则称 K 是 R 的键。若第二个条件成立，则称 K 是 R 的超键。

> [!note] 主键与候选键
> - 关系中能够起标识作用的键称为**候选键**
> 	- 在一个关系中，如果有多个候选键，选其中一个键作为**主键**
> 	- 若关系的键由多个属性组成，称为**联合键**
> 	- 关系的所有属性构成该关系的键，称为**全键**
> - **外建**：一个关系中的一般属性或者组成键的部分属性，又同时是另一个关系的键

### 完整性约束

为了维护数据库中数据与现实世界的一致性，对关系数据库的插入、删除和修改操作必须有一定的约束条件，这就是关系模型的三类完整性约束。
- 实体完整性：通常由关系系统自动支持。
- 参照完整性：通常由关系系统自动支持。
- 用户定义的完整性：反映应用领域需要遵循的约束条件，体现了具体领域中的语义约束。用户定义后由系统支持。

#### 实体完整性约束

**实体完整性** (Entity Integrity Constraint) 指主键的值不能为空或者部分为空。
- 若属性 $A$ ^[一个或一组属性] 是基本关系 $R$ 的主属性，则属性 $A$ 不能取**空值**。

> [!tip] 如果一个元组的键为空值或部分为空，则该元组将不可标识，不能表示任何实体，因而无意义。

> [!note] 关系模型必须遵守实体完整性规则的原因
> 1. 实体完整性规则是针对基本关系而言的，一个基本表通常对应现实世界的一个实体集或多对多联系。我们假设现实世界中的实体和实体是可以区分的，即它们具有某种唯一标识。相应的，关系模型中以主键作为唯一标识。
> 2. 主键中的属性，即主属性不能取空值。如果主属性取空值，说明存在某个不可标识的实体，即存在不可区分的实体。这与基本关系的假设矛盾。

#### 参照完整性约束

**参照完整性约束** (Reference Integrity Constraint) 是对关系中作为**外键**的值的约束。规定：
- 如果关系 $R_1$ 中属性 $A$ 是另一个关系 $R_2$ 中的主键，则对于关系 $R_1$ 中的任一个元组在属性 $A$ 上的值或者为空值，或者为另一个关系 $R_2$ 中某个元组的主键的值。
- 参照完整性约束规定了关系模型中存在的关系与关系间的引用。

> [!definition|Definition] 外键
> 设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的键。如果 $F$ 与基本关系 $S$ 的主键 $K_{s}$ 相对应，则称 $F$ 是基本关系 $R$ 的外键。

> [!note]
> - 基本关系 $R$ 被称为**参照关系**，基本关系 $S$ 称为**被参照关系**或者**目标关系**。
> - 关系 $R$ 和 $S$ 不一定是不同的关系。
> - $S$ 的主键 $K_{s}$ 和 $R$ 的外键 $F$ 必须定义在同一个域上，或同一组域上。
> - 外键并不一定要与相应的主键同名。

#### 用户定义的完整性

不同的关系数据库系统由于应用环境的不同，往往还需要一些特殊的约束条件，这就是**用户定义完整性** (User-defined Integrity)。
- 用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。
- 关系模型应该提供定义和检验这类完整性的机制，以便用统一的、系统的方法处理它们，而不要由应用程序承担这一功能。

## 关系代数

关系代数是一种抽象的查询语言，是以关系为运算对象的一组运算的集合。在关系代数运算中，运算的三个要素分别为：
- 运算对象：关系
- 运算结果：关系
- 运算符

按照关系运算符的不同，关系代数运算分为两类：
1. 传统的集合运算：
	- 并、差、交、广义笛卡尔积。
	- 把关系看做元组的集合，则以元素作为集合中的元素可以进行集合运算。其运算是从关系的水平方向的角度进行的。
2. 专门的关系运算：
	- 选择、投影、连接、除。
	- 不仅涉及行运算，也涉及列运算，这种运算是为数据库的应用而引进的特殊运算。

### 传统的集合运算

下面以 $R\ op\ S$ 为例：
- 并 (union)：属于 $R$ 或者 $S$ 的所有元素，记为 $R \cap S$
- 交 (intersection)：既属于 $R$ 又属于 $S$ 的元素，记为 $R \cup S$
- 差 (difference)：属于 $R$ 但不属于 $S$ 的元素，记为 $R-S$
- 笛卡尔积：R 中所有元组和 S 中所有元组的拼接，记为 $R\times S$

> [!example]- 笛卡尔积
> ![[Assets/关系数据库.png]]

### 专门的关系运算

> [!note] 常用记号补充
> - 设 $R$ 是关系，$t$ 是元组，
>   - 设关系模式为 $R(A_1,A_2,\cdots,A_n)$，它的一个关系为 $R$
>   - $t\in R$ 表示 $t$ 是 $R$ 的一个元组。
>   - $t[A_i]$ 表示元组 $t$ 中相对应属性 $A_i$ 的一个分量。
> - 若 $A=\{A_{i1},A_{i2},\cdots, A_{ik}\}$，其中 $A_{i1},A_{i2},\cdots,A_{ik}$ 是 $A_1,A_2,\cdots,A_n$ 中的一部分，则称 $A$ 为属性列或域列。
>   - $t[A]=(t[A_{i1}],t[A_{i2}],\cdots,t[A_{ik}])$ 表示元组 $t$ 在属性列 $A$ 上诸分量的集合。
>   - $\overline{A}$ 则表示 $\{A_1,A_2,\cdots,A_n\}$ 在去掉 $A=\{A_{i1},A_{i2},\cdots, A_{ik}\}$ 或剩余的属性组。
> - $\overset{\frown}{t_rt_s}$ 称为元组的连接，它是一个 $n+m$ 列的元组，前 $n$ 个分量为 $R$ 中的一个 n 元组，后 $m$ 个分量为 $S$ 中的一个 $m$ 元组。

#### 选择 (Selection)

选择运算是关系上的一元运算，是从关系中选择满足一定条件的元组子集：
$$
\sigma_F(R)=\{t\mid r\in R \wedge t(F)\}
$$
- $F$ 是限定条件的布尔表达式
- 上式表示在关系 $R$ 中选择使 $t(F)$ 为真的所有元组
- 选择运算是从行的角度进行的运算

#### 投影 (Projection)

在模式 $R$ 上的投影运算表示为：
$$
\Pi_X(R)=\{t[X]\mid t\in R\}
$$
- 其中，$\Pi$ 是投影算符，$X$ 是模式 $R$ 属性的子集，$t[X]$ 表示 $R$ 中元组在属性集 $X$ 上的值，或为元组 $t$ 在 $X$ 上的投影
- 从 $R$ 中选择出若干属性列组成新的关系
- 投影操作主要从列的角度进行运算（但是投影后会消除重复行）

#### 连接 (Join)

连接运算是把两个关系中的元组按条件连接起来，形成一个新关系。
- **条件连接**：条件连接也称 $\theta$ 连接，是将两个关系中满足 $\theta$ 条件的元组拼接起来形成新元组的集合。设属性 A 和 B 分别是关系 R 和 S 上的属性，且定义在同一个域上，R 和 S 的连接记为：
	$$
	R \underset{{A\,\theta\, B}}{\bowtie}S=\{t|t=\overset{\frown}{t_rt_s},t_r\in R \wedge t_s\in S\wedge t_r[A]\,\theta\, t_s[B]\}
	$$
	- 其中，$\bowtie$ 是连接符，$A\,\theta\,B$ 为连接条件。$\theta$ 是比较符
	- 从 $R$ 和 $S$ 的笛卡尔积 $R\times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上值满足比较条件的元组。
	- 最常用的连接是两个属性值的相等比较。
	- $\theta$ 为 $=$ 的连接运算称为等值连接。
- **自然连接**：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。即自然连接会将对应分量相同的元组进行拼接，且只会保留一组相同的分量。
	$$
	R\bowtie S=\{t|t=\overset{\Large\frown}{t_rt_s[\overline{A}]},t_r\in R\wedge t_s\in S \wedge t_r[A]=t_s[A]\}
	$$

> [!note]
> - 一般的连接操作是从行的角度进行运算
> - 自然连接还需要取消重复列，所以使同时从行和列的角度进行运算

> [!example]- 条件连接
> ![[Assets/关系数据库-2.png]]

> [!example]- 自然连接
> ![[Assets/关系数据库-1.png]]

#### 除运算 (Division)

除法运算是一个二元运算，用 $\div$ 表示
- 若 $R\div S$，要求 $R$ 和 $S$ 有定义在同一域上的属性或属性组。
- $R\div S$ 的结果生成一个新关系 $R'$，$R'$ 的属性是 $R$ 的属性中去掉与具有公共域属性的其他属性。

设 $R(X,Y),S(Y),R'(X)$。则 $R\div S$ 记为：
	$$
	R\div S=R'=\{t_r[X]|t_r\in R\wedge t_r[X]\times S\subseteq R\}
	$$
- $R\div S$ 是 $\Pi_X(R)$ 的最大的子集 $R'$，使得 $R'\times S$ 包含在 $R$ 中。
- 除运算可以使用其他关系运算表示：
  - $R\div S=\Pi_X(R)-\Pi_X(\Pi_X(R)\times S - R)$
  - 除操作是同时从行和列的角度进行运算的

> [!note] 使用象集计算除运算
> 象集 $Z_x$：给定一个关系 $R(X,Z)$，$X$ 和 $Z$ 是属性组。当 $t[X]=x$ 时，$x$ 在 $R$ 中的象集为：
> $$
> Z_x=\{t[Z]|t\in R, t[X]=x\}
> $$
> - 它表示 $R$ 中属性组 $X$ 上的值为 $x$ 时对应的其他分量构成的元组的所有值的集合。
> - 给定关系 $R(X,Y)$ 和 $S(Y,Z)$，其中 $X$，$Y$，$Z$ 为属性组。$R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须出自相同的域集。$R$ 与 $S$ 的除运算得到一个新的关系 $P(X)$，$P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：
> 	$$
> 	R\div S=\{t_r[X]|t_r\in R \wedge \Pi_Y(S)\subseteq Y_x\}
> 	$$
>   - $Y_x$：x 在 R 中的象集，$x=t_r[X]$
>   - 它表示元组在 X 上分量值 x 的象集 $Y_x$ 包含 S 在 Y 上投影的集合
>
> 使用象集进行除运算的步骤：
>   1. 写出 $Y_x$，即 $x$ 在 $R$ 中的象集
>   2. 写出 $S$ 中与 $R$ 相同的属性的投影
>   3. 若 $x$ 的象集包含了投影，则结果包含 $x$

> [!example]- 除运算
> ![[Assets/关系数据库-3.png]]

### 扩充的关系运算

#### 属性重命名

设 $r$ 是模式 $R$ 上的一个关系，$A$ 是 $R$ 的一个属性，$B$ 为属性名，$B$ 不是 $R$ 中的属性，$B$ 和 $A$ 具有相同的域，则将属性 $A$ 重命名为 $B$，记为：
$$
\delta_{A\to B}(r)=\{t'|t\in r \wedge t'[R-A]=t[R-A]\wedge t'[B]=t[A]\}
$$

> [!note] 属性重命名的作用
> - 在同一个关系上做自然连接运算
> - 做同一个关系的笛卡尔积
> - 将两个关系的等值连接方便地表示为自然连接

#### 外连接

> [!note] 内连接
> 内连接 (inner join) 运算是把两个关系中的元组按条件连接起来，结果为满足条件的元素集合。

**外连接 (outer join)** 是对自然连接运算的拓展。外连接结果中除了满足连接条件的元组外，包含没有被连接的元组。
- **左外连接**：连接结果中包含了关系 $R$（左边关系）中不满足连接条件的元组，在这些元组对应关系 $S$ 属性上的值为空值，记为 $R\bowtie_L S$
- **右外连接**：连接结果中包含了关系 $S$（右边关系）中不满足连接条件的元组，在这些元组对应关系 $R$ 属性上的值为空值，记为 $R\bowtie_R S$
- **完全外连接**：完全外连接的连接结果中包含了关系 $R$ 中不满足连接条件的元组，同时也包含了关系 $S$ 中不满足连接条件的元组。即连接结果是左外连接和右外连接结果的并，记为：$R⋈_FS$。

## 元组关系演算

关系代数语言：用对关系的运算来表达查询要求

关系演算语言：用谓词来表达查询要求

按谓词变元的基本对象的不同分为：

- 元组关系演算语言
  - 谓词变元的基本对象是元组变量
- 域关系演算语言
  - 谓词变元的基本对象是域变量

### 元组关系演算语言 ALPHA

操作语句 工作空间名 (表达式)：操作条件

- 表达式用于指定语句的操作对象，它可以是关系名或属性名，一条语句可以同时操作多个关系或多个属性
- 操作条件是一个逻辑表达式，用于将操作结果限定在满足添加的元组中，操作条件可以为空
- 除此之外，还可以在基本格式的基础上加上排序要求，定额要求等

#### 检索语句 GET

例：查询所有被选修的课程号码：GET W (SC.Cno)

#### 更新语句 PUT, HOLD, UPDATE, DELETE, DROP

修改操作步骤：

1. 用 HOLD 语句将要修改的元组从数据库中读到工作空间中
2. 用宿主语言修改工作空间中元组的属性
3. 用 UPDATE 语句将修改后的元组送回数据库中

插入操作步骤：

1. 用宿主语言在工作空间中建立新元组
2. 用 PUT 语句把该元组存图指定关系中

删除操作步骤：

1. 用 HOLD 语句把要删除的元组从数据库中读到工作空间中
2. 用 DELETE 语句删除该元组

## 域关系演算

- 一种典型的与关系演算语言
- QBE：Query By Example
  - 基于屏幕表格的查询语言
  - 查询要求 L：以填写表格的方式构造查询
  - 用示例元素（域变量）来表示查询结果可能的情况
  - 查询结果：以表格形式显示

### 检索操作

1. 用户提出要求
2. 屏幕显示空白表格
3. 用户在最左边一栏输入要查询的关系名，例如 Student
4. 系统显示该关系的属性名
5. 用户在上面构造查询要求
6. 屏幕显示查询结果

---

< [[00-笔记/数据库/数据模型|数据模型]] | [[00-笔记/数据库/SQL|SQL]] >
