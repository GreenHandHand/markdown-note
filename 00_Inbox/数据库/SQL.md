---
tags:
  - 数据库
---

# 关系数据库标准语言 SQL

结构化查询语言 SQL(Structured Query Language) 是一种介于关系代数与关系演算之间的语言，是一个通用的、功能极其强的 [[00_Inbox/数据库/关系数据库|关系数据库]] 语言，是关系数据库的标准语言。SQL 语言集*数据定义*、*数据查询*、*数据操纵*和*数据控制*于一体，充分体现了关系数据语言的特点和优点

> [!note] SQL 的特点
> 1. 综合统一：集数据定义语言 DDL、数据操纵语言 DML、数据控制语言 DCL 的功能于一体，可以完成数据库生命周期中的全部活动。由于关系模型中实体和实体间的联系都用关系来表示，使得操作符单一，每种操作只能使用一个操作符。
> 2. 高度非过程化：使用 SQL 语言，只需要描述做什么，而无需指明怎么做，无需了解存取路径，提高了数据的独立性。
> 3. 面向集合的操作方式：SQL 语言采用集合操作方式，查询、插入、删除、修改操作的对象都是集合。
> 4. 以同一种语法结构提供多种使用方式：
> 	- 作为独立的语言，提供了联机交互工具，在终端上直接键入 SQL 命令对数据库进行操作，并由 DBMS 来进行解释。
> 	- 作为嵌入式语言，SQL 语句能嵌入到高级语言程序中，使应用程序充分利用 SQL 访问数据库的能力。
> 	- 不同方式下，SQL 的语法结构基本上是一致的，提供了极大的灵活性和方便性。

> [!info] SQL 语言的版本包括：
> - SQL-86、SQL-89、SQL-92(SQL2)
> - SQL-99(SQL3) 增加了面向对象的概念
> - SQL2003(SQL4)
> - SQL2008

## SQL 的系统结构

SQL 语言支持数据库的三级模型结构，即
- **内模式**：基本表在物理上与储存文件相对应，所有储存文件的集合为物理数据库，对应着内模式。
- **模式**：关系模式称为基本表，基本表的集合形成数据库模式，对应着模式。
- **外模式**：外模式由视图 (view) 组成。

> [!note] SQL 中的基本结构
> - 基本表：独立存在的表
> - 储存文件：对最终用户透明
> - 视图：由一个或多个基本表导出，不实际存在，虚表
> - 索引：一个表可以带若干索引，索引存放在储存文件中

### 数据定义语句

关系数据库系统的基本对象有模式 (Schema)、表 (Table)、视图 (View) 和索引 (Index)，下表是它们分别对应的定义、删除与修改语句。

|     |      创建       |     删除      |     修改      |
| :-: | :-----------: | :---------: | :---------: |
| 模式  | CREATE SCHEMA | DROP SCHEMA |             |
|  表  | CREATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图  |  CREATE VIEW  |  DROP VIEW  |             |
| 索引  | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

> [!note]
> 在 SQL 中，一个 SQL 模式由*模式名*、*权限标识符*和*模式中元素的描述符*组成。
> - 权限标识符：指明拥有该模式的用户或账号
> - 模式元素：包含一个数据库应用的表、视图和索引等。
> - 属于同一个应用的表、视图和索引等可以定义在同一个模式中。

#### 模式的定义和删除

在定义模式时可以先给出模式名和权限标识符，以后再定义其中的元素，语法格式：`CREATE SCHEMA <模式名> AUTHORIZATION <用户名>`
- 如果没有指定 `<模式名>`，则隐含为 `<用户名>`。
- 可以在创建模式的同时在模式定义中进一步创建基本表、视图、定义授权等。

模式定义语句：
  ```sql
  CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [ <表定义子句> | <视图定义子句> | <授权定义子句> ]
  ```

删除模式语句：
```sql
DROP SCHEMA <模式名> [ CASCADE | RESTRICT ]
```

> [!note] 删除参数
> - CASCADE：级联式方式，表示在删除模式的同时把该模式中所有的数据库对象全部一起删除
> - RESTRICT：限制式方式（默认），表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行

#### 表的定义、修改与删除

##### 定义基本表

```sql
CREATE TABLE <表名>
    ( <列名> <数据类型> [ <列级完整性约束条件> ],
      <列名> <数据类型> [ <列级完整性约束条件> ],
      ...,
     [ <表级完整性约束条件> ], [ <表级完整性约束条件> ]...);
```

> [!note] 定义参数
> - 表名：所要定义的基本表的名字。
> - 列名：组成该表的各个属性（列）。
> - 列级完整性约束条件：涉及相应属性列的完整性约束条件，格式为 `CONSTRAINT <约束名> <约束>`。
> - 表级完整性约束条件：涉及一个或者多个属性列的完整性约束条件，格式为 `CONSTRAINT <约束名> <约束>`。

> [!note] 域
> 在 SQL2 中增加了定义域的语句，可以用域名代替指名列的数据类型。域定义语句的格式为：
> ```sql
> CREATE DOMAIN <域名> <数据类型>
> ```
>
> 在域创建后，定义表时，对列的类型定义可以直接使用域名替换。如果有一个或多个表的属性的域是相同的，通过对域的修改可以很容易地改变属性的数据类型。

> [!tip]
> 在定义基本表时，表所属的数据库模式一般被隐式指定，也可以显示地在定义表时指定表所属的数据库模式名。
>   - 例：`CREARE TABLE SST.Student` 指定学生表所在的模式为学生数据库模式 `SST`

##### 修改基本表

```sql
ALTER TABLE <表名>
    [ ADD   <列名> <数据类型> [ <完整性约束> ] ]
    [ DROP  <列名> [ CASCADE | RESTRICT ] ]
    [ ALTER <列名> <数据类型> ];
```

> [!note] 参数
> - `ADD` 字句用于增加新列，包括列名、数据类型和列级完整性约束。
> - `DROP` 子句用于删除指定的列名。
>   - `CASCADE` 表示删除列时自动删除引用该列的视图和约束。
>   - `RECTRICT` 表示没有视图和约束引用时才能删除该列，否则将拒绝删除操作。
> - `ALTER` 子句用于修改列的定义，如修改列的数据类型或修改列的宽度。

##### 删除基本表

```sql
DROP TABLE <表名> [ RESTRICT | CASCADE ];
```

> [!note]
> - 若选择 `RESTRICT`，则删除的基本表不能是由 `FOREIGN KEY` 约束引用的表，不能有视图，不能有触发器，不能有存储过程和函数等。如果存在这些依赖该表的对象，则此表不能被删除。
> - 如选择 `CASCADE`，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图等都被一起删除。
> - 缺省的情况下，默认为 `RESTRICT`。

#### 索引的建立、修改与删除

索引是一种数据结构，可以提高查询速度。大型关系数据库中的索引的实现技术是数据库管理系统实现总最重要的核心问题。当关系变得很大时，通过扫描所有关系中的所有元组来找出那些匹配给定条件的元组的操作方式代价太高，此时建立索引是**加快查询速度**的有效手段。
- 可根据需要在一个表上建立一个或多个索引，以提供多种存取路径，加快查找速度。也可以不建立索引。
- 建立索引的时机：
	- DBA 或表的属主（即建立表的人）根据需求建立
	- 有些 DBMS 自动建立以下列的索引：`PRIMARY KEY`, `UNIQUE`
- 维护索引：由 DBMS 自动完成
- 使用索引：系统在存取数据时会自动选择是否使用索引以合适的索引作为存取路径，用户不必也不能选择索引。

##### 建立索引

```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
    ON <表名> ( <列名> [ <次序> ], [ <列名> [ <次序> ] ]...);
```

> [!note] 参数
> - 表名：指定要建索引的基本表名字。
> - 列名：索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。
> - 次序：指定索引值的排列次序，升序 `ASC`，降序 `DESC`。默认为升序。
> - `UNIQUE`：表明此索引值只对应唯一的数据记录。
> - `CLUSTER`：表示要建立的索引时聚簇索引。

> [!note] 聚簇索引
> 根据索引的顺序和数据库的物理存储属性是够相同，索引分为聚簇索引、非聚簇索引。
> - **聚簇索引**：对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚簇索引与数据是混为一体的，它的叶节点中存储的是实际的数据^[[[02_Areas/数据结构与算法/查找#B+ 树|B+树]]]。
> 	- 聚簇索引确定表中数据的物理顺序，因此一个表只能由一个聚簇索引，但是该索引可以包含多列 (组合索引)。
> 	- 适用于很少对基表进行增删操作，很少对其边长列进行修改操作的情况。
> - **非聚簇索引**：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。

##### 修改与删除索引

```sql
-- 重命名索引
ALTER INDEX <旧索引名> RENAME TO <新索引名>
-- 删除索引
DROP INDEX <索引名>
```

> [!note] 什么时候使用索引？
> 索引为性能所带来的好处是有代价的，数据库设计者需要对索引作一个折中的选择，这种选择是衡量数据库设计成败的重要因素。
> - 索引为性能所带来的好处：
> 	- 对某个属性使用索引能极大提高对该属性上的值的检索效率，使用到该属性时，还可以加快连接操作。
> - 索引的代价：
> 	- 带索引的表在数据库中会占据更多的空间。
> 	- 维护索引的代价，对数据进行插入、更新、删除操作的命令所花费的时间会更长。
> - 应评估*数据的性质*和*表的查询性质*，来决定是否创建索引，应确保对性能的提高程度大于在储存空间和处理资源方面的代价。

#### 数据字典

数据字典是关系数据库管理系统内部的一组系统表，记录了数据库中的所有定义信息。
- 关系模式定义
- 视图定义
- 索引定义
- 完整性约束定义
- 各类用户对数据库的操作权限
- 统计信息

关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息。

## SQL 数据操纵

### 查询

> [!info] 完整句式
> ```sql
> SELECT [ALL|DISTINCT] <目标列表达式> | ...
> FROM <表名或视图名> [, <表名或视图名> ] ...
> [ WHERE <条件表达式> ]
> [ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
> [ ORDER BY <列名2> [ ASC | DESC ] ];
> ```

数据查询是数据库的核心功能，使用关键词 `SELECT` 表示一个查询语句。其基本句式如下，作用为*从 R1,R2,...,Rn 中选择满足 P 的元组，并输出其中的 A1,A2,...,An 列*。
```sql
SELECT A1, A2, ..., An FROM R1, R2, ..., Rn WHERE P;
```

> [!tip] 相当于语句 $\Pi_{A_1,A_2,\dots,A_n}(\sigma_P(R_1\times R_2\times\dots\times R_n))$

#### 单表查询

查询仅涉及一个表，是一种最简单的查询操作，可以进行的操作包含
- 选择表中的若干列
- 选择表中的若干元组
- 对查询结果进行排序
- 使用聚集函数
- 对查询结果进行分组

> [!note]
> `SELECT` 语句中的 `<目标列表达式>` 不仅可以是表中的属性列，还可以是表达式^[表达式可以是算术表达式，字符串常量，函数，列别名等]。
> - 直接查询与使用表达式：查询全体学生的姓名及其出生年份，`SELECT Sname, 2023-Sage FROM Student`。
> - 使用内置函数与字符串：查询全体学生的姓名、出生年份和所在系，使用小写表示系名，`SELECT Sname, 'Year of Birth:', 2023-Sage, LOWER(Sdept)`。
> - 使用 `DISTINCT` 消除重复元组：`SELECT DISTINCT Sno, Grade FROM SC`。

##### 条件语句

|  条件表达式  | 语法                                                        |
| :-----: | --------------------------------------------------------- |
|  比较表达式  | `<列名1> op <列名2> \| 常量`                                    |
|         | 其中 `op` 可以是比较运算符：`=,>,>=,<,<=,<>,!=`                      |
|  逻辑表达式  | `<条件表达式1> op <条件表达式2>`                                    |
|         | 其中 `op` 可以是逻辑运算符 `AND, OR, NOT`                           |
| BETWEEN | `<列名1> [NOT] BETWEEN <常量或列名> AND <常量或列名> ...`             |
|   IN    | `<列名> [NOT] IN [常量、表、列 或者 SELECT子句]`                      |
|  LIKE   | `<列名> [NOT] LIKE '匹配字符串'`                                 |
|         | 其中匹配字符串使用 `_` 表示匹配一个字符，使用 `%` 表示匹配任意字符串                   |
|         | 对于字符串中包含 `_` 与 `%` 的匹配，需要使用 `ESCAPE` 关键字指定转义字符，在匹配串中进行转义。 |
|  NULL   | `<列名> IS [NOT] NULL`                                      |
|         | 需要注意，不能使用 `= NULL` 匹配空值。                                   |
|  EXIST  | `[NOT] EXISTS [SELECT子句]`                                 |

> [!note] SQL 空值
> SQL 允许属性有一个特殊值 `NULL`，称为空值。
> - 空值不同于空白或零值。没有两个相等的空值，空值和任何值进行算数运算，结果仍为空值。
> - 执行计算时消除空值很重要，因为包含空值列的某些计算 (例如平均值) 会不准确。
> - 当使用逻辑运算符和比较运算符，有可能返回结果 `UNKNOWN`，该值与 `TRUE` 和 `FALSE` 地位同等，是一种布尔值。
> - 空串指零长度的字符串。

> [!example]
> 1. 比较大小：`SELECT Sname, Sage FROM Student WHERE Sage < 20;`
> 2. 确定范围：`SELECT Sname, Sage FROM Student WHERE Sage BETWEEN 20 AND 23;`
> 3. 确定集合：`SELECT Sname Ssex FROM Student WHERE Sdept IN ('IS', 'MA', 'CS');`
> 4. 字符串匹配：`SELECT Sname, Sno, Ssex FROM Student WHERE Sname LIKE '刘%';`
> 5. 字符串匹配转义：`SELECT Cno, Ccredit FROM Course WHERE Cname LIKE 'DB\_Design' ESCAPE '\';`
> 6. 涉及空值的查询：`SELECT Sno, Cno FROM SC WHERE Grade IS NULL;`
> 7. 多重条件：`SELECT Sname FROM Student WHERE Sdept='CS' AND Sage < 20;`

##### 对查询结果进行排序

使用 `ORDER BY` 子句可以对查询结果按一个或多个属性列排序，升序 `ASC`，降序 `DESC`。缺省时为升序。

> [!note] 空值将作为最大值排序，即 `ASC` 排序后空值最后显示，`DESC` 排序后空值最先显示

> [!example]
> ```sql
>  SELECT Sno, Grade
>  FROM SC
>  WHERE Cno='3'
>  ORDERE BY Grade DESC;
> ```

##### 聚集函数

| 聚集函数  | 用法                                |
| :---: | --------------------------------- |
|  计数   | `COUNT([ DISTINCT or ALL ] <列名>)` |
| 计算总和  | `SUN([ DISTINCT or ALL ] <列名>)`   |
| 计算平均值 | `AVG([ DISTINCT or ALL ] <列名>)`   |
| 求最大值  | `MAX([ DISTINCT or ALL ] <列名>)`   |
| 求最小值  | `MIN([ DISTINCT or ALL ] <列名>)`   |
|       | `DISTINCT`：在计算时取消指定列中的重复值         |
|       | `ALL`：不取消重复是，默认为 `ALL`             |

##### 对查询结果进行分组

使用 `GROUP BY` 子句分组，分组的作用如下：
- 细化聚集函数的作用对象。
	1. 未对查询结果分组，聚集函数将*作用于整个查询结果*。
	2. 对查询结果分组后，聚集函数将*分别作用于每一个组*。
- 分组方法：按指定的一列或者多列值分组，值相等的为一组。
	- 使用 `GROUP BY` 子句后，`SELECT` 子句的列名列表中只能出现分组属性和聚集函数。
- `GROUP BY` 子句的作用对象是查询的中间结果表
- 使用 `HAVING` 短语筛选最终输出结果
  - 只有满足 `HAVING` 短语指定条件的组才输出

> [!example]
> 查询选修了 3 门以上课程的学生学号:
> ```sql
> SELECT Sno
> FROM SC
> GROUP BY Sno
> HAVING COUNT(*) > 3
> ```

> [!note] `HAVING` 与 `WHERE` 的区别
> 1. 作用对象不同
> 	- `WHERE` 子句作用于基表或视图，从中选择满足条件的元组。
> 	- `HAVING` 子句作用于组，从中选择满足条件的组。
> 2. 聚合函数
> 	- `WHERE` 子句不能使用聚合函数。
> 	- `HAVING` 子句可以使用聚合函数。

#### 连接查询

同时涉及多个表的查询称为**连接查询**。用来连接两个表的条件称为**连接条件**或**连接谓词**。连接谓词中的列名称称为**连接字段**。SQL 中连接查询的主要类型有：
1. 广义笛卡尔积
2. 等值与非等值连接
3. 自身连接查询
4. 外连接查询
5. 复合条件连接查询

##### 广义笛卡尔积

不带连接谓词的连接。广义笛卡尔积是两表元组的交叉乘积，其连接的结果会产生大量没有意义的元组，基本上用不到。

> [!example]
> ```sql
> SELECT Student.*, SC.*
> FROM Student, SC;
> ```

##### 等值连接与非等值连接

- **等值连接**：即连接运算符为 $=$ 的连接操作。
- **非等值连接**：即连接运算符为比较运算符的连接操作。
- **自身连接**：一个表与其自己进行连接，称为表的自身连接，需要给表起别名以示区别。
- **外连接**：
	- 内连接操作只输出满足连接条件的元组，外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出
	- 外连接通过在非主体表中添加虚行实现，该行全部由空值组成。
- **复合条件连接**：`WHERE` 子句中含有多个连接条件时，称为复合条件连接，复合条件连接可以看作普通连接后得到的关系表又进行一次选择运算。

> [!example]
> 1. 等值连接：`SELECT Student.*, SC.* FROM Student, SC WHERE Student.Sno=SC.Sno;`
> 2. 自身连接：`SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cno=SECOND.Cno;`
> 3. 内连接：`SELECT buyer_name, sales.buyer_id, qty FROM buyers INNER JOIN sales ON buyers.buyer_id = sales.buyer_id;`
> 4. 外连接：`SELECT Student.Sno, Cno FROM Student LEFT OUTER JOIN SC ON Student.Sno=SC.Sno;`
> 5. 复合连接：`SELECT Student.Sno, Student.Sname FROM Student.SC WHERE Student.Sno=SC.Sno AND SC.Cno='2';`

### 嵌套查询

将一个查询块嵌套在另一个查询块的 `WHERE` 子句或 `HAVING` 短语的条件中的查询称为嵌套查询。嵌套查询的实现一般是从里到外，即先进行了子查询，再把其结果用于父查询的条件。
- 一个 `SELECT-FROM-WHERE` 语句称为一个查询块。
- 子查询不能使用 `ORDER BY` 子句。
- 子查询需要使用谓词 `IN`、比较运算符、`ANY`、`ALL`、`EXISTS` 引出。

> [!note] 嵌套查询的分类
> - 不相关子查询：
> 	- 子查询的条件不依赖于父查询。
> 	- 是由里向外逐层处理，即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。
> - 相关子查询：
> 	- 子查询的查询条件依赖于父查询。
> 	- 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若 `WHERE` 子句返回值为真，则取此元组放入结果表。
> 	- 然后再取外层表的下一个元组，重复这一过程直到外层表全部检查完为止。

#### 含有 IN 的子查询

> [!example]
> 查询选修了课程名为信息系统的学生学号和姓名。
> ```sql
> SELECT Sno, Sname
> FROM Student
> WHERE Sno IN (
> 	SELECT Sno
> 	FROM SC
> 	WHERE Cno IN (
> 		SELECT Cno
> 		FROM Course
> 		WHERE Cname='信息系统'
> 	)
> );
> ```

#### 含有比较运算符的子查询

当能确切直到内层查询返回单值时，可以用比较运算符。

> [!example]
> 假设一个学生只可能在一个系学习，并且必须属于一个系，则可以使用下面的方式查询。
> ```sql
> SELECT Sno, Sname, Sdept
> FROM Student
> WHERE Sdept = (
> 	SELECT Sdept
> 	FROM Student
> 	WHERE Sname LIKE '刘*'
> );
> ```

> [!warning]- 子查询一定要在比较符之后。
> ```sql
> SELECT Sno, Sname, Sdept
> FROM Student
> WHERE (
> 	SELECT Sdept
> 	FROM Student
> 	WHERE Sname LIKE '刘*'
> ) = Sdept; -- 错误用法
> ```

#### 带有 ANY 或 ALL 谓词的子查询

谓词语义：`ANY` 表示任何一个，`ALL` 所有值，常使用它们配合比较运算符进行查询。

> [!example]
> 查询其他系中比 CS 系任意一个学生年龄小的学生姓名和年龄。
> ```sql
> SELECT Sname, Sage
> FROM Student
> WHERE Sage < ANY(
> 	SELECT Sage
> 	FROM Student
> 	WHERE Sdept = 'CS'
> ) AND Sdept <> 'CS';
> ```

#### 带有 EXISTS 谓词的子查询

- `EXIST` 谓词，存在量词，当内层查询结果为空时，返回 `FALSE`，当内存查询结果非空时，返回 `TRUE`。
- 由 `EXISTS` 引出的子查询，其目标列表达式通常用 `SELECT *` 表示，因为带 `EXISTS` 的子查询只返回真值或假值，给出列名没有实际意义。
- `NOT EXISTS` 谓词

> [!example]
> ```sql
> SELECT Sname
> FROM Student
> WHERE EXISTS (
> 	SELECT *
> 	FROM SC
> 	WHERE Sno = Student.Sno AND Cno='1'
> );
> ```

### 集合查询

> [!info]
> 标准 SQL 只直接支持并操作。但是在一般的商用数据库中同时支持并、交、差操作。

使用集合查询的需要满足：
- 属性的个数必须一致
- 对应的类型必须一致
- 属性名无关
- 最终结果集采用第一个结果的属性名
- 缺省为自动去除重复元组，除非显示说明 `ALL`
- `Order By` 放在整个语句最后

#### 并操作

```sql
<查询块1>
UNION [ALL]
<查询块2>;
```

> [!note] 说明
> - 参加 `UNION` 操作的每个结果集列数必须相同，而且对应项的数据类型必须兼容。
> - 使用 `UNION` 合并多个结果集时，系统会自动去掉重复元组。
> - 如果需要保留重复元组，使用 `UNION ALL` 操作符。

## 数据更新

### 插入数据

两种插入数据方式：
- 插入单个元组
- 插入子查询结构

```sql
-- 插入单个元组
INSERT INTO <表名> [ <属性列1>,... ]
	VALUES (常量1, 常量2, ...);

-- 插入子查询结果
INSERT INTO <表名> [ <属性列1>,... ]
	<SELECT语句>;
```

> [!note] 参数
> - `INTO` 子句
> 	- 指定要插入数据的表名及属性列。
> 	- 属性列的顺序可以与表定义的顺序不一致。
> 	- 没有指定属性列，表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致。
> 	- 指定部分属性列：插入的元组在其余属性列上取空值。
> - `VALUES` 子句
> 	- 提供的值必须与 `INTO` 子句匹配，即值的顺序、类型和个数相同。
> - 子查询
> 	- `SELECT` 子句的目标列必须与 `INTO` 子句匹配。

### 修改数据

```sql
UPDATE <表名>
SET <列名1> = <表达式1> [, <列名2> = <表达式2> ]
[ WHERE <条件表达式> ];
```

> [!note] 参数
> - `SET` 子句：指定修改方式、修改的列与修改的值。
> - `WHERE` 子句：指定要修改的元组，缺省表示修改表中的所有元组。

#### 删除数据

```sql
DELETE FROM <表名>
[ WHERE <条件> ];
```

> [!note] 参数
> `WHERE` 子句指定要删除的元组，缺省表示删除表中所有元组。

> [!note] DBMS 在执行插入、修改、删除语句时会检查操作是否破坏表上已定义的完整性规则。

## 视图

视图可以被看作是一个虚拟表，它基于一个或多个基本表（或者其它视图）构建。在数据库的三层模式结构中，视图对应于外模式层次，专注于数据的逻辑表示而非物理存储。值得注意的是，数据库仅保存视图的定义，并不存储视图的数据副本，因此不会造成数据冗余。一旦基本表中的数据发生了变化，通过视图查询到的数据也会随之更新。

实际上，视图为用户提供了一个观察和操作数据的逻辑视角，使得用户能够对特定的数据集进行查询和执行某些更新操作。然而，对于视图的操作存在一定的限制条件，特别是更新操作，并非所有情况下都可行。

> [!note] 视图的定义是递归的，可以定义基于该视图的新视图。

### 建立视图

```sql
CREATE VIEW <视图名> [ <列名>, ... ]
AS <子查询>
[ WITH CHECK OPTION ];
```

> [!note] 参数
> - 子查询：可以是任意的 `SELECT` 语句，但通常不包含 `ORDER BY` 子句和 `DISTINCT` 短语。
> - 列名：组成视图的属性名可以全部缺省或全部指定。
> 	- 全部缺省：由 `SELECT` 目标列中的字段组成。
> 	- 全部指定：当列不是单纯的属性名，而是聚集函数或者列表达式时，或者需要再视图中为某个列启用新的名字时，可以进行指定。
> - `WITH CHECK OPTION` 选项：通过视图插入、删除或修改元组时检查元组是否满足视图定义中的条件，如果不满足则拒绝执行。

> [!example]
> 建立计算机系选修了 C2 课的学生学号、姓名、成绩的视图。
> ```sql
> CREATE VIEW CS_SC(Sno, Sname, Grade)
> AS SELECT Student.Sno, Sname, Grade
> FROM Student, SC
> WHERE Sdept='CS' AND Student.Sno=SC.Sno AND Cno='C2';
> ```

### 删除视图

```sql
DROP VIEW <视图名> [ CASCADE ];
```

> [!note] 参数
> 如果该视图还导出了其他视图，则使用 `CASCADE` 级联删除语句把该视图及由它导出的所有视图一起删除。

### 视图上的操作

从用户角度来看，与基本表一样，通过视图可以对数据库执行查询和更新操作。DBMS 实现视图查询有两种方法：
1. 视图实体化方法：执行有效性检查，检查所查询的视图是否存在。若视图存在，则执行视图定义，将视图临时实体化，生成临时表，并将查询视图的操作转换为查询临时表。查询完毕后删除被实体化的临时表。
2. 视图消解法：进行有效性检查，检查查询的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把视图定义的子查询与用户的查询结合起来，转换为等价的对基本表的查询。

> [!note] 视图消解法的局限
> 有些情况下，视图消解法不能生成正确查询，采用视图消解法的 DBMS 会限制这类查询。简单视图的消解总是能进行的，但含有聚集函数的视图消解可能会发生错误，只能采取对基表直接操作的方式。

> [!note] 视图的优点
> 1. 视图提供了一定程度的逻辑独立性
> 2. 简化了用户的操作，能更清晰地表达查询。
> 3. 使用户能以多种角度看待同一数据。
> 4. 提供了安全保护功能。

## SQL 的数据控制

SQL 的数据控制功能包括 [[00_Inbox/数据库/数据库的安全性|数据库的安全性]]，[[00_Inbox/数据库/数据库的完整性|数据库的完整性]]，[[00_Inbox/数据库/数据库恢复技术|数据库恢复技术]]，[[00_Inbox/数据库/数据库并发控制|数据库并发控制]]。这里介绍数据库安全性中对数据的存取权限控制语句。

### 授权

授权是指有授予权的用户将所拥有的权限授予其他用户。授权语句的格式为：
```sql
GRANT <权限1> [, <权限2> ... | ALL PRIVILIGES ]
ON <对象类型1> <对象名1> [, <对象类型2> <对象名2> ...]
TO <用户名1> [, <用户名2> ... | PUBLIC ]
[ WITH GRANT OPTION ];
```

> [!note] 参数
> 1. `WITH GRANT OPTION`：包含该参数时，被授权的用户还可以把获得的权限再授予其他用户。
> 2. 一个 `GRANT` 语句可以把多个权限同时授予其他用户。如果使用 `ALL PRIVILIGES` 代替权限，则表示授予全部权限。
> 3. 一个 `GRANT` 语句可以把相应权限同时授予多个用户。如果使用 `PUBLIC` 替换用户，则表示把权限授予所有数据库的用户。

### 权限回收

具有授予权的用户可通过回收语句将所授予的权限回收。回收语句的格式为：
```sql
REVOKE <权限1> [, <权限2> ... | ALL PRIVILIGES ]
ON <对象类型1> <对象名1> [, <对象类型2> <对象名2> ... ]
FROM <用户名1> [, <用户名2> ... | PUBLIC ]
[ RESTRICT | CASCADE ];
```

> [!note] 参数
> - `CASCADE`：回收权限时引起级联操作，即拥有授予权的用户如果把拥有的权限授予了其他用户，则要把转授出去的权限一起回收。
> - `RESTRICT`：只有用户没有将拥有的权限转授给其他用户时才能回收该用户的权限，否则系统将拒绝执行。

---
< [[00_Inbox/数据库/关系数据库|关系数据库]] | [[00_Inbox/数据库/查询处理和查询优化|查询处理和查询优化]] >
