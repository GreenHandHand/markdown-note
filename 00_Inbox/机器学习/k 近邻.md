---
aliases:
  - KNN
  - k nearest neighbor
tags:
  - 机器学习
  - 监督学习
---

# k 近邻

k 近邻法 (k-nearest neighbor, k-NN) 是一种基本分类与回归方法。K 近邻法的输入为实例的特征向量，对应于特征空间中的点，输出为实例的类别，可以取多类。k 近邻法假设给定一个训练数据集，其中的实例类别已定，对于新的数据，k 近邻法根据其 k 个最近邻的训练实例的类别，通过多数表决等方法进行预测。K 近邻法于 1968 年由 Cover 和 Hart 提出。

## k 近邻算法

对于给定的训练数据集
$$
T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}
$$
$x_i\in\mathcal X\subseteq R^n$ 为实例的特征向量，$y_i\in\mathcal Y=\{c_1,c_2,\cdots,c_K\}$ 为实例的类别。对于输入实例 $x$，k 近邻算法给出类别 $y$。算法的计算过程如下：
1. 根据给定的距离度量，在训练集中找出与 $x$ 最邻近的 $k$ 个点，涵盖这 $k$ 个点的 $x$ 的领域记为 $N_k(x)$。
2. 在 $N_k(x)$ 上更加分类决策规则（如多数表决）决定 $x$ 的类别和 $y$。即
$$
y=\arg\max_{c_j}\sum_{x_i\in N_k(x)}I(y_i=c_j)
$$
k 近邻算法的特殊情况为 k=1，此时称为最近邻算法。k 近邻算法没有显式的学习过程，即 k 近邻算法的学习仅仅是将训练数据储存下来。

## k 近邻模型

k 近邻法使用的模型实际上对应于对特征空间的划分，模由三个基本要素：距离度量、k 值的选择和分类决策规则决定。

### 模型

k 近邻法中，当训练集、距离度量、k 值以及分类决策规则确定后，对于任何一个新的输入实例，它所属的类别确定。这相当于根据上述要素将特征空间划分为了一些子空间，确定子空间里每个点所属的类。

特征空间中，对于每个实例 $x_i$，距离该点比其他更近的所有点组成了一个区域，被称为单元 (cell)，每个训练实例点拥有一个单元，所有训练实例点的单元组成了对特征空间的一个划分。

### 距离度量

特征空间中两个点的距离是两个实例点相似程度的反应。k 近邻模型的特征空间一般是 n 为实数向量空间 $R^n$，使用的距离是欧氏距离，但也可以是其他距离，如 $L_p$ 距离或者 Minkowski 距离。

$L_p$ 距离的定义为：
$$
L_p(x_i,x_j)=\left(\sum_{l=1}^n\vert x_i^{(l)}-x_j^{(l)}\vert^p\right)^{\frac{1}{p}}
$$
这里的 $p\geqslant 1$，当 $p=2$ 时，称为欧氏距离 (Euclidean distance)，即
$$
L_2(x_i,x_j)=\sqrt{\sum_{l=1}^n\vert x_i^{(l)}-x_j^{(l)}\vert^2}
$$
当 $p=1$ 时，称为曼哈顿距离 (Manhattan distance)，即
$$
L_1(x_i,x_j)=\sum_{l=1}^n\vert x_i^{(l)}-x_j^{(l)}\vert
$$
当 $p=\infty$ 时，它是各个坐标距离的最大值，即
$$
L_\infty(x_i,x_j)=\max_l\vert x_i^{(l)}-x_j^{(l)}\vert
$$
不同的距离度量所确定的最近邻点是不同的。

### k 值的选择

k 值的选择会对 k 近邻法的结果产生重大意义。
1. 如果选择较小的 k 值，学习的近似误差 (approximation eror) 会减小，只有与输入实例较近的训练实例才会对预测结果产生作用。但确定时学习的估计误差 (estimation error) 会增大，预测结果会对近邻的实例点非常敏感。如果近邻的实例点恰好是噪声，预测就会出错。换句话说，**k 值的减小就代表着整体模型变得复杂，容易发生过拟合**。
2. 较大的 k 值优点是可以减小学习的估计误差，但是缺点是近似误差会增大，这时与输入实例较远的训练实例也会对预测其作用，是预测发生错误。**k 值的增大就意味着整体的模型变得简单**。

在实际应用中，k 一般取一个较小的数值，通常采用 [[00_Inbox/实践知识/交叉验证|交叉验证]] 的方法来选取最优的 k 值。

### 分类决策规则

k 近邻法中的分类决策规则往往是多数表决，即有输入实例的 k 个近邻的训练实例多数类决定输入实例的类。

多数表决规则 (majority voting rule) 有如下解释：如果分类的损失函数为 0-1 损失函数，分类函数为：
$$
f:R^n\to\{c_1,c_2,\cdots, c_K\}
$$
那么误分类的概率是
$$
P(Y\ne f(X))=1-P(Y=f(X))
$$
对于给定的实例 $x\in\mathcal X$，其最近邻 k 个训练实例点构成集合 $N_k(x)$，如果涵盖 $N_k(x)$ 的区域类别时 $c_j$，那么误分类的概率为：
$$
\frac{1}{k}\sum_{x_i\in N_k(x)}I(y_i\ne c_j)=1-\frac{1}{k}\sum_{x_i\in N_k(x)}I(y_i=c_j)
$$
要是误分类率最小即经验风险最小化，就要使 $\frac{1}{k}\sum_{x_i\in N_k(x)}I(y_i=c_j)$ 最大，所以多数表决规则等价于经验风险最小化。

## k 近邻算法的实现：kd 树

实现 k 近邻算法，主要考虑的问题是如何对训练数据进行快速 k 近邻搜索，这点在特征空间维度大及数据容量大时尤其必要。最简单的实现方法是线性扫描 (linear scan)，但是当训练集很大时，计算非常耗时，这种方法是不可取的。下面介绍 kd 树 (kd tree) 方法。

### 构造 kd 平衡树

1. 构造根节点，节点对应包含 $T$ 的 k 维空间的超矩形区域
   选择 $x^{(1)}$ 为坐标轴，以 $T$ 中所有实例的 $x^{(1)}$ 坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。切分由通过切分点且与坐标轴 $x^{(1)}$ 垂直的超平面实现。由根节点生成深度为 1 的左、右子节点：左子节点对应坐标 $x^{(1)}$ 小于切分点的子区域，右子节点对应于坐标 $x^{(1)}$ 大于切分点的子区域。将落在切分超平面上的实例点保存在根节点。
2. 重复，对深度为 $j$ 的节点，选择 $x^{(l)}$ 为切分的坐标轴，$l=j(\mod k)+1$，以该结点的区域中所有实例 $x^{(l)}$ 坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标走 $x^{(l)}$ 垂直的超平面实现。由该结点生成深度为 $j+1$ 的左、右子节点：左子节点对应坐标 $x^{(l)}$ 小于切分点的子区域，右子节点对应坐标 $x^{(l)}$ 大于切分点的子区域。将落在切分超平面上的实例点保存在该节点。
3. 直到两个子区域中没有实例存在时停止。从而形成 kd 树的区域划分。

### 使用 kd 树进行 k 近邻搜索

1. 在 kd 树中找到包含目标点 $x$ 的叶节点：从根节点出发，递归地向下访问 kd 树，若目标点 $x$ 当前维的坐标小于切分点的坐标，则移动到左节点，否则移动到右节点。
2. 以此节点为当前最近点
3. 递归地向上回退，在每个节点进行以下操作：
	1. 如果该节点保存的实例比当前最近点距离目标的更近，则以该实例点为当前最近点
	2. 当前最近点一定存在与该节点一个子节点对应的区域。检查另一子节点对应的区域是否以目标点为球心，以目标点与当前最近点间的距离为半径的超球体相交。如果相交，可能在另一个子节点对应的区域内存在距目标点更近的点，移动到另一个子节点。接着递归的进行最近邻搜索。如果不相交，向上回退。
4. 当回退到根节点时，搜索结束，最后的当前最近点即为 $x$ 的最近邻点。

当实例点是随机分布时，kd 数搜索的平均时间复杂度为 $O(\log N)$，这里的 $N$ 数训练实例数。kd 树更适用于训练实例数远大于空间维度数时的 k 近邻搜索。当空间维度数接近训练实例数时，它的效率会迅速下降，几乎接近线性搜索。
