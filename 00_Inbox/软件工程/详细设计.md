---
tags:
  - 软件工程
---

# 详细设计

详细设计阶段的根本目标是确定应该怎样具体实现所要求的系统，也就是说，经过这个阶段的设计工作，因该得出对目标系统的精确描述，从而在编码阶段可以把这个描述直接翻译成某种程序设计语言书写的程序。

## 结构程序设计

结构程序设计的经典定义如下所述：如果一个程序的代码块仅仅通过顺序、选择和循环这 3 种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。

> [!tip] 实际上结构化程序设计本质上是一种使得程序代码容易阅读、容易理解的编程方法。

## 人机界面设计

人接界面设计是接口设计的一个重要的组成部分。对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。人机界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，因此，必须对人机界面设计给予足够重视。

在设计人机界面的过程中，几乎总会遇到下述 4 个问题：系统响应时间、用户帮助设施、出错信息处理和命令交互。不幸的是，许多设计者直到设计过程后期才开始考虑这些问题。最好在设计初期就把这些问题作为重要的设计问题来考虑，这是修改比较容易，代价也很低。下面讨论 4 个设计问题：
1. **系统响应时间**：系统响应时间有两个重要因素，分别是长度和易变性。
	- 长度：如果系统响应时间过程，用户就会感到紧张和沮丧。当用户工作速度由人机界面决定时，系统响应时间果断也不好，这会迫使用户加快操作节奏，从而可能会犯错误。
	- 易变性：指系统响应相对于平均响应时间的偏差。
2. **用户帮助设施**：几乎交互式系统的每个用户都需要帮助，当遇到复杂问题时甚至需要查看用户手册以寻找答案。具体设计帮助设施时，必须解决下述的一系列问题：
	1. 在用户与系统交互期间，是否在任何时候都能获取关于系统任何功能的帮助信息。
	2. 用户怎样请求帮助，例如帮助菜单、特殊功能键和 `HELP` 命令。
	3. 怎样显示帮助信息，例如在独立的窗口中，指出参考某个文档，和在屏幕固定位置显示简短提示。
	4. 用户怎样返回到正常的交互方式中，例如屏幕的返回按钮和功能键。
	5. 怎样组织帮助信息，例如平面结构，信息的层次结构和超文本结构。
3. **出错信息处理**：一般来说，交互式系统给出的出错信息或警告信息，应具有下述属性：
	1. 信息应该用用户可以理解的术语描述问题。
	2. 信息应该提供有助于从错误中恢复的建设性意见。
	3. 信息应该指出错误可能导致哪些负面后果，以便用户检查问题。
	4. 信息应该伴随着听觉或视觉上的提醒。
	5. 信息不能带有指责色彩。
4. **命令交互**：在提供命令行交互方式时，需要考虑下面的设计问题
	1. 是否每个菜单选项都有对应的命令。
	2. 采用何种命令形式，例如控制序列，功能键和键入命令。
	3. 学习和记忆命令的难度有多大？忘记命令了怎么办？
	4. 用户是否可以定制或缩写命令。

## 过程设计工具

描述程序处理过程的工具称为过程设计工具，它们可以分为图形，表格和语言 3 类。不论哪类，对它们的基本要求都是能提供对涉及的无歧义的描述。

### 程序流程图

程序流程图又称为程序框图，是历史最悠久，使用最广泛的描述过程设计的方法，然而它也是用得最混乱的一种方法。

> [!note] 程序流程图的缺点
> 1. 程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。
> 2. 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。
> 3. 程序流程图不易表示数据结构。

### 盒图

盒图 (N-S) 具有以下特点：
1. 功能域明确，可以从盒图上一眼看出来。
2. 不可能任意转移控制。
3. 很容易确定局部和全程数据的作用域。
4. 很容易表示嵌套关系，也可以表示模块的层次结构。

> [!example]- 盒图
> ![[Assets/详细设计-1.png]]

### PAD 图

PAD 是问题分析图 (problem analysis diagram) 的英文缩写。它用为二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。

> [!note] PAD 图的优点
> 1. 使用你表示结构化控制结构的 PAD 符号所设计出来的程序比如是结构化程序。
> 2. PAD 图所描绘的程序结构十分清晰。每增加一个层次，图形向右拓展一条竖线。PAD 图中的竖线的总条数就是程序的层次数。
> 3. 用 PAD 图表现程序逻辑，易读，易懂，易记。
> 4. 容易将 PAD 图转换成高级语言源程序，这种转换可以由软件工具自动完成。
> 5. 既可以用于表示程序逻辑，也可以用于描述数据结构。
> 6. PAD 图的符号支持自顶向下，逐步求精方法的使用。

> [!example]- PAD 图
> ![[Assets/详细设计-2.png]]

### 判定表与判定树

当算法中包含多重嵌套的条件选择时，使用程序流程图、盒图、PAD 图都不易清晰描述。判定表是用于表示复杂的条件组合与应做的动作之间的对应关系。

判定表虽然能够清晰表示复杂的条件组合与应做的动作之间的对应关系，但其含义却不是一眼就能看出来的。判定树是判定表的变种，它的优点在于，它的形式简单到不需任何说明，一眼就可以看出其含义。

> [!example]- 判定表与判定树
> ```image-layout-c
> ![[image/详细设计-4.png]]
> ![[image/详细设计-3.png]]
> ```

### 过程设计语言

过程设计语言 PDL 也称为伪代码，是一个笼统的名称。PDL 应该具有以下特点：
1. 关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。
2. 自然语言的自由语法，它描述处理特点。
3. 数据说明的手段。
4. 模块定义和调用的结束，应该提供各种接口描述模式。

> [!note] PDL 的优点
> 1. 可以作为注释直接插在源程序中间。
> 2. 可以使用普通的正文编译程序或文字处理系统，很方便地完成 PDL 的书写和编辑工作。
> 3. 已经有了自动处理 PDL 的程序存在，而且可以自动由 PDL 生成程序代码。

## 面向数据结构的设计方法

计算机软件本质上是信息处理系统，因此，可以根据软件所处理的信息的特征来设计软件。面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。这种设计方法并不明显地使用软件结构的概念，模块是设计过程的副产品，对于模块独立原理也没有予以应有的重视，因此，这种方法最适合于在详细设计阶段使用，也就是说，在完成了软件结构设计之后，可以使用面向数据结构的方法来设计每个模块的处理过程。

### Jackson 图

略

## 程序复杂程度的定量度量

定量度量程序复杂程度的方法很有价值，把程序的复杂程度乘以适当常数就可以估算出软件中错误的数量以及软件开发需要用的工作量，定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣。程序的定量的复杂程度可以作为模块规模的精确限度。

### McCabe 方法

McCabe 方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。为了突出表示程序的控制流，人们通常使用**流图**。所谓流图实质上是退化了的程序流程图，它仅仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。

环形复杂度定量度量程序的逻辑复杂度。有了描绘程序控制流的流图之后，可以用下述三种方法中任何一种来计算环形复杂度：
1. 流图中线性无关区域数等于环形复杂度。
2. 流图 $G$ 的环形复杂度 $V(G)=E-N+2$，其中 $E$ 是流图中边的条数，$N$ 是节点数。
3. 流图 $G$ 的环形复杂度 $V(G)=P+1$，其中 $P$ 是流图中判定节点的数目。

> [!note] 环形复杂度的用途
> 程序的环形复杂度取决于程序控制流的复杂度，即取决于程序结构的复杂程度。当程序内分支数或循环个数增加时，环形复杂度也随之增加，因此它是对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。McCabe 研究大量程序后发现，环形复杂度高的程序往往是最困难，最容易出现问题的程序。
>
> 实践表明，模块规模以 $V(G)\leqslant 10$ 为宜。

### Halstead 方法

Halstead 方法是另一个著名的方法，它根据程序中运算符和操作数的总数来度量程序的复杂程度。令 $N_{1}$ 为程序中运算符出现的总次数，$N_{2}$ 为操作数出现的总次数，程序长度 $N$ 定义为
$$
N=N_{1}+N_{2}
$$

详细设计完成之后，可以指导程序中使用的不同运算符 (包括关键字) 的个数 $n_{1}$ 以及不同操作数 (变量和常数) 的个数 $n_{2}$。Halstead 给出预测程序长度的公式如下：
$$
H=n_{1}\log_{2}n_{1}+n_{1}\log_{2}n_{2}
$$

Halstead 还给出了预测程序中包含错误的个数的公式如下：
$$
E=N\log_{2}(n_{1}+n_{2})/3000
$$

---
< [[00_Inbox/软件工程/总体设计|总体设计]] | [[00_Inbox/软件工程/实现|实现]] >
