---
tags:
  - 软件工程
---

# 面向对象方法学

面向对象方法学所提供的**对象**概念，是让软件开发者自己定义或选取解空间对象，然后把软件系统作为一系列离散的解空间对象的集合。应该使这些解空间对象与问题空间对象尽可能一致。这些解空间对象彼此间通过发送消息而互相作用，从而得出问题的解。

也就是说，面向对象方法是一种新的思维方法，它不是把程序看做工作在数据上的一系列过程或函数的集合，而是**把程序看做互相协作而又彼此独立的对象的集合**。每个对象就是一个微型程序，有自己的数据、操作、功能和目的。这样做就向着减少语义断层方面迈了一大步，在许多系统中解空间对象都可以直接模拟问题空间的对象，解空间与问题空间的结构十分一致。因此，这样的程序易于理解和维护。

概括的说，面向对象方法具有下述特点：
1. 认为客观世界使由各种对象组成，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成。
2. 把所有对象都划分为各种**对象类**，对每个对象类都定义了一组数据和一组方法。
	- 数据：用于表示对象的静态属性，是对象的状态信息。
	- 方法：是允许施加于该类对象上的操作，是该类所有对象共享的，并不需要为每个对象都复制操作的代码。
3. 按照子类与父类的关系，把若干个对象类组成一个层次结构的系统。在这种层次结构中，通常下层的派生类自动具有和上层的基类相同的特性，这种现象叫做**继承**。
4. 对象彼此之间仅能通过消息传递互相联系。

> [!note]
> - 如果仅使用对象和消息，则这种方法可以称为基于对象 (object-based) 方法，而不能称为面向对象的方法。
> - 如果进一步要求把所有对象都划分为类，则这种方法可称为基于类 (class-based) 的方法，但是仍然不是面向对象方法。
> - 只有同时使用对象，类，继承和消息的方法，才是真正面向对象的方法。

> [!note] 面向对象方法学的优点
> 1. **与人类习惯的思维方法一致**：面向对象的软件技术为开发者提供了随着对某个应用系统的认识逐步深入和具体化的过程，而逐步设计和实现该系统的可能性，因为可以先设计出抽象类构成的系统框架，随着认识深入和具体化再派生出更具体的派生类。
> 2. **稳定性好**：因为面向对象的软件系统的结构是根据问题领域的模型建立起来的，而不是基于对系统应完成的功能的分解，所以，当对系统的功能需求变化时并不会引起软件结构的整体变化，往往仅需要作一些局部性的修改。
> 3. **可重用性好**：用已有的零部件装配新的产品，是典型的重用技术。
> 4. **较易开发大型软件产品**：用面向对象方法学开发软件时，可以把一个大型软件产品分解为一系列本质上相互独立的小产品来处理，这不仅降低了开发的技术难度，而且也使得对开发工作的管理变得容易得多。
> 5. **可维护性好**：由于下面因素的存在，使得用面向对象方法所开发的软件可维护性好：
> 	- 面向对象的软件稳定性比较好。
> 	- 面向对象的软件比较容易修改。
> 	- 面向对象的关键比较容易理解。
> 	- 易于测试和调试。

## 面向对象概念

### 对象

由于客观世界中的实体通常都既有静态的属性，又有动态的行为，因此，面向对象方法学中的对象是由描述该对象属性的数据以及可以对这些数据施加的所有操作封装在一起构成的统一体。对象可以作的操作表示它的动态行为，在面向对象分析和面向对象设计中，通常把对象的操作方法称为服务或方法。

目前，对对象所下的定义并不完全同意，人们从不同角度给出对象的不同定义。这些定义虽然形式不同，但是基本含义是相同。

> [!definition|Definition] 对象
> 对象 (object) 是具有相同状态的一组操作的集合。

> [!note] 对象的特点
> 1. 以数据为中心：操作围绕对其数据所需要做的处理来设置，不设置与这些数据无关的操作，而且操作的结果往往与当时所处的状态有关。
> 2. 对象是主动的：对象与传统的数据有本质区别，不是被动地等待对它进行处理，相反，它是处理的主体。
> 3. 实现了数据封装。对象好像一只黑盒子，它的私有数据完全被封装在盒子内部，对外是隐藏的，不可见的，对私有数据的访问或处理只能通过公有的操作进行。
> 4. 本质上具有并行性：不同对象各自独立地处理自身的数据，彼此通过发消息传递信息完成通信。
> 5. 模块独立性好：对象是面向对象软件的基本模块，为了充分发挥模块化简化开发的优点，希望模块的独立性强。由于完成对象功能所需要的元素基本都被封装在对象内部，它与外界的联系自然就比较少，因此，对象之间的耦合通常比较松。

### 类

> [!definition|Definition] 类
> 类 (class) 是支持继承的抽象数据类型，而对象就是类的实例。

在面向对象的软件技术中，类就是对具有相同数据和相同操作的一组相似对象的定义。也就是说，类是对具有相同属性和行为的一个或多个对象的描述。通常在这种描述中也包括对怎样创建该类的新对象的说明。

> [!note] 实例
> **实例**(instance) 就是由某个特定的类描述的一个具体的对象。当使用对象这个术语时，既可以指定一个具体的对象，也可以泛指一般的对象。但是当使用实例这个术语时，必然是指一个具体的对象。

> [!note] 消息
> **消息**(message) 就是要求某个对象执行定义在它的那个类中所定义的某个操作的规格说明。通常，一个消息由下述 3 部分组成：
> - 接受消息的对象。
> - 消息选择符 (也称为消息名)。
> - 零个或多个变元。

> [!note] 方法
> 方法 (method) 就是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法。在 c++ 中称为成员函数。

> [!note] 属性
> 属性 (attribute) 就是类中所定义的数据，它是对客观世界实体所具有的性质的抽象。类的每个实例都有自己特有的属性值。

### 封装

从字面意思上来看，封装就是把某个事物包裹起来，使外界不知道该事物的具体内容。

在面向对象的程序中，把数据和实现操作的代码集中起来放在对象内部。使用一个对象的事后，只需要知道它向外界提供的接口形式，无须知道它的数据结构细节和实现操作的算法。综上所述，对象具有**封装**(encapsulation) 性的条件如下：
1. 有一个清晰的边界。所有私有数据和实现操作的代码都被封装在这个边界内，从外面看不见更不能直接访问。
2. 有确定的接口 (协议)。这些接口就是对象可以接受的消息，只能通过向对象发送消息来使用它。
3. 受保护的内部实现。实现对象功能的细节不能在定义该对象的类的范围外访问。

### 继承

广义地说，继承是指能够直接获得已有的性质和特征，而不必重复定义它们。在面向对象的软件技术中，**继承**(inheritance) 是子类自动地共享基类中定义的数据和方法的机制。

一个类的上层可以有父类，下层可以有子类。这种层次结构系统的一个重要性质是继承性，一个类直接继承其父类的全部描述。

继承具有传递性，如果类 C 继承类 B，类 B 继承类 A，则类 C 继承类 A。因此，一个类实际上继承了它所在的类等级中在它上层的全部基类的所有描述。也就是说，属于某类的对象除了具有该类所描述的性质外，还具有类等级中该类上层全部基类描述的一切性质。

> [!note] 多重继承
> 当一个类只允许有一个父类时，类的继承是单继承。当允许一个类有多个父类时，类的继承是多重继承。多重继承的类可以组合多个父类的性质构成所需要的性质，因此功能更强、使用更方便。但是，使用多重继承时要注意避免二义性。

### 多态

在面向对象的软件技术中，**多态**(polymorphism) 是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。

在类等级的不同层次中可以共享一个行为的名字，然而在不同层次中的每个类却各自按照自己的需要来实现这个行为。当对象接收到发送给它的消息时，根据该对象所属于的类动态选用在该类中定义的实现算法。

> [!note] 虚函数
> 在 C++ 语言中，多态性是通过虚函数来实现的。在类等级不同层次中可以说明名字，参数特征和返回值特征都相同的虚拟成员函数，而在不同层次的类中的虚函数实现算法各不相同。虚函数机制使得程序员能在一个类等级中使用相同函数的多个不同版本，在运行时刻才根据接受消息的对象所属于的类，决定到底执行哪个版本，这称为**动态联编**，也叫滞后联编。

### 重载

有两种**重载** (overloading)：
- 函数重载：指在同一作用域的若干个参数特征不同的函数可以使用相同的函数名字。
- 运算符重载：当参数特征不同或被操作数的类型不同时，实现函数的算法或运算符的语义是不同的。

> [!note]
> 在 C++ 语言中函数重载是通过**静态联编**实现的，也就是在编译时根据函数变元的个数和类型，决定到底使用函数的哪个实现代码。对于重载的运算符，同样是在编译时根据被操作数的类型，决定使用该运算符的哪种语义。

## 面向对象建模

通常，使用 UML 提供的类图来建立对象模型。在 UML 中术语类的事迹含义是，一个类及属于该类的对象。下面简单介绍 UML 的类图。

### 类图的基本符号

类图描述类与类之间的静态关系。类图是一种静态模型，它是创建其他 UML 图的基础。一个系统可以由多张类图来描述，一个类也可以出现在几张类图中。
1. 定义类：UML 中类的图形符号为长方形，用两条横线将长方形分为上中下 3 个区域，分别放置类的名字、属性、方法。
2. 定义属性：UML 描述属性的语法格式为：`可见性 属性名: 类型名 = 初值{性质串}`。
	- 属性的可见性有公有的 (public, `+`)，私有的 (private, `-`) 和保护的 (protected,`#`)。
	- 类型名表示该属性的类型，可以是基本数据类型，也可以是用户自定义类型。
	- 在创建类实例时应该给其属性赋值。
	- 用花括号括起来的性质串明确列出了该属性的所有可能的取值，常用于枚举类型。
	- 类的属性还可以由一种能别该类所有对象共享的属性，称为**类的作用域属性**，也称为**类变量**。在类图中表现为带下划线的属性。
3. 定义方法：UML 描述操作的语法格式为：`可见性 方法名(参数表): 返回值类型{性质串}`。
	- 参数表是一个用逗号分隔的形式参数序列，描述语法为 `类型名=默认值`。
	- 与属性类似，在类中也可以定义作用域操作，在类图中表示为带下划线的操作。这种操作只能存取本类的类作用域属性。

> [!note] 类名
> 类名是一类对象的名字，命名是否恰当对系统的可理解性影响相当大。因此，命名类时需要遵守以下规则：
> 1. 使用标准术语。应该使用在应用领域中人们习惯的标准术语创建类名。
> 2. 使用具有确切含义的名词。
> 3. 必要时用名词短语作为名字。

### 表示关系的符号

类与类之间通常由关联、泛化 (继承)、依赖和细化 4 种关系。

#### 关联

关联表示两个类的对象之间存在某种语义上的联系。
1. 普通关联：普通关联是最常见的关联联系，只要在类与类之间存在连接关系就可以用普通关联表示。普通关联的图示符号是连接两个类之间的直线。
2. 关联的角色：在任何关联中都会涉及参与此关联的对象所扮演的角色，在某些情况下显示标明角色名有助于别人理解类图。
3. 限定关联：限定关联通常用在一对多或多对多的关联关系中，可以把模型中的重数从一对多变为一对一，或从多对多简化为多对一。在类图中，把限定词放在关联关系末端的一个小方块内。
4. 关联类：为了说明关联的性质，可能需要一些附加信息。可以引入一个关联类来记录这些信息。关联中的每个连接与关联类的一个对象相联系。关联类通过一条虚线与关联连接，与一般的类一样，也有属性、操作和关联。

> [!note] 重数
> 在表示关联的直线两端可以写上重数 (multiplicity)，它表示该类有多少个对象与对方的一个对象连接。重数的表示方法通常有：
> - `0..1`：表示 0 到 1 个对象。
> - `0..*` 或 `*`：表示 0 到多个对象。
> - `1+` 或 `1..*`：表示 1 到多个对象。
> - `1..15`：表示 1 到 15 个对象
> - `3`：表示 3 个对象。

> [!example]- 普通关联
> ![[Assets/面向对象方法学-1.png]]

> [!example]- 递归关联 (标明角色)
> ![[Assets/面向对象方法学-2.png]]

> [!example]- 受限关联
> ![[Assets/面向对象方法学-3.png]]

> [!example]- 关联类
> ![[Assets/面向对象方法学-4.png]]

#### 聚集

聚集也称为集合，是关联的特例。聚集表示类与类之间的关系是整体和部分的关系。在陈述时使用包含、组成、分为等字句往往意味着存在聚集关系。除了一般的聚集外，还有两种特殊的聚集关系：
1. 共享聚集：如果在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的构成，则该聚集称为共享聚集。一般聚集和共享聚集图示相同，都是在表示关联关系的只写末端紧挨着整体类的地方画一个空心菱形。
2. 组合聚集：如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失，则该聚集称为组成聚集。组合聚集使用实心菱形表示。

> [!example]- 共享聚集和一般聚集
> ![[Assets/面向对象方法学-5.png]]

> [!example]- 组合聚集
> ![[Assets/面向对象方法学-6.png]]

#### 泛化

UML 中的返回关系就是通常所说的继承关系。具体元素完全拥有通用元素的信息，并且还可以附加一些其他信息。在 UML 中，用一端为空心三角形的连线表示泛化关系，三角形的顶角紧挨着通用元素。
1. 普通泛化。
2. 受限泛化：可以给泛化关系附加约束条件，进一步说明该泛化关系的使用方法或扩充方法，这样的泛化关系称为受限泛化。预定义的约束有 4 种：多重、不相交、完全和不完全。
	- 多重继承：一个子类可以同时多次继承同一个上层基类。
	- 不相交继承：一个子类不能多次继承同一个基类。
	- 完全继承：父类的所有子类都已经在类图中穷举出来了。
	- 不完全继承：父类的子类没有都穷举出来，随着对问题理解的深入，可不断补充和维护。

> [!note] 抽象类
> 没有具体对象的类称为抽象类。抽象类通常作为父类，用于描述其他子类的公共属性和行为。抽象类通常都有抽象操作，抽象操作仅用来指定该类的所有子类应该具有哪些行为。抽象类与抽象方法的图示都是在操作标记后跟随一个性质串 `{abstract}`。

> [!example]- 抽象类
> ![[Assets/面向对象方法学-7.png]]

> [!example]- 多重继承
> ![[Assets/面向对象方法学-8.png]]

#### 依赖和细化

**依赖关系**描述两个模型元素之间的语义连接关系：其中一个模型元素是独立的，另一个模型元素不是独立的，它依赖于独立的模型元素。如果独立的模型元素改变了，将影响依赖于它的模型元素。

在 UML 的类图中，使用带箭头的虚线连接两个有依赖关系的类，箭头指向独立的类。

> [!example]- 依赖
> ![[Assets/面向对象方法学-9.png]]

当对同一个事物在不同抽象层次上描述时，这些描述之间具有**细化关系**。假设两个模型元素 A 和 B 描述同一个事物，它们的区别是抽象层次不同。如果 B 是在 A 的基础上的更详细的描述，称 B 细化了 A，或者 A 细化成了 B。

在 UML 的类图中，使用一端为空心三角形的虚线描述细化关系。

> [!example]- 细化
> ![[Assets/面向对象方法学-10.png]]

## 动态模型

动态模型表示瞬时的、行为化的系统的控制性质，它规定了对象模型的对象的合法变化序列。

一旦建立起对象模型之后，就需要考察对象的动态行为。所有对象都具有自己的声明周期，对一个对象来说，生命周期由许多阶段组成，在每个特定阶段中，都有适合该对象的一组运行规律和行为规则，用以规范该对象的行为。生命周期中的阶段也就是对象的状态。

所谓状态，是对对象属性值的一种抽象。各对象之间相互触发就形成了一系列的状态变化。人们把一个触发行为称作一个事件。对象对事件的响应，取决于接受该触发的对象时所处的状态，响应包括改变自己的状态或者又形成一个新的触发行为。

通常使用 UML 提供的状态图来描绘对象的状态、触发状态转换的事件以及对象的行为。每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型。也就是说，动态模型是基于事件共享而互相关联的一组状态图的集合。

## 功能模型

功能模式表示变化的系统的功能性质，指明系统应该做什么，因此更直接地反映了用户对目标系统的需求。

通常，功能模型由一组数据流图组成。在面向对象方法学中，数据流图远不如在结构分析、设计方法中那样重要。UML 提供的用例图也是进行需求分析和建立功能模型的强有力的工具。在 UML 中把用例图建立起来的系统模型称为用例模型。

### 用例图

一幅用例图包含的模型元素有系统、行为者、用例以及用例之间的关系。
1. **系统**：系统被看做一个提供用例的黑盒子，内部如何工作、用例如何实现，这些对于建立用例模型来说都不重要。代表系统的方框表示系统的边界，用于划定系统的功能范围，定义了系统所具有的功能。描述该系统功能的用例置于方框内，代表外部实体的行为置于方框外。
2. **用例**：一个用例是可以被行为者感受到、系统的一个完整的**功能**。在 UML 中把用例定义成系统完成的一系列动作，动作的结果能被特定的行为者察觉到。这些动作除了完成系统内部的计算与工作外，还包括一些行为者的通信。用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互。
3. **行为者**：行为者是指**与系统交互的人或其他系统**，它代表外部实体。使用用例并且与系统交互的任何人或物都是行为者。
4. **用例之间的关系**：UML 用例之间主要有扩展和使用两种关系，它们是泛化关系的两种形式。
	- 扩展关系：向前一个用例中添加一些动作后构成另一个用例，这两个用例之间的关系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用例。
	- 使用关系：当一个用例使用另一个用例时，两个用例之间就构成了使用关系。

### 用例建模

几乎在任何情况下都需要使用用例，通过用例可以获取用户需求，规划和控制项目。获取用例时需求分析阶段的主要工作之一，而且是首先要做的工作。大部分用例将在项目的需求分析阶段产生，并且随着开发工作的深入还会发现更多用例，这些新发现的用例都应及时补充进已有的用例集中。

> [!note] 用例集中的每个用例都是对系统的一个潜在需求。

一个用例模型由若干幅用例图组成。创建用例模型的工作包括：
1. **寻找行为者**：为获取用例首先要找出系统的行为者，可以通过请系统的用户回答一些问题的办法来发现行为者。例如：
	- 谁将使用系统的主要功能 (主行为者)？
	- 谁需要借助系统的支持来完成日常工作？
	- 谁来维护和管理系统 (幅行为者)？
	- 系统控制哪些硬件设备？
	- 系统需要与哪些其他系统交互？
	- 哪些人或系统对本系统产生的结果感兴趣？
2. **寻找用例**：一旦找到了行为者，就可以通过请每个行为者回答下述问题来获取用例。
	- 行为者需要系统提供哪些功能？行为者自身需要做什么？
	- 行为者是否需要读取、创建、删除、修改或存储系统中的某类信息？
	- 系统中发生的事件需要通知行为者吗？行为者需要通知系统某些事情吗？从功能的观点看，这些事件能做什么？
	- 行为者的日常工作是否因为系统的新功能而被简化或提高效率？
	- 系统需要哪些输入输出？输入来自哪？输出到哪去？
	- 当前使用的系统存在的主要问题是什么？

> [!note] 三种模型之间的关系
> 面向对象建模技术所建立的三种模型，分别从 3 个不同侧面描述了所要开发的系统。
> - 功能模型指明了系统应该做什么。
> - 动态模型明确规定了什么时候做。
> - 对象模型则定义了做事情的实体。
>
> 在面向对象方法学中，对象模式是最基本最重要的，它为其他两种模型奠定了基础，人们依靠对象模型完成 3 中模型的集成。下面扼要地叙述了 3 种模型之间的关系：
> 1. 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。
> 2. 状态转换驱使行为发生，这行为在数据流图中被映射为处理，在用例图中被映射为用例，它们同时与类图中的方法相对应。
> 3. 功能模型中的处理对应于对象模型中类所提供的方法。
> 4. 数据流图中的数据存储，以及数据的源点、终点，通常是对象模型中的对象。
> 5. 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。
> 6. 用例图中的行为，可能是对象模型中的对象。
> 7. 功能模型中的处理可能产生动态模型中的事件。
> 8. 对象模型描述了数据流图中的数据流、数据存储以及数据源点、终点的结构。

---
< [[00-笔记/软件工程/维护|维护]] | [[00-笔记/软件工程/面向对象分析|面向对象分析]] >
