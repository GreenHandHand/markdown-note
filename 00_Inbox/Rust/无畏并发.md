---
tags:
  - Rust
---

# 无畏并发

安全且高效地处理并发编程是 Rust 的另一个主要目标。**并发编程** (*Concurrent programming*)，代表程序的不同部分相互独立地执行，而**并行编程** (*parallel programming*) 代表程序不同部分同时执行，这两个概念随着计算机越来越多的利用多处理器的优势而显得愈发重要。由于历史原因，在此类上下文中编程一直是困难且容易出错的：Rust 希望能改变这一现状。

## 多线程

 因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这种不确定性会导致一系列复杂且难以处理的问题，尤其是在多线程编程中，这些问题可能会对程序的正确性和性能造成严重影响。以下是几个典型问题及其具体表现：
- [[02_Areas/操作系统/操作系统基本原理概论#异步|竞态条件]] (*Race conditions*): 多个线程以不一致的顺序访问数据或资源。
- [[02_Areas/操作系统/进程管理#死锁|死锁]] (*Deadlocks*): 两个线程互相等待对方资源，导致两者都无法运行。
- **难以重现和修复的 bug**: 多线程程序中的某些问题只会发生在特定的执行条件下，例如特定的输入数据、系统负载或线程调度顺序。这些 bug 往往具有高度的随机性，可能在开发环境中无法复现，但在生产环境中却频繁出现。这使得它们的诊断和修复变得极为复杂。

Rust 尝试减轻使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，同时其所要求的代码结构也不同于运行于单线程的程序。

> [!note]
> 标准库中的 `std::thread` 提供了线程的创建与管理操作。Rust 实现的线程是 [[02_Areas/操作系统/进程管理#多线程模型|一对一模型]]。如果需要实现更高效的并发模型，例如一个系统级线程对应多个用户级线程（M:N 模型），可以在 [crates.io](https://crates.io/) 中寻找相关的第三方库，

### 创建线程

Rust 中使用 `std::thread` 进行线程操作，并提供了一些线程的常用操作。
- 使用 `thread::spawn(fn)` 创建一个线程，其中 `fn` 是一个实现了 `FnOnce` 的 [[00_Inbox/Rust/函数式特性#Fn trait|函数]]。该函数返回一个 `JoinHandle` 类型，负责管理这个线程的资源。
- 使用 `JoinHandle.join()` 方法来阻塞一个线程，直到对应的线程执行完毕。该方法返回一个 `Result` 对象。

```rust
use std::thread;
use std::time::Duration;

fn main() {
	// 创建了一个线程
	let handle = thread::spawn(|| {
		for i in 0..10 {
			println!("Thread says {i}.");
            thread::sleep(Duration::from_secs(1));
		}
	});

	handle.join().unwarp();
}
```

> [!note] `join` 方法的返回值
> 对于某些错误，线程可能直接终止，此时会链式调用主线程的 `panic!` 并退出执行。如果子线程发生了 `panic!` 且没有终止程序，那么就会返回一个 `Err` 并附带终止信息。

### 传递资源

`move` 修饰的闭包经常用于 `thread::spawn` 创建的线程中。考虑下面的情景：

```rust
use std::thread;

fn main() {
	let v = !vec[1, 2, 3];
	let handle = thread::spawn(|| {
		println!("{v:?}"); // 编译器推断为 &v
	}); // Error!
	
	drop(v); // 由于线程是异步执行的
			 // 这里有两种可能性，但是编译器不知道是哪一种
	handle.join().unwarp();
}
```

如果 Rust 允许这段代码运行，则新建线程可能会立刻被转移到后台并完全没有机会运行。新建线程内部有一个 `v` 的引用，当执行 `drop` 函数后，`v` 将被丢弃，此时闭包中的引用就变成了悬垂引用。

正确的方式是显示地声明闭包是所有权捕获的，即使用 `move` 关键词修饰。

```rust
use std::thread;

fn main() {
	let v = !vec[1, 2, 3];
	let handle = thread::spawn(move || {
		println!("{v:?}"); // 移动所有权
	});
	
	// drop(v); // v 的所有权被移动，这里无法再使用 v
	handle.join().unwarp();
}
```

> [!tip]
> `move` 关键字覆盖了 Rust 默认保守的借用，但它不允许我们违反所有权规则。

> [!note] 生命周期与线程安全
> 查看 `std::thread::spawn` 函数的定义可以发现，它要求闭包所捕获的变量必须满足 `'static` 生命周期。这意味着：如果不在闭包前使用 `move` 关键字将变量的所有权转移进线程，则几乎无法安全地从外部环境中捕获任何变量。
>
> 这一限制源于线程可能执行的时间长度不确定，编译器无法保证外部变量在子线程运行期间仍然有效。因此，`Rust` 强制要求这些变量具有 `'static` 生命周期，以确保内存安全。
>
> 针对这一限制，主要有两种解决方案：
> - 显式创建 `'static` 生命周期的数据<br>可以手动声明全局静态变量（`'static`），或者通过 `Box::leak` 将数据“泄露”为 `'static` 生命周期。虽然这种方法在技术上可行，但并不推荐作为常规手段使用，因为它会带来资源管理上的负担，甚至造成内存泄漏。
> - 使用 `thread::scope` 创建线程作用域<br>Rust 1.63+ 提供了 `std::thread::scope` 函数来创建一个线程的作用域（Scope）。该方法允许在线程闭包中安全地引用局部变量，只要这些变量在作用域结束前仍然有效。换句话说，`Scope::spawn` 方法不要求被捕获的变量具有 `'static` 生命周期，而只需要它们在作用域生命周期内有效。 这种方式既安全又实用，是编写多线程程序时推荐的做法，尤其适用于需要跨线程共享临时数据的场景。

## 消息传递

[[02_Areas/操作系统/进程管理#消息传递|消息传递]] (*message passing*) 是一种确保安全并发的沟通方式，广泛应用于多线程编程中。通过消息传递，线程之间可以避免直接共享内存，从而显著减少数据竞争和死锁的风险。这种机制的核心思想是将数据的所有权从一个线程转移到另一个线程，从而保证在任何时刻只有一个线程能够访问该数据。

为了实现消息传递并发，Rust 标准库提供了一个**信道**^[信道是一个通用编程概念，表示数据从一个线程发送到另一个线程。]（*channel*）实现。信道由两个关键部分组成：
- **发送端** (*transmitter*)：发送端负责将数据发送到信道中。
- **接收端** (*receiver*)：接收端负责从信道中读取数据。

当发送端或接收端任一被丢弃时，可以认为信道被**关闭** (*closed*) 了。我们使用 `std::sync::mpsc` 中的方法来创建一个信道。其中 `mpsc` 是 *multiple producer, single consumer* 的缩写，表示 [[02_Areas/操作系统/进程管理#生产者消费者问题|多生产者，单消费者]]。这意味着多个线程可以同时向同一个信道发送数据，但只有一个线程可以从信道中接收数据。这种设计非常适合需要集中处理来自多个来源的数据的场景，例如日志收集系统或任务调度器。

Rust 中一个简单的信道的例子如下：

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        // 我们将 tx 转移到线程中以实现发送消息
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

> [!note] 由于历史原因，我们使用 `tx` 表示发送端，使用 `rx` 表示接收端。
> - 对于 `tx`，我们可以通过 `clone()` 方法来创建多个生产者，并通过 `send()` 方法发送消息。
> 	- 例如，如果有多个线程需要向同一个信道发送数据，可以通过克隆发送端来实现。这种方式非常适合分布式任务处理场景，比如多个传感器线程将数据发送到一个中央处理器线程。
> - 对于 `rx`，我们可以通过 `recv()` 方法接收消息。
> 	- 接收端通常在一个单独的线程中运行，用于处理来自多个生产者的消息。例如，在一个实时监控系统中，接收端可以不断读取来自不同传感器的数据并进行分析。

> [!note] `send` 的返回值
> `send` 返回一个 `Result`
> - 如果发送成功，则返回一个 `Ok(())`，表示消息已成功发送到信道中。
> - 如果发送失败 (例如接收方已经被丢弃了)，返回一个 `Err` 并返回错误。这种情况通常发生在接收端线程提前退出时，导致信道被关闭。例如，如果接收端线程因为某种异常终止，发送端尝试发送消息时会收到一个错误提示，这有助于开发者快速定位问题。

> [!note] 接收消息
> Rust 中使用三种方式接收消息：
> - `recv()`：阻塞进程直到接收到消息，返回 `Result`。当发送方关闭，则返回一个 `Err` 表示不会再有值到来。这种方式适用于需要等待消息的场景，例如等待用户输入或外部事件触发。
> - `try_recv()`：不会立即阻塞，而是直接返回一个 `Result`，如果有消息，则返回一个 `Ok` 并包含对应的值；如果没有消息，则返回一个 `Err` 表示此时没有任何消息。这种方式适用于非阻塞的轮询场景，例如定期检查是否有新任务到达。
> - 迭代器：我们还可以将 `rx` 视为一个迭代器，这将不断调用 `recv()` 方法直到得到一个 `Err`。这种方式非常适合处理连续的消息流，例如日志系统或事件驱动的应用程序。例如，在一个实时聊天应用中，接收端可以持续监听新消息并将其显示给用户。

> [!tip] 我们的并发错误会造成一个编译时错误。
> `send` 函数获取其参数的所有权并移动这个值归接收端所有。这可以防止在发送后意外地再次使用这个值；所有权系统检查一切是否合乎规则。例如，如果尝试在发送后再次使用发送的数据，编译器会报错，从而避免潜在的并发问题。这种设计使得 Rust 在并发编程中具有极高的安全性，开发者无需担心常见的竞态条件或数据不一致问题。

> [!note] 无界信道
> 使用 `mpsc::channel` 创建的是一个无界信道，该信道没有容量上限，如果发送的速度大于接收并处理的速度，那么数据就会堆积直到内存占满。这种设计虽然简单，但在高负载场景下可能会导致性能问题。例如，在一个高吞吐量的日志系统中，如果日志生成速度远快于处理速度，可能会导致内存耗尽。在实际中更加常用的信道是有界的，即当信道占满后会阻塞发送端发送数据。在 Rust 中，使用 `sync_channel` 来创建一个有界信道。该方法提供了一个 `SyncSender` 和一个普通的 `Receiver`。有界信道的优点是可以限制内存使用，同时通过阻塞机制平衡发送和接收的速度，从而避免资源耗尽的问题。例如，在一个任务队列中，有界信道可以确保任务生成速度与处理速度保持一致，从而提高系统的稳定性。

## 共享内存

[[02_Areas/操作系统/进程管理#共享存储|共享内存]] 是另一种线程通信的方式。Rust 中通过互斥锁来实现安全访问。

### 互斥锁

**互斥器**（*mutex*）是互相排斥（*mutual exclusion*）的缩写，因为在同一时刻，它只允许一个线程访问数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的**锁**（*lock*）来表明其希望访问数据。锁是一个数据结构，作为互斥器的一部分，它记录谁有数据的专属访问权。因此我们讲，互斥器通过锁系统**保护**（*guarding*）其数据。

> [!tip] 在 Rust 中，得益于所有权机制，我们不可能在锁的获取与释放上出错。

`Mutex<T>` 使用 `new` 创建一个带有锁的变量。我们可以通过 `lock()` 方法获得一个锁中的变量，该方法是一个原子操作，将变量上锁。当一个变量被上锁时，其他对该变量调用 `lock` 方法会被阻塞到锁被释放。

> [!note]
> `lock()` 方法返回一个 `Result`，当一个线程获得了锁，但是还没释放就 `panic` 退出了，此时其他线程调用 `lock()` 方法会得到一个 `Err`。

> [!tip]
> 实际上，`Mutex` 是一个智能指针，调用其 `lock()` 方法会返回一个 `MutexGuard` 的智能指针，该指针实现了 `Deref` 来获取其中的值。它也实现了 `Drop` 方法，在离开作用域时会自动释放锁。

> [!info] 读写锁
> 常用的锁还有 [[02_Areas/操作系统/进程管理#读者写者问题|读写锁]]，在 Rust 中被定义为 `RwLock`，该锁提供了 `write` 和 `read` 方法，允许多个读者同时读一个数据或者一个写者在某一时刻写一个数据，但是不允许读者与写者、写者与写者同时读写一个数据。

### 多线程共享互斥锁

在 [[00_Inbox/Rust/智能指针|智能指针]] 中，我们使用 `Rc<T>` 来实现。但是事实上 `Rc<T>` 实现的方式不是原子操作，因此在多线程中 `Rc<T>` 是不安全的。相应的，Rust 提供了 `Arc<T>` 作为多线程中的替代。它们的使用方式是一致的。

下面是一个 `Arc` 的使用示例。
```rust
fn main() {
    let num = Arc::new(Mutex::new(0));
    let mut threads = Vec::new();
    for i in 0..10 {
        let num = Arc::clone(&num);
        let handle = thread::spawn(move || {
            let mut num = num.lock().unwrap();
            *num += 1;
            println!("Thread {i}: num is {num}");
        });
        threads.push(handle);
    }

    for t in threads {
        t.join().unwrap();
    }
}
```

> [!note] `Arc<Mutex<T>>` 与 `Rc<RefCell<T>>` 的相似性
> 在上面的例子中，尽管 `num` 是不可变的，但是我们仍然可以获取 `Mutex` 中变量的可变引用，因此 `Mutex` 也是一个具有 [[00_Inbox/Rust/智能指针#`RefCell<T>`|内部可变性]] 的智能指针。

> [!warning]
> 使用 `Mutex` 和 `Arc` 也不能完全避免逻辑错误。使用 `Rc` 会造成循环引用的问题，而使用 `Mutex` 也同样会造成 [[02_Areas/操作系统/进程管理#死锁|死锁]] 的现象。

## `Sync` 与 `Send` Trait

前面介绍的内容都属于 Rust 标准库的范畴，而非 Rust 语言内嵌的要素。Rust 内置的语言特性仅包括 `Sync` 和 `Send` 两个标记 Trait，我们可以编写自己的并发特性或者使用他人编写的并发特性。
- `Send` 标记 Trait：表明该类型可以在线程之间传送。几乎所有的 Rust 类型都实现了 `Send` Trait，常见的没有实现 `Send` 的类型包括 `Rc<T>`，因此 `Rc<T>` 是不能在线程之间传送的。当我们试图在不同的线程中移动 `Rc` 的所有权时，我们会得到一个没有实现 `Send` Trait 的错误。
- `Sync` 标记 Trait：`Sync` 标记 trait 表明一个实现了 `Sync` 的类型可以安全的在多个线程中拥有其值的引用。换一种方式来说，对于任意类型 `T`，如果 `&T`（`T` 的不可变引用）实现了 `Send` 的话 `T` 就实现了 `Sync`，这意味着其引用就可以安全的发送到另一个线程。

> [!note]
> `Send` 与 `Sync` 两种类型不应该手动实现，它们仅在类型的所有组成类型都实现了 `Send` 或 `Sync` 时，由编译器自动实现。手动实现这些 Trait 涉及到不安全的 Rust。

---

< [[00_Inbox/Rust/智能指针|智能指针]] ｜ [[00_Inbox/Rust/异步编程|异步编程]] >
