---
tags:
  - Rust
---

# 枚举与模式匹配

**枚举**（*enumerations*），也被称作 *enums*。枚举允许你通过列举可能的 **变体**（*variants*）来定义一个类型。枚举是一种类型，该类型为枚举的值，且必须是其中一种值。

## 定义

Rust 中使用如下方式定义与使用一个枚举类型。

```rust
// 枚举类型
enum IpAddrKind {
	V4, // 变体
	V6,
}

fn main(){
	let kind = IpAddrKind::V4;
}
```

> [!note] 枚举的定义与使用与 cpp 中的 `enum class` 类似。使用命名空间前缀的方式来使用一个枚举。但是 rust 的函数式特性赋予了枚举更加强大的能力。

### 枚举值

Rust 的枚举除了表示不同的类型，还可以包含类似的值。可以通过多种方式定义类型包含的值。

```rust
enum Message {
	Quit, // 单枚举
	Move { x: i32, y: i32 }, // 包含命名变量
	Write(String), // 包含一个 String
	ChangeColor(i32, i32, i32), // 包含 3 个 i32
}

fn call_message(msg: &Message) { ... }
```

### 方法

与结构体类型，枚举类型也可以使用 `impl` 块定义方法。

```rust
impl Message {
	fn call(&self) {
		...
	}
}
```

### Option 枚举类型

`Option` 是标准库中定义的一个枚举类型，代表一个值要么有值要么没有值。Rust 使用 `Option` 枚举来替代其他编程语言中涉及到的空值问题。其定义如下：

```rust
enum Option<T> {
	None,
	Some<T>,
}
```

> [!note]
> `Option` 应用广泛，因此被包含在了 Rust 的 prelude 中，不需要引用就可以直接使用。此外，`None` 与 `Some` 也不需要 `Option` 命名空间前缀，可以直接使用。

> [!note] 通过 `Option` 的引入，在 Rust 中没有空值，因此一个值如果不是 `Option` 的，我们就可以认为它是安全的。

## match 控制流

`match` 是一个极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行代码。

> [!note] 模式可以由字面值、变量、通配符等组成。详见 [[模式与模式匹配]]。

使用 `match` 可以匹配一个枚举类型的所有情况。
- 当 `match` 匹配的表达式与当前模式不匹配是，会接着匹配下一个模式。
- 分支语句是一个表达式，表达式的结果将作为整个 `match` 语句的结果。
- 分支语句较短时不使用大括号，一个分支语句可以使用大括号运行多行语句。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

> [!note] `match` 与 `if` 的区别
> `if` 关键词后跟表达式，且该表达式的值必须是 `bool` 类型。而 `match` 匹配的表达式可以是任何表达式。

### 绑定值

`match` 匹配枚举类型时，可以通过绑定值来获取枚举类型中包含的值。绑定后可以在后续的分支语句中使用该变量。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) -> bool {
        match self {
            Message::Quit => false,
            Message::Move { x, y } => {
                println!("Move to {x}, {y}");
                true
            }
            Message::Write(text) => {
                println!("Write: {text}");
                true
            }
            Message::ChangeColor(r, g, b) => {
                println!("Change color to ({r}, {g}, {b})");
                true
            }
        }
    }
}
```

> [!warning] 匹配是穷尽的！`match` 语句必须匹配所有可能的情况。

### 通配符与占位符

`match` 语句可以使用 `other` 通配符代表剩下的所有情况，并将这些情况的模式的引用赋值到 `other` 变量上供分支语句使用。

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other: i32 => move_player(other),
    }
```

如果不想要值，可以使用 `_` 占位符。

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }
```

### `if let` 与 `let else`

`if let` 是 `match` 的一个语法糖，它在匹配到给定模式时执行代码，而忽略其他所有的模式。它是 `match` 的一种特殊情况。

```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
	println!("{}", max);
} else {
	println!("not match");
}
```

> [!note]- 等价写法
>
> ```rust
> let config_max = Some(3u8);
> match config_max {
> 	Some(max) => println!("{}", max),
> 	_ => println!("not match"),
> }
> ```

`if let` 还有一种用法是提取枚举类型中包含的变量，这在函数判断输入时非常常见。

```rust
fn process_max(config_max: Option<i32>) -> Option<String>{
	let max = if let Some(max) = config_max {
		max
	} else {
		return None
	}

	println!("process {max}");
	"Done"
}
```

我们可以使用 `let...else` 来简化这一过程，并增加代码的可读性。

```rust
fn process_max(config_max: Option<i32>) -> Option<String>{
	let Some(max) = config_max else {
		return None;
	};

	println!("process {max}");
	"Done"
}
```

## 模式匹配

模式匹配在 Rust 中普遍存在的。这里列出了 Rust 语言中可以出现模式匹配的所有位置。
1. `match` 分支：`match VALUE { PATTERN => EXPRESSION, PATTERN => EXPRESSION }`
2. `if let` 表达式：`if let PATTERN = EXPRESSION { }`
3. `while let` 循环：`while let PATTERN = EXPRESSION { }`
4. `for` 循环：`for PATTERN in EXPRESSION { }`
5. `let` 语句：`let PATTERN = EXPRESSION ...`
6. 函数参数

当我们在上述位置使用表达式时，实际上就是进行了一次模式匹配。例如：

```rust
let x = 5;   // x 是模式
if let Some(val) = some_option_value { 
	dosomething;
} // Some(val) 是模式

let v = vec!['a', 'b', 'c'];
for (index, value) in v.iter().enumerate() {
	println!("{value} is at index {index}");
} // (index, value) 是模式

let Point { x : x1, y : y1 } = point; // Point {x:x1, y:y1} 是模式
```

模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。
- 能匹配任何传递的可能值的模式被称为是**不可反驳的**（*irrefutable*）。
	-  `let x = 5;` 语句中的 `x`，因为 `x` 可以匹配任何值所以不可能会失败。
	- 函数参数、`let` 语句和 `for` 循环只能接受不可反驳的模式，因为当值不匹配时，程序无法进行有意义的操作。
- 对某些可能的值进行匹配会失败的模式被称为是**可反驳的**（*refutable*）。
	-  `if let Some(x) = a_value` 表达式中的 `Some(x)`；如果变量 `a_value` 中的值是 `None` 而不是 `Some`，那么 `Some(x)` 模式不能匹配。
	- `if let` 和 `while let` 表达式可以接受可反驳和不可反驳的模式，但编译器会对不可反驳的模式发出警告，因为根据定义它们旨在处理可能的失败：条件表达式的功能在于它能够根据成功或失败来执行不同的操作。

### `match` 模式语法

`match` 支持多种模式语法。这里给出所有的情况：

#### 匹配字面量

```rust
let x = 1;
match x {
	1 => println!("one");
	2 => println!("two");
	3 => println!("three");
	_ => println!("I can't count it");
}
```

#### 匹配命名变量

```rust
let x = Some(5);
match x {
	Some(x) => println!("x is {x}");
	None => println!("x is not a value");
}
```

#### 匹配范围值

```rust
let x: usize = 1;
match x {
	0..100 => println!("I'm less than 100"),
	_ => println!("other value").
}

// 或者对 char 使用
let x = 'c';
match x {
	'a'..='j' => println!("early ASCII letter"),
	'k'..='z' => println!("late ASCII letter"),
	_ => println!("something else"),
}
```

#### 结构枚举、结构体与元组

```rust
// 解构嵌套解构
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
match msg {
	Message::ChangeColor(Color::Rgb(r, g, b)) => {
		println!("Change color to red {r}, green {g}, and blue {b}");
	}
	Message::ChangeColor(Color::Hsv(h, s, v)) => {
		println!("Change color to hue {h}, saturation {s}, value {v}");
	}
	_ => (),
}
```

#### 其他匹配语法

在 `match` 中可以使用 `|` 表示逻辑或。

```rust
let x = 1;
match x {
	1 | 2 => println!("one or two"),
	3 => println!("three"),
	_ => println!("anything"),
}
```

可以使用 `_` 匹配所有值，但是不会捕获任何值。

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
	(Some(_), Some(_)) => {
		println!("Can't overwrite an existing customized value");
	}
	_ => {
		setting_value = new_setting_value;
	}
}
```

可以使用 `..` 来忽略剩余的值。

```rust
struct Point {
	x: i32,
	y: i32,
	z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
	Point { x, .. } => println!("x is {x}"),
}
```

> [!warning]
> 然而使用 `..` 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。
> ```rust
> match numbers {
> 	(.., second, ..) => {
> 		println!("Some numbers: {second}")
> 	},
> }
> ```

可以在每个模式的后面提供额外条件，称为匹配守卫。

```rust
let num = Some(4);

match num {
	Some(x) if x % 2 == 0 => println!("The number {x} is even"),
	Some(x) => println!("The number {x} is odd"),
	None => (),
}
```

> [!note]
> 匹配守卫的优先级要低于 `|`，因此 `x, y, z if flag` 等同于 `(x, y, z) if flag`。

可以使用 `@` 运算符在绑定值的同时测试它。

```rust
enum Message {
	Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
	Message::Hello {
		id: id_variable @ 3..=7,
	} => println!("Found an id in range: {id_variable}"),
	Message::Hello { id: 10..=12 } => {
		println!("Found an id in another range")
	}
	Message::Hello { id } => println!("Found some other id: {id}"),
}
```

---

< [[00_Inbox/Rust/结构体|结构体]] | [[00_Inbox/Rust/包与模块|包与模块]] >
