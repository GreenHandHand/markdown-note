---
tags:
  - 计算机组成原理
---

# 指令系统

> [!definition|Definition] 机器指令
**机器指令**，简称**指令**，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一条计算机的所有指令的集合构成该机的**指令系统**，也称为**指令集**。

> [!tip] 一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

## 指令系统

指令系统是**指令集体系结构** (ISA) 中最核心的部分，ISA 完整定义了软件和硬件之间的接口，规定了机器语言和汇编语言程序的格式。

ISA 规定的内容主要包括：
1. 指令格式，指令寻址方式、操作类型，以及每种操作对应的操作数和相应规定。
2. 操作数的类型，操作数寻址方式，以及按照大端方式还是小端方式存放。
3. 程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式。
4. 指令执行过程的控制方式等，包括程序计数器、条件码定义等。

### 指令的基本格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常要包括**操作码**字段和**地址码**字段两个部分。
$$
\begin{array}{|c|c|}
\hline\small\text{操作码字段} & \small\text{地址码字段} \\ \hline
\end{array}
$$
- 操作码 (OP)：指出指令应该执行什么操作以及具有何种功能。*操作码是识别指令、了解指令功能以及区分操作数地址内容等的关键信息，对于每个不同的指令，都有其对应的操作码*。
- 地址码 (A)：给出被操作信息 (指令或者数据) 的地址。*包括参与运算的一个或者多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等*。

> [!note] 指令字长
> **指令字长**是指一条指令所包含的二进制代码的位数，其取决于操作码的长度、地址码的长度和地址码的个数。
>
> 指令字长与机器字长没有固定的关系，它即可等于机器字长，又可大于或者小于机器字长。一般来说，我们规定：
> - 指令字长等于机器字长的指令称为单字长指令。
> - 指令长度等于半个机器字长的指令称为半字长指令。
> - 指令长度等于两个机器字长的指令称为双字长指令。

> [!warning]
> 指令长度不同会导致取指令时间开销不同。对于单字长指令只需要访存一次就可以取到指令，但是对于双字长指令则需要访存两次才能完整取出，耗费两个存取周期。

### 指令的分类

#### 按照指令中操作数地址码的数目分类

一条指令可能包含一个或者多个地址码，根据地址码的数目不同，可以将指令分为零地址指令，一地址指令，二地址指令等。
1. **零地址指令**：$\begin{array}{|ccc|} \hline&\small\text{OP}& \\\hline\end{array}$
	- 用于不需要操作数，如空操作、停机、关中断等。
	- 在堆栈计算机中，两个操作隐含存放在栈顶和次栈顶，计算结果压回栈顶即可。因此堆栈计算机中不需要操作数。
2. **一地址指令**：$\begin{array}{|ccc|ccc|}\hline&\small\text{OP}&&\small\text{A}_{1}\\\hline\end{array}$
	- 用于只需要单操作数的指令，从 $A_{1}$ 读取操作数，并写回原地址，如自增，自减，取反，求补等。
		- 记为 $\text{OP}(A_1)\to A_1$
		- 完成一条指令需要 3 次访存：取指、读 $A_1$，写 $A_1$。
	- 需要两个操作数，但其中一个操作数隐含在某个寄存器中 (如 ACC 中)。
		- 记为 $(\text{ACC})\text{OP}(A_1)\to\text{ACC}$
		- 完成这样的指令只需要 2 次访存：取指，读 $A_1$。
- **二地址指令**：$\begin{array}{|ccc|c|c|}\hline&\small\text{OP}&&\small\text{A}_{1}&\small\text{A}_{2}\\\hline\end{array}$
	- 常用于需要两个操作数的算术运算，逻辑运算相关指令。
		- 指令的含义为 $(A_1)\text{OP}(A_2)\to A_1$
		- 完成一条指令需要 4 次访存，即取指、读 $A_1$，读 $A_2$，写 $A_1$。
- **三地址指令**：$\begin{array}{|ccc|c|c|c|}\hline&\small\text{OP}&&\small\text{A}_{1}&\small\text{A}_{2}&\small\text{A}_{3}\\\hline\end{array}$
	- 常用于需要两个操作数的算术运算、逻辑运算相关指令，可以指定存储地址。
		- 指令含义为 $(A_1)\text{OP}(A_2)\to A_3$。
		- 完成一条指令需要访存 4 次，即取指、读 $A_1$、读 $A_2$、写 $A_3$。
- **四地址指令**：$\begin{array}{|ccc|c|c|c|c|}\hline&\small\text{OP}&&\small\text{A}_{1}&\small\text{A}_{2}&\small\text{A}_{3}&\small\text{A}_{4}\text{(下址})\\\hline\end{array}$
	- 相当于指出了下地址的三地址指令，其中 $A_4$ 为下址，即下一条指令的地址。

#### 按照指令长度分类

> [!note]
> - 指令字长：一条指令的总长度。
> - 机器字长：CPU 进行一次整数运算所能处理的二进制数据的位数。通常和 $\text{ALU}$ 直接相关。
> - 存储字长：一个存储单元中的二进制代码位数。通常和 $\text{MDR}$ 为主相同。

指令可以按照与机器字长的关系，分为半字长指令、单字长指令、双字长指令。指令字长会影响取指令所需的时间。由于主存一般是按照字节编址的，因此指令字长通常为字节的整数倍。
- 定长指令字结构：指令系统中所有的指令的长度相同。
- 变长指令字结构：指令系统中所有的指令的长度不等。

#### 按操作类型分类

设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按照功能可以分为以下几种。
1. 数据传送：即数据传送指令
	- MOV 指令：寄存器之间的传送
	- LOAD 指令：从内存单元读取数据到 CPU
	- STORE 指令：从 CPU 寄存器写数据到内存单元
	- PUSH 指令：进栈操作
	- POP 指令：出栈操作
2. 算术逻辑操作
	- 算术：加减乘除、自增自减、求补、浮点运算、十进制运算
	- 逻辑：与或非、异或、位操作、位测试、位清除、位求反
3. 移位操作：算术位移、逻辑位移、循环位移
4. 转移操作：
	- 无条件转移 JMP
	- 条件转移：例如 JZ 指令，结果为 0 跳转，JO 指令，结果溢出跳转，JC 指令，结果有进位跳转
	- 调用和返回：CALL 指令和 RET 指令
	- **陷阱 Trap 和陷阱指令**
5. 输入输出操作：CPU 寄存器与 IO 端口之间的数据传送

### 扩展操作码指令格式

> [!note] 定长操作码
> **定长操作码指令**在指令的最高位部分分配固定的若干位 (定长) 表示操作码，一般 $n$ 位操作码字段的指令可以表示 $2^{n}$ 条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。*当计算机字长为 32 位或者更长时，这是常规用法*。

为了在指令字长有限的前提下仍然保持比较丰富的指令种类，可以采取**可变长操作码**，即全部指令的操作码位数不固定，且分散地放在指令字的不同位置上。显然，这会增加指令译码和分析的难度，使得控制器的设计复杂化。

最常见的变长操作码方法是**扩展操作码**，它使得操作码的长度随地址码的减少而增加。不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。通过这种方法，可以将一些常用的简单指令（如算术运算）赋予较短的操作码，而将一些复杂的或不常用的操作（如特殊的浮点运算）赋予较长的操作码。这样既节省了空间，又能够容纳更多的指令类型。

> [!note] 定长指令字结构 + 可变长操作码结构
> - 优点：在指令字长有限的前提下仍然保持了比较丰富的指令种类。
> - 缺点：增加了指令译码和分析的难度，使得控制器的设计复杂化。

在设计扩展操作码指令格式时，必须注意以下两点：
1. 不允许短码是长码的前缀。即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。

> [!note]
> 通常对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能较少指令译码和分析的时间。
>
> 在实际设计中，设地址长度为 $n$，上一层留出 $m$ 种状态，下一层可以扩展出 $m\times 2^n$ 种状态。

> [!example]-
> 这里给出一个设计扩展操作码的例子。假设指令字长为 16 位，地址字段为 4 位，我们需要设计一个指令系统来满足 15 条三地址指令、12 条二地址指令、62 条一地址指令以及 32 条零地址指令的需求。
> - **三地址指令**：三地址指令需要占用 3 个地址字段（共 12 位），因此可以在操作码部分使用剩下的 4 位来表示。可以设计从 `0000` 到 `1101`（共 15 种组合）作为三地址指令的操作码，而 `1111` 可以预留供后续使用。因此三地址指令的格式为 `xxxx ---- ---- ----`。
> - **二地址指令**：二地址指令需要占用 2 个地址字段（共 8 位），因此在操作码部分可以使用剩下的 8 位来表示。由于三地址指令已经占用了 `0000` 到 `1101`，二地址指令的操作码高 4 位必须为 `1111`，剩下的 4 位可以从 `0000` 到 `1011`（共 12 种组合）。所以二地址指令的格式为 `1111 xxxx ---- ----`。
> - **一地址指令**：一地址指令需要占用 1 个地址字段（共 4 位），因此在操作码部分可以使用剩下的 12 位来表示。考虑到前两类指令已经占用了前 8 位，一地址指令的操作码可以使用接下来的 6 位，从 `00 0000` 到 `11 1110`（共 62 种组合）。因此一地址指令的格式为 `1111 11xx xxxx ----`。
> - **零地址指令**：剩余的部分可以全部用于设计零地址指令。剩下的 5 位刚好可以设计 32 条零地址指令。因此零地址指令的格式为 `1111 1111 111x xxxx`。
>
> 当 CPU 解析指令时，会按照零地址、一地址、二地址、三地址的顺序来确定指令的类别，然后根据对应的扩展操作码执行相应的操作。

## 寻址方式

寻址方式是寻找指令或者操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令地址的方法。寻址方式分为指令寻址和数据寻址两大类。
- 指令寻址：寻找下一条将要执行的指令地址
- 数据寻址：寻找本条指令的数据地址

### 指令寻址

**指令寻址**即如何确定下一条指令的地址。使用程序计数器 (PC) 来指出下一条指令的地址。每一条指令在执行前都会将 PC 加上当前的指令字长，从而获得下一条指令的位置。
- 顺序寻址：
	- 定长指令字结构：每读入一条指令，使得 PC 自增，即 $(\text{PC})+指令字长\to\text{PC}$
	- 变长指令字结构：
		1. 读入一个字，根据操作码判断这条指令的总字节数 $n$
		2. $(\text{PC})+n\to\text{PC}$
		3. 根据指令的类型，CPU 可能还要进行多次访存，每次读入一个字
- 跳跃寻址：通过跳转类指令实现。跳跃是指由本条指令给出下一条指令地址的计算方式，而是否跳跃可能受到状态寄存器的控制，跳跃的方式分为绝对转移 (地址码直接指出转移目标地址) 和相对转移 (地址码指出转移地址相对于当前 PC 的偏移量)，由于 CPU 总是根据 PC 的内容去主存取指令的，因此转移执行的执行结果就是修改 PC 的值，下一条指令仍然由 PC 给出。

> [!note] PC 寄存器
> PC（程序计数器）寄存器在每个时钟周期会自动递增，这是由硬件逻辑实现的。
> - 因此，在顺序执行指令的情况下，CPU 从 PC 中读取完当前指令的位置后，PC 会自动指向内存中的下一个指令地址。
> - 如果当前指令是一条跳转指令，则指令执行的结果就是修改 PC 的值，在下一个时钟周期，CPU 将从 PC 中读取跳转指令的目标地址，并从此地址开始继续执行指令，同时 PC 会继续自动递增以指向后续的指令。

### 数据寻址

**数据寻址**用于确定当前执行指令的地址码指明的真实地址。

数据寻址的方式较多，为了区别各种方式，通常在指令字中设置一个寻址特征字段，用于指明属于哪种寻址方式，其位数决定了寻址方式的种类。数据寻址命令的指令格式如下：
$$
\begin{array}{|c|c|c|}
\hline\small\text{操作码} & \small\text{寻址特征} & \small\text{形式地址} A \\ \hline
\end{array}
$$
指令中的地址码字段不代表操作数的真实地址，这种地址称为**形式地址**，使用 $A$ 表示。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为**有效地址**，使用 $\text{EA}$ 表示。

> [!note] 常见的数据寻址方式
> - 若为立即寻址，则形式地址的位数决定了操作数的范围。
> - 若为直接寻址，则形式地址的位数决定了可寻址范围。
> - 若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。
> - 若为寄存器间接寻址，则寄存器的位数决定了可寻址范围。

> [!tip]
> 形式地址 $A$ 即可是一个数值，也可以是寄存器编号，也可以是内存地址。

|   寻址方式    |               有效地址               | 访存次数 |
| :-------: | :------------------------------: | :--: |
|   立即寻址    |             $A$ 即操作数             |  0   |
|   直接寻址    |       $\text{EA}=\text{A}$       |  1   |
|  一次间接寻址   |      $\text{EA}=\text{(A)}$      |  2   |
|   寄存器寻址   |        $\text{EA}=R_{i}$         |  0   |
| 寄存器一次间接寻址 |       $\text{EA}=(R_{i})$        |  1   |
|   相对寻址    | $\text{EA}=(\text{PC})+\text{A}$ |  1   |
|   基址寻址    | $\text{EA}=\text{(BR)}+\text{A}$ |  1   |
|   变址寻址    | $\text{EA}=(\text{IX})+\text{A}$ |  1   |

#### 立即寻址

形式地址 $\text{A}$ 就是操作数本身，又称为立即数，一般采用补码的形式。常使用 "\#" 表示立即寻址特征。

> [!note] 立即寻址特点
> - 优点：指令执行阶段不访问主存，指令执行时间最短。
> - 缺点：A 的位数限制了立即数的范围，如 $\text{A}$ 的位数为 $n$，且立即数采用补码时，可以表示的数据范围为 $-2^{n-1}\sim 2^{n-1}-1$。

#### 直接寻址

指令字中的形式地址就是操作数的真实地址 $\text{EA}$，即 $\text{EA}=\text{A}$。直接寻址仅需要两次访存，即取指令，执行指令。

> [!note] 直接寻址特点
> - 优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。
> - 缺点：A 的位数决定了该指令的操作数的寻址范围，操作数的地址不易修改。

#### 间接寻址

相对于直接寻址，间接寻址的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的主存单元的地址，也就是操作数地址的地址，即 $\text{EA}=\text{(A)}$。

此外，还可以进行多次间接寻址。在多次间接寻址中，每个地址的开头第一位为 0 表示保存的是真实地址 EA，开头第一位为 1 表示保存的仍然是间接地址。

> [!note] 间接寻址特点
> - 优点：可扩大寻址范围 (有效地址 EA 的位数大于形式地址的位数)、便于编制程序 (用间接寻址可以方便地完成子程序返回)。
> - 缺点：指令在执行阶段要多次访存 (一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存)

#### 寄存器寻址

在指令字中直接给出操作数所在的寄存器编号，即 $\text{EA}=R_{i}$，其操作数在由 $R_{i}$ 所值的寄存器内。

> [!note] 寄存器寻址特点
> - 优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。一条指令的执行只需要取指令访存一次。
> - 缺点：寄存器价格昂贵，计算机中寄存器个数有限。

#### 寄存器间接寻址

这种方式综合了间接寻址和寄存器寻址的特点，寄存器 $R_{i}$ 中给出的不是一个操作数，而是操作数所在主存单元的地址，即 $\text{EA}=(R_{i})$。

> [!note] 寄存器间接寻址特点
> 与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存。(因为操作数在主存中) 在执行阶段需要访问一次主存。

#### 隐含寻址

这类寻址方式不显式的给出操作数的地址，而是指令中隐含着操作数的地址。例如，单地址指令的格式中就隐含约定的第二个操作数，例如 ACC。

> [!note] 隐含寻址特点
> - 优点：有利于缩短指令字长。
> - 缺点：需要增加存储操作数或隐含地址的硬件。

#### 偏移寻址

以某一个特定的起点，偏移一定的值的寻址方式。根据偏移的起点选取，可以将偏移寻址分为三类。

> [!tip] 偏移寻址在指令执行期间需要访存一次。

##### 相对寻址

把程序计数器 PC 的内容加上指令格式中的形式地址 $\text{A}$ 而形成操作数的有效地址，即 $\text{EA}=\text{(PC)}+\text{A}$，其中 $\text{A}$ 是相对于 $\text{(PC)}$ 所指地址的偏移量，可正可负，==补码==表示。

> [!note] 相对寻址特点
> - 优点：使得代码在程序内浮动时不用更改跳转指令的地址码。相对寻址广泛用于转移指令。

> [!warning]
> 在使用相对寻址的跳转指令 `JMP A`，若该指令的地址为 `X`，且占 2B，则取出该地址后，$\text{PC}$ 的值会==增加 2==，并且在执行完这个指令后，将将 `A` 加到 $PC$ 上，即该指令的执行效果为 $\text{X+2+A}\to\text{PC}$。
>
> 相对寻址中的操作数一般为补码表示，同时，一般而言操作数的宽度小于 PC 的内容。因此，在计算相对寻址时，需要先将操作数进行符号扩展，然后与 PC 值相加。

##### 基址寻址

将 CPU 中基址寄存器 (BR) 的内容加上指令格式中的形式地址 $\text{A}$，而形成操作数的有效地址，即 $\text{EA}=(\text{BR})+\text{A}$。其中基址寄存器既可采用专用寄存器^[[[00-笔记/操作系统/内存管理#程序的链接与装入|动态重定位]] 中提到的重定位寄存器]，也可以指定某个通用的寄存器作为基址寄存器。

> [!note]
> 在有的计算机内部不会专门设置一个基址寄存器，而是在指令中指明要将那个通用寄存器作为基址寄存器使用。这种时候形式地址 $A$ 是指明寄存器的编号。
>
> 基址寄存器是面向操作系统的，其内容由操作系统或者管理程序确定 (操作系统中的内容)。采用通用寄存器作为基址寄存器时，可以由用户决定哪个寄存器作为基址寄存器，但是其内容仍然由操作系统确定。

> [!note] 基址寻址的特点
> - 优点：
> 	- 便于程序的浮动，方便实现多道程序并发运行。
> 	- 可以扩大寻址范围 (基址寄存器的位数大于形式地址 A 的位数)。
> 	- 用户不必考虑自己的程序存于主存的哪一空间区域，有利于多到程序的设计与编制浮动程序。
> - 缺点：
> 	- 偏移量 (形式地址 $\text{A}$) 的位数较短。

##### 变址寻址

有效地址 $\text{EA}$ 等于指令字中的形式地址 $\text{A}$ 与变址寄存器 IX 的内容之和，即 $\text{EA}=(\text{IX})+\text{A}$，其中 IX 可以为变址寄存器，也可以是通用寄存器作为变址寄存器。

> [!note] 变址寻址与基址寻址的区别
> 区别与基址寄存器，变址寄存器是面向用户的，在程序的执行过程中，变址寄存器的内容可由用户改变 (IX 作为偏移量)，形式地址 A 不变 (作为基地址)。
> - 变址寻址主要用于处理数组问题。
> - 基址寻址主要用于多道程序或数据分配存储空间。

> [!note] 变址寻址的应用
> 变址寻址在遍历数组的时候可以简化代码。即在数组的处理过程中，可设定 $\text{A}$ 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任意数据的地址，特别适合编制循环程序。

> [!note] 变址寻址特点
> - 优点：特别适合于编制循环程序。

> [!tip] 基址&变址复合寻址
> 将基址寻址方式与变址寻址的方式复合，即在寻址中先进行基址寻址，再在这个基础上在进行变址寻址。多种寻址方式的复合可以理解为复合函数。

#### 堆栈寻址

操作数存放在堆栈寄存器中，隐含使用堆栈指针 (SP) 作为操作数地址。

> [!note] 堆栈
> 堆栈是存储器 (或专用寄存器组) 中一块特定的按**后进先出**原则管理的存储区，该存储区中被读、写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针 (SP)。
> - 硬堆栈：使用寄存器实现堆栈。成本较高，不适合做大容量堆栈。
> - 软堆栈：在主存中划分一个空间作为堆栈。现实中常用这种方式。

## 程序的机器级代码表示

流行的汇编指令格式包括 AT&T 与 Intel (x86) 格式，这里主要介绍 x86 处理器的汇编指令。

> [!note] x86 与 AT&T 格式的区别
> 1. **大小写**：AT&T 格式的指令只能使用小写字母，而 x86 格式的指令对大小写不敏感。
> 2. **操作数顺序**：在 AT&T 格式中，第一个数为源操作数，第二个数为目的操作数，方向从做到右。在 x86 中，第一个数为目的操作数，第二个数为源操作数，方向从右到左 (与我们习惯的赋值方向相同)。*例如，在 AT&T 中的操作数一般为 `op s, d`*。
> 3. **寄存器与立即数表示**：AT&T 格式中，寄存器需要加 `%`，立即数需要加 `$`。在 x86 中，不需要加前缀。*例如，在 AT&T 中，访问寄存器为 `mov %eax, %ebx` 或者，访问立即数为 `mov $123, %eax`*。
> 4. **寻址符号**：在内存寻址方面，AT&T 使用 `()` 寻址，x86 使用 `[]` 寻址，*例如，在 AT&T 中，访问主存为 `mov %eax, (af996h)`*。
> 5. **数据长度**：在指定数据长度方面，AT&T 在指令的后面添加 `b` 表示字节，`w` 表示字，`l` 表示双字。在 x86 中，在地址的前面使用 `byte ptr` 表示字节，`word ptr` 表示字^[由于 32 位系统和 64 位系统都是由 16 位系统拓展而来，因此这里的字通常表示 16 位]，使用 `dword ptr` 表示双字。*例如，在 AT&T 中移动一个字为 `movb $5, (af996h)`*。
> 6. **复杂寻址方式**：在地址偏移量的表示中，AT&T 的内存操作数为 `disp(base, index, scale)`，分别表示偏移量、基址寄存器、变址寄存器和比例因子。
> 	-*例如，AT&T 中的 `8(%edx, %eax, 2)` 对应于 x86 中的*<code>[edx+eax*2+8]</code>。

### 常用汇编指令

> [!note]- 相关寄存器
> x86 处理器中一共有 8 个 32 位通用寄存器，其中 EAX、EBX、ECX、EDX 的高两位和低两位可以独立使用^[这里的 E 表示 Extended，因此 EAX 的低两位字节称为 AX，而 AX 的高低字节又可以分别作为两个寄存器 AH 与 AL]。![[Assets/指令系统-1.png#center|x86相关寄存器]]

在 x86 汇编中，有 3 种基本的访存形式，由此可以引申出一些其他的访存方式。下面是一些常见的访存方式：
```asmatmel
mov eax, ebx				# 寄存器 -> 寄存器
mov eax, dword ptr [af996h] # 主存 -> 寄存器
mov eax, 5					# 立即数 -> 寄存器

mov eax, dword ptr [ebx]	# 寄存器间接寻址
							# 其中 [ebx] 表示 ebx 中保存的主存地址
mov eax, [ebx]				# 没有指名长度，默认为32位
mov eax, dword ptr [ebx+8]	# 偏移寻址
```
1. 数据在寄存器中，直接给出寄存器名
2. 数据在主存中，使用 `长度 [地址]` 的方式给出读写长度和主存地址
3. 数据在指令中，直接给出数字 (可以使用不同进制数)

x86 中使用 d (destination) 表示目的操作数，s (source) 表示源操作数。在 x86 中，常见的算术指令与逻辑指令如下：

|      功能      |     指令      | 解释                                                  |
| :----------: | :---------: | --------------------------------------------------- |
|     Add      | `add d, s`  | `d = d + s`                                         |
|  Substract   | `sub d, s`  | `d = d - s`                                         |
|   Multiply   | `mul d, s`  | `d = d * s`，无符号数乘法                                  |
|   Multiply   | `imul d, s` | `d = d * s`，有符号数乘法                                  |
|    Divide    |   `div s`   | `eax = eax / s ... edx`，无符号数除法，商存入 `eax` 中，余数存入 `edx` 中 |
|    Divide    |  `idiv s`   | `eax = eax / s ... edx`，有符号数除法，商存入 `eax` 中，余数存入 `edx` 中 |
|   Negative   |   `neg d`   | `d = -d`，取负数                                        |
|   Increase   |   `inc d`   | `d++`，自增                                            |
|   Decrease   |   `dec d`   | `d--`，自减                                            |
|     And      | `and d, s`  | `d = d & s`                                         |
|      Or      |  `or d, s`  | <code>d = d \| s</code>                             |
|     Not      |   `not d`   | `d = ~d`                                            |
| Exclusive Or | `xor d, s`  | `d = d^s`                                           |
|  Shift Left  | `shl d, s`  | `d = d << s`                                        |
| Shift Right  | `shr d, s`  | `d = d >> s`                                        |

> [!tip]
> 目的操作数 d 不能是常量。

### 分支语句

> [!tip] IP 寄存器
> 在 x86 中，程序计数器 PC 也称为 IP (Instruction Pointer) 寄存器。

分支语句通过转移语句来实现。下面是一些常见的转移指令：

|         功能         |     指令     | 解释                      |
| :----------------: | :--------: | ----------------------- |
|        Jump        |  `jmp s`   | `goto s`，无条件跳转到 d 所指地址  |
|      Compare       | `cmp a, b` | 比较 a 和 b 两个数，用在条件跳转指令之前 |
|     Jump equal     |   `je s`   | `if (a == b) goto s`    |
|   Jump not equal   |  `jne s`   | `if (a != b) goto s`    |
|    Jump greater    |   `jg s`   | `if (a > b) goto s`     |
| Jump greater equal |  `jge s`   | `if (a >= b) goto s`    |
|     Jump less      |   `jl s`   | `if (a < b) goto s`     |
|  Jump less equal   |  `jle s`   | `if (a <= b) goto s`    |

> [!note] 锚定位置
> 在汇编语言中，可以使用一个字符串加冒号锚定一个位置，即使用该字符串表示对应的位置 (类似与 `goto`)。通过锚定方式与跳转指令，可以增加汇编程序的可阅读性。
>  ```asmatmel
> ...    		# some code
> jmp NEXT  	# 无条件跳转
> ... 		# some code
> NEXT:
> # 程序会跳转到这里
> ```

> [!note] `cmp` 指令的原理
> `cmp a, b` 指令实际上就是计算 `a-b`，并生成标志位 OF、ZF、CF、SF，这些运算结果会自动存入 PSW 程序状态字寄存器 (Inter 称为标志寄存器)。条件跳转指令会根据标志位来进行跳转。

### 循环语句

循环语句可以使用两种方式实现：
- 可以利用跳转语句，只是分支语句跳转方向为向后跳转，而循环指令的跳转方向为向前跳转。此外，还需要指明退出循环条件。
- 除了跳转转移指令外，还可以使用 `loop` 指令实现循环。

`loop` 指令的使用方式如下：
```asmatmel
mov ecx, 500 # 使用 ecx 作为循环计数器
Looptop:
	...
	# 循环体
	...
	loop Looptop # ecx--，若ecx!=0，跳转到Looptop
```

> [!note] `looo` 指令
> - `loop` 指令使用 `ecx` 作为循环计数器，但是不能使用其他的寄存器。
> - `loop` 指令可能会使得代码更加简洁清晰。
> - 理论上，使用 `loop` 指令实现的功能一定可以使用条件转移指令实现。

> [!tip] 其他 `loop` 指令
> - `loopnz` 指令：在循环的过程中额外判断 `ZF==0`，即条件为 `ecx!=0 && ZF==0`。
> - `loopz` 指令：在循环的过程中格外判断 `ZF==1`，即条件为 `ecx!=0 && ZF==1`。

### 函数调用指令

在 x86 架构中，函数调用主要通过 `call` 和 `ret` 指令来实现。它们是无条件转移指令，用于跳转到被调用的函数并最终返回。
- **`call` 指令**:
  - 将当前的指令指针 (IP) 压入栈中，保存返回地址。
  - 无条件跳转到被调用函数的第一条指令。
- **`ret` 指令**:
  - 从栈中弹出返回地址，恢复 IP 的值。
  - 跳转回调用函数的下一条指令。

下面是一个简单的函数调用示例：
```asmatmel
add:
    push ebp        # 保存调用函数栈帧
    mov ebp, esp    # 设置新的栈帧
    ...
    mov esp, ebp    # 恢复栈顶指针
    pop ebp         # 恢复之前的栈帧
    ret             # 从栈帧中恢复 IP 的旧值

caller:
    push ebp
    mov ebp, esp
    sub esp, 24
    ...
    call add        # 调用 add 函数，IP 压入栈
    leave
    ret
```

### 栈帧的概念

要完整的理解函数的调用过程，我们需要知道栈帧的概念。在 [[00-笔记/操作系统/内存管理#进程的内存映像|进程内存映象]]，存在一个进程的栈区，所有程序运行时创建的局部变量都会被放置到其生存周期对应的栈区中。

在每个函数调用时，都会为该函数分配一个栈帧。栈帧使用 `ebp` (栈底指针, base pointer) 和 `esp` (栈顶指针, stack pointer) 来标记其边界，栈从高地址向低地址增长。`ebp` 通常固定指向栈底，`esp` 随数据的入栈和出栈动态变化。

如下图所示，整个进程的内存从高地址到低地址包含了多个区域，栈 (Stack) 位于高地址，随着函数调用，栈顶从高地址向低地址方向增长。
![[Excalidraw/操作系统-进程内存映象.excalidraw|进程内存映象|700]]

在栈区域中，每个函数调用（如 `main`, `sum`, `add`）都会有属于自己的栈帧。栈帧从高地址到低地址依次保存了上一层栈帧基址、若干局部变量、未使用区域、调用参数和 IP 返回地址。

> [!note] 栈帧结构
> - **上一层栈帧基址**：用于在函数返回时恢复调用者的栈帧结构，存放在 `[ebp]` 中。
> - **局部变量**：每个函数的局部变量在栈帧中分配，并通过 `sub esp, xxx` 来调整栈顶，放置变量。
> - **未使用区域**：由于栈帧的大小必须对齐至 16 字节的整数倍，未使用的部分被保留以保证对齐。
> - **调用参数**：参数按照从右到左的顺序被压入栈中，函数通过 `ebp + offset` 来访问这些参数。这里的 `offset` 是从 8 开始的，即第一个参数的地址为 `[ebp+8]`。这是因为 `[ebp+4]` 中一定保存着 IP 返回地址。
> - **IP 返回地址**：在调用 `call` 指令时，当前指令的地址被保存至栈中，以便函数执行完成后通过 `ret` 指令返回到调用者。

#### 栈帧的动态变化

这里仍然使用之前的例子。
```asmatmel
add:
	push ebp		# 调用函数的栈底
	mov ebp, esp	# 修改当前栈底为上一个函数的栈顶
	...
	mov esp, ebp	# 修改栈顶为当前函数的栈底
	pop ebp			# 还原之前函数的栈底
	ret				# 返回，从栈帧中找到 IP 旧值

caller:
	push ebp
	mov ebp, esp
	sub esp, 24		# 分配局部变量
	...
	call add		# 调用 call，将指向下一条命令的IP寄存器压入栈
					# 跳转到 add 处
	mov esp, ebp	# 修改栈顶为当前函数的栈底
	pop ebp			# 还原之前函数的栈底
	ret				# 返回
```
当 `caller` 调用 `add` 函数时，栈帧会发生如下变化：
1. `call add`：将当前 IP 压入栈，同时跳转到 `add` 函数入口。栈顶指针 `esp` 指向 IP 返回地址。
	- 这里的 call 指令就相当于两条指令 `push IP` 和 `jmp add`。
	- 此时栈顶为 IP 返回地址。
2. `push ebp`：保存当前函数的栈底 `ebp`，用于函数返回时恢复调用者的栈帧。
	- 此时栈顶保存上一层栈帧基址。
3. `mov ebp, esp`：将 `esp` 赋值给 `ebp`，即新函数的栈底。
	- 此时 `ebp` 与 `esp` 重合，当前程序的栈帧长度为 0。
4. **局部变量分配**：编译器通过 `sub esp, n` 来为局部变量分配空间。
5. **函数执行**：函数执行期间，`esp` 会动态变化，随着数据的入栈和出栈而调整。
6. **栈帧恢复**：通过 `mov esp, ebp` 和 `pop ebp` 恢复栈帧的结构。
	- 将栈顶 `esp` 修改为栈底 `ebp`。此时栈顶内容为原函数的栈帧底。
	- 将栈顶的内容出栈，赋值到 `ebp` 中，`ebp` 被还原。`esp` 由于出栈操作加 4，指向旧 IP 地址。
1. **返回调用者**：`ret` 指令通过出栈 IP 返回地址，跳转到调用函数的下一条指令。同时 `esp` 寄存器加 4，栈顶变为原来的栈顶，原函数的栈帧被恢复。IP 寄存器指向调用函数处的下一条指令。

> [!note] 栈顶与栈底指针
> - `esp`：栈顶指针，动态指向栈中最近的有效数据。每次入栈时 `esp` 减小，出栈时 `esp` 增加。
> - `ebp`：栈底指针，指向当前栈帧的基址，用于函数调用过程中保持稳定，帮助访问局部变量和参数。

> [!note] `push` 与 `pop` 指令
> - `push` 指令先让 `esp` 减 4，然后将元素赋值到 `esp` 指向的栈区。
> - `pop` 指令弹出 `esp` 指向的数据，然后令 `esp = esp + 4`。
>
> 因此，`esp` 总是指向栈顶的数据。

> [!tip] 栈帧切换的指令优化
> 在函数调用和返回的过程中，我们可以通过 `enter` 和 `leave` 指令优化 `push ebp`, `mov ebp, esp` 和 `mov esp, ebp`, `pop ebp` 操作。

## CISC 和 RISC

现代的指令系统朝着两个截然不同的方向发展：
1. 增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化。这类机器称为 CISC (Complex Instruction Set Computer)，即复杂指令的计算机系统。设计思路为一条指令完成一个复杂的基本功能。代表为 x86 架构，主要用于笔记本、台式机等。
2. 减少指令种类和简化指令功能，提高指令的执行速度。这类机器称为 RISC (Reduced Instruction Set Computer)，即精简指令的计算机系统。设计思路为一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能。代表为 ARM 架构，MIPS 架构，主要用于手机、平板等。

> [!note] CISC 特点
> 1. 指令系统复杂庞大，指令数目一般为 200 条以上。
> 2. 指令的长度不固定，指令格式多，寻址方式多。
> 3. 可以访存的指令不受限制。
> 4. 各种指令使用频度相差很大。
> 5. 各种指令执行时间相差很大，大多数指令需要多个时钟周期才能完成。
> 6. 控制器大多数采用微程序控制，有些指令非常复杂，以至于无法采用硬连线控制。
> 7. 难以用优化编译生成高效的目标代码程序。

> [!tip]
> 80-20 规律：典型程序中 80% 的语句仅仅使用处理机中的 20% 指令。

> [!note] RISC 特点
> 1. 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。
> 2. 指令长度固定，指令格式种类少，寻址方式种类少。一般小于 100 条。
> 3. 只有 `load` 和 `store` 指令访存，其余指令的操作都在寄存器之间进行。
> 4. CPU 中通用寄存器的数量相当多。
> 5. 一定采用指令流水线技术，大部分指向在一个时钟周期内完成。
> 6. 以硬布线控制为主，不用或少用微程序控制。
> 7. 特别重视编译优化工作，以减少程序的执行时间。

> [!note] CISC 与 RISC 的比较
> 与 CISC 相比，RISC 的优点主要体现在：
> 1. RISC 更能充分利用 VLSI (超大规模集成电路) 芯片的面积。CISC 采用微程序控制，其控制存储器占用 CPU 芯片面积的 50% 以上，而 RISC 采用组合逻辑控制，其硬布线逻辑只占 CPU 芯片面积的 10% 左右。
> 2. RISC 可以提高运算速度。RISC 的指令数、寻址方式和指令格式种类少，又舍友多个通用寄存器，采用流水线技术，所以运算速度快，大多数指令可以在一个时钟周期内完成。
> 3. RISC 便于设计，可降低成本，提高可靠性。RISC 指令系统简单，因此机器设计周期短。其逻辑简单，出错概率低，可靠性高。
> 4. RISC 有利于编译程序代码优化。RISC 指令类型少，寻址方式少，使得编译程序容易选择更加有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更加高效。

---
< [[00-笔记/计算机组成原理/存储系统|存储系统]] | [[00-笔记/计算机组成原理/中央处理器|中央处理器]] >
