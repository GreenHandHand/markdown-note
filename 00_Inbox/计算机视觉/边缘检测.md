---
aliases:
  - edge
  - edge detection
tags:
  - 计算机视觉
---

# 边缘检测

## 边缘检测任务

在进行边缘检测之前，我们需要定义边缘 (edge)。定性地说，边缘出现在那些颜色、亮度或者纹理不一样的区域之间。但是在实际中，将图像分割成为一致的区域是一个很困难的任务，在计算机视觉中，这被称为图像分割。

在传统的计算机视觉中，边缘检测通常将边缘定义为亮度产生剧烈变化的位置。将一幅图像想象为一个高度域，在这样一个表面，边缘出现在陡峭斜率上。

边缘检测任务定义如下：
- 目标： 该任务的主要目标是识别图像中的突然变化，即不连续性。这些不连续性通常表现为图像中物体之间的边界、光照变化、纹理差异或颜色跃变等。边缘在图像中编码了大多数形状信息和语义信息，且相比单个像素，它们提供了更紧凑的表示形式。
- 特性：
	- 图像中的大多数形状信息和语义信息都可以通过边缘来表达。
	- 边缘相对于像素提供了更紧凑的表示，更有助于捕捉物体轮廓和关键特征。
- 理想情况下，边缘检测的终极目标是将图像转换为线条画。这意味着通过突出显示边缘信息，我们希望实现图像内容的更抽象和简化表示。此过程有助于强调图像中的关键特征，同时消除不必要的细节，从而创造出更直观、易于理解的视觉呈现。

### 边缘信息

通过边缘信息，我们可以
- 提取信息，识别物体
- 重建几何和视点

边缘信息来自图像中的不连续：
- **表面法线不连续**：法线不连续意味着在某一点附近，物体表面的朝向发生了突然变化。这种变化可能由物体几何形状的不规则性引起，如边缘或角落。
- **深度不连续**：深度不连续表示在图像中的某些位置，物体的深度突然变化。这可能是由物体之间的遮挡、表面高度变化或物体边缘引起的。
- **表面颜色不连续**：这种变化可以由不同的材质、纹理或颜色分布引起，而在边缘处会表现为不连续性。
- **照明不连续**：由于物体之间的阴影、光源位置的变化或材质的反射性质不同而引起的。在边缘处，由于光照的变化，会出现照明不连续性。

## 图像导数

根据边缘信息的特性，我们可以自然的想到使用导数来计算图像的变化。因此，这里首先需要解决的如何对图像进行求导的问题。

在一维函数中，导数的定义为：
$$
\frac{\mathrm df}{\mathrm dx}=\lim_{\Delta x\to 0} \frac{f(x)-f(x-\Delta x)}{\Delta x}=f'(x)=f_x
$$
对于离散的一维数据，我们有下面几种策略计算导数，同时使用 [[00_Inbox/计算机视觉/图像滤波#线性滤波|线性滤波器]] 进行表示：
- Backward：$\dfrac{\mathrm df}{\mathrm dx}=f(x)-f(x-1)=f'(x)$，即 $\begin{bmatrix}0&1&-1\end{bmatrix}$。
- Forward：$\dfrac{\mathrm df}{\mathrm dx}=f(x)-f(x+1)=f'(x)$，即 $\begin{bmatrix}-1&1&0\end{bmatrix}$。
- Central：$\dfrac{\mathrm df}{\mathrm dx}=f(x+1)-f(x-1)=f'(x)$，即 $\begin{bmatrix}1&0&-1\end{bmatrix}$。

图像是二维离散数据，我们可以使用相同的思想对其进行计算。对于一个给定二维函数 $f(x,y)$，其梯度向量是
$$
\Delta f(x,y)=\begin{bmatrix}\frac{\partial f(x,y)}{\partial x}\\\frac{\partial f(x,y)}{\partial y}\end{bmatrix}=\begin{bmatrix}f_x\\f_y\end{bmatrix}
$$
因此我们可以将图像的导数的计算等同与分别对图像的两个长度和宽度两个维度进行一维导数计算。我们可以使用与上面相同的滤波器构造，例如下面的两个滤波器：
$$
\small kernel_x=\frac{1}{3}\begin{bmatrix}1&0&-1\\1&0&-1\\1&0&-1\end{bmatrix}
\quad kernel_y=\frac{1}{3}\begin{bmatrix}1&1&1\\0&0&0\\-1&-1&-1\end{bmatrix}
$$

联系梯度与边缘的定义，我们可以发现：
- 梯度指向图像中变化最大的方向，这也是边缘的定义。
- 梯度的大小表示了图像变换的剧烈程度，这可以用来表示边缘的强度。

### 噪声处理

图像噪声是指图像中由于各种因素引起的不希望的、随机的、非结构化的、和可能干扰图像质量或信息的不规则变化。这些因素可能包括传感器噪声、信号传输过程中的干扰、照明变化、环境干扰以及图像采集设备的局限性等。图像噪声通常表现为在图像中出现的额外的、不属于原始场景的像素值或颜色，导致图像细节的丧失，降低了图像的质量和可用性。

对图像求梯度的方法对噪声非常敏感。一般而言，图像的噪声越大，梯度的响应越大。因此在对图像求梯度之前，我们需要对图像进行平滑处理，减轻噪声像素的影响。

于是一个简单的边缘检测过程可以描述为：
1. 使用平滑滤波器 $g$ 对输入信号 $f$ 平滑，即计算 $f*g$
2. 使用求导滤波器进行求导，即计算 $\dfrac{\mathrm d}{\mathrm dx}(f*g)$
3. 找到信号的极值点，对应边缘

> 这里有一个非常有用的细节，根据卷积的性质，我们有：
> $$\frac{\mathrm d}{\mathrm dx}(f*g)=f*\frac{\mathrm d}{\mathrm dx}g$$
> 即我们可以先对 $g$ 进行求导操作，在与输入信号进行卷积操作。这样可以减少很多的计算，仅进行一次卷积操作就可以得到梯度。对高斯滤波器进行求导，就可以得到 DOG (Derivative of Gaussian) 滤波器。

对于平滑滤波器，更强的滤波器可以去除噪声，但是也同时模糊边缘，因此可以通过不同大小的平滑滤波器来找到不同尺度的边缘。

### 拉普拉斯滤波器

拉普拉斯滤波器常用作二阶求导滤波器，根据二阶求导公式：
$$
f''(x)=\lim_{h\to 0}\frac{f(x+h)-2f(x)+f(x-h)}{h^2}
$$
于是拉普拉斯滤波器为：
$$
\begin{bmatrix}1&-2&1\end{bmatrix}
$$
根据卷积的性质，我们也可以将拉普拉斯滤波器与高斯滤波器结合，得到 LoG (Laplacian of Gaussian) 滤波器。对比 LoG 与 DOG，LoG 在检测中更加准确，但是存在零交叉点，因此处理起来比较麻烦。而 DOG 得到的梯度图像可以直接通过求极值点的方式来得到边缘。

### 设计边缘检测器

设计良好的边缘检测器应当满足应该遵循下面的原则：
1. 检测性能良好：可以最小化假正率 (False positives) 与假负率 (False negatives)。
2. 定位性能良好：检测到的边缘必须接近真实的边缘。
3. 单一响应：检测器必须对每个真实边缘点只返回一个点；即，尽量减少真实边缘周围的局部极大值的数量。

## Sobel 算子

Sobel 算子是用于边缘检测的离散微分算子，结合了高斯平滑和一阶微分。其使用了两个 $3\times 3$ 的滤波器，分别在两个方向对图像进行近似求导。
$$
G_x=\begin{bmatrix}1&0&-1\\2&0&-2\\1&0&-1\end{bmatrix}\quad G_y=\begin{bmatrix}1&2&1\\0&0&0\\-1&-2&-1\end{bmatrix}
$$
Sobel 算子是可分离的，将其分离后，可以看到 Sobel 算子实际上就是先对图像进行高斯模糊，之后在进行求导得到的结果。
$$
G_x=\begin{bmatrix}1&0&-1\\2&0&-2\\1&0&-1\end{bmatrix}=\begin{bmatrix}1\\2\\1\end{bmatrix}\begin{bmatrix}1&0&-1\end{bmatrix}
$$
使用 Sobel 算子可以计算得到图像的两个梯度，从而计算每个像素点处的边缘及其方向。
$$
G=\sqrt{G_x^2+G_y^2}\quad\Theta=\arctan(\frac{G_y}{G_x})
$$
Sobel 算子存在下面的问题：
1. 定位性能差：在相邻的多个像素中可能会触发多次响应
2. 阈值偏向于特定的方向，而忽略了其他方向。这可能会导致错过许多倾斜的边，忽略真实的边缘。增加了假负率。

以 Sobel 为首，有大量的基于求导的边缘检测算子。
![[Assets/Pasted image 20240104160034.png]]

## Canny 边缘检测

基于卷积运算的的边缘检测算法存在两个缺点：
1. 没有充分利用边缘的梯度方向
2. 最后输出的边缘二值图，只是简单的利用阈值处理，显然，阈值过大时会损失很多边缘信息，阈值过小时会有很多噪声。

Canny 边缘检测方法基于这两点做出了改进，提出了基于边缘梯度方向的非极大值抑制和双阈值的滞后阈值处理。Canny 可能是计算机视觉中应用广泛的边缘检测方法。

Canny 边缘检测算法包括四个部分：
1. 抑制噪声
2. 计算梯度大小与方向
3. 使用非极大值抑制
4. 双阈值的滞后阈值处理

在实际中，抑制噪声操作和计算梯度的大小方向操作，我们可以直接通过 Sobel 算子得到。所以后面主要介绍的是非极大值抑制和双阈值滞后阈值处理。

### 非极大值抑制

在 Canny 边缘算法中，作者认为边缘出现在梯度的极大值处，因此非极大值抑制方法舍弃了那些超过了阈值，但是却不是极大值的点。具体来说，非极大值抑制算法在求出了梯度大于阈值的点后，还会将其与周围的点的梯度进行比较，如果该点不是梯度极大值点，则舍弃。

设 $|\nabla G|(x,y)$ 是像素点 $(x,y)$ 处的梯度，那么有
$$
M(x,y)=\begin{cases}|\nabla G|(x,y) & \text{if} |\nabla G|(x,y) > |\nabla G| (x',y')\\ & \& |\nabla G|(x,y) > |\nabla G|(x'',y'')\\0& \text{otherwise}\end{cases}
$$
其中 $x'$ 与 $x''$ 都是沿着 $x$ 梯度方向的邻点。
![[Assets/Pasted image 20240104162706.png]]

对于非极大值抑制中的邻点的求法，有两个方式：
1. 将梯度方向离散化为四种情况，分别对应了
![[Assets/Pasted image 20240104162926.png]]
2. 使用梯度方向所在的直线穿过的所有部分进行插值，来拟合梯度方向上的边缘强度，可以更加准确的衡量梯度方向上的边缘强度。这种方式将梯度方向离散化为了下面的四种情况
![[Assets/Pasted image 20240104163058.png]]
其中第一种方式需要计算左上方和上方的插值，右下方和下方的插值。

该步骤因为只保留了极大值，抑制了非极大值，所以该步骤实际上是对 Sobel 边缘强度图进行了细化。

### 双阈值的滞后阈值处理

在经过非极大值抑制处理后的边缘强度图，一般需要经过阈值化处理。这里使用的滞后阈值处理使用了两个阈值，分别是高阈值和低阈值，按照下面的三个规则进行边缘的阈值化处理：
- 边缘强度大于高阈值的点作为确定边缘
- 边缘强度小于低阈值的点立即被剔除
- 边缘强度在低阈值和高阈值之间的点，按照下面的原则处理：
	- 只有这些点可以按照某一路径与确定边缘点相连时，才可以作为边缘点被接受。
	- 组成这一路径的所有点的边缘强度都要比低阈值大。

这一方法可以理解为，使用高阈值确定边缘点，然后基于低阈值尽可能的延长边缘，使得图像的边缘更加完整。
