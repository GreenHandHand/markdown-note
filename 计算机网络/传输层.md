---
tags:
  - 计算机网络
---

# 传输层

数据链路层提供链路上相邻节点之间的逻辑通信，网络层提供主机之间的逻辑通信。传输层位于网络层之上，应用层之下，它为运行在不同主机上的进程之间提供**逻辑通信**。传输层属于面向通信部分的最高层，同时也是用户功能中的最低层。显然，即使网络层协议不可靠，传输层同样能为应用程序提供可靠的服务。

> [!note] 传输层的功能
> 1. **应用进程之间的逻辑通信**；应用进程之间的通信称为**端到端的逻辑通信**，IP 协议虽然能把分组送到目的主机，但这个分组还停留在主机的网络层，而没有交付给主机中的进程。从传输层来看，通信的真正端点不是主机而是主机中的进程。
> 2. **复用和分用**：
> 	- **复用**：发送方不同的应用进程都可以使用同一传输层协议传送数据。
> 	- **分用**：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。
> 3. **检错检测**：传输层要对收到的报文进行差错检测。*在网络层，IP 数据报首部中的检验字段只检验首部是否出错，而不检查数据部分*。
> 	- 对于 TCP 协议，若接收方报文段出错，则要求发送方重发该报文段。
> 	- 对于 UDP 协议，若接收方发现数据报出错，则直接丢弃。
> 4. **提供面向连接和无连接的传输协议**：传输层向高层用户屏蔽了低层网络核心的细节，它使应用进程看见的是两个传输层实体之间好像有一条端到端的逻辑通信信道。
> 	- 采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的，单这种逻辑通信信道就相当于一条全双工的可靠信道。
> 	- 采用面向无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。
> 	- 网络层无法同时实现这两种协议。

## 传输层的寻址和端口

端口能让应用层的格式进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。端口在传输层的作用类似于 IP 地址在网络层的作用，只不过 IP 标识的是主机，而端口标识的是主机中的应用进程。

### 端口号

应用进程通过端口号进行标识，端口号长度为 16 比特，能够表示 65536 个不同的端口号。端口号具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号没有联系。根据端口号范围可以将端口分为两类：
1. **服务器端使用的端口号**。
	- **熟知端口号**，数值为 0~1023，IANA 把这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有用户都知道。
	- **登记端口号**，数值为 0~49151，供没有熟知端口号的应用程序使用的，使用这类端口号必须在 IANA 登记，以防止重复。
2. **客户端使用的端口号**，数值为 49152~65535，因为这类端口号仅在客户进程运行时才动态地选择，所以又称**短暂端口号**。当服务器进程收到客户进程的报文时，就直到了客户进程所使用的端口，因为可以把数据发送给客户进程。进程结束后，刚用过的客户端口号就不复存在，这个端口号可以供其他客户进程使用。

> [!tip]
> 1. 同一台计算机上，TCP 协议与 UDP 协议的端口号互不冲突，即可以重复。
> 2. 当两个进程之间想要通信时，需要指明：
> 	1. 使用哪种传输层协议
> 	2. 本进程绑定的端口号
> 	3. 对方的 IP 和端口号

### 套接字

在网络中通过 IP 地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，端口号拼接到 IP 地址即构成**套接字**(Socket)。在网络中采用发送方和接收方的套接字来识别端点。套接字实际上就是一个通信端点，即
$$
\text{套接字(Socket)}=\text{(IP地址:端口号)}
$$
它唯一地标识网络中的一台主机上的一个应用进程。

在网络通信中，主机 A 发给主机 B 的报文包含目的端口号和源端口号，源端口号是返回地址的一部分，即当主机 A 需要发回一个报文给主机 A 时，主机 B 到主机 A 的报文中的目的端口号便是主机 A 到主机 B 的报文中的源端口号。

> [!tip] 套接字分为 TCP 套接字和 UDP 套接字，它们是可以重复的

> [!note] TCP 与 UDP
> TCP/IP 协议族在 IP 层之上使用了两个传输协议：
> - 面向连接的传输控制协议 (TCP)：采用 TCP 时，传输层向上提供的是一条全双工的可靠逻辑信道。
> - 无连接的用户数据协议 (UDP)：采用 UDP 时，传输层向上提供的是一条不可靠的逻辑信道。

## UDP 协议

UDP 仅在 IP 层的数据报服务之上增加了两个最基本的功能：复用和分用，以及差错检测。

> [!note] UDP 协议的特点
> 1. UDP 无须建立连接。因此 UDP 不会引入建立连接的时延。
> 2. 无连接状态。TCP 需要在端系统中维护连接状态，此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。而 UDP 既不维护连接状态，也不跟踪这些参数。
> 3. UDP 的首部开销小。TCP 有 20B 的首部开销，而 UDP 仅有 8B 的开销。
> 4. UDP 没有拥塞控制，因此网络中的拥塞不会影响源主机的发送速率。
> 5. UDP 支持一对一、一对多、多对一和多对多的交互通信。

UDP 常用于一次性传输较少数据的网络应用，如 DNS、SNMP 等，因为对于这些应用，若采用 TCP，则将为连接创建、维护和拆除带来不少的开销。UDP 也常用于多媒体应用。显然，可靠数据传输对这些应用来说并不是重要的，但 TCP 的拥塞控制会导致数据出现较大的延迟，这时它们不可容忍的。

### UDP 的首部格式

UDP 数据报包含两部分：首部字段和用户数据字段。UDP 首部有 8B，由 4 个字段组成，每个字段的长度都是 2B。各字段意义如下：
1. **源端口**。源端口，在需要对方回信时选用，不需要时可全为 0。
2. **目的端口**。目的端口号。这在终点交付报文时必须用到。
3. **长度**。UDP 数据报的长度，单位 B，最小值为 8(仅有首部)。
4. **检验和**。检测 UDP 数据报在传输中是否有错，有错就丢弃。该字段是可选的，当源主机不想计算检验和时，则直接令该字段为全 0。

若接收方 UDP 发现收到的报文中目的端口号不正确，则丢弃该报文，并由 ICMP 发送端口不可达差错报文给对方。

### UDP 检验

在计算检验和时，要在 UDP 数据报之前增加 12B 的伪首部，伪首部并不是 UDP 的真正首部，只是在计算检验和时，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。检验和就是按照这个临时的 UDP 数据报来计算的。伪首部既不向下传送也不向上递交，只是为了计算检验和。
1. **构造临时 UDP 数据报**：
	- 发送方将 12 字节的伪首部添加到 UDP 数据报前面。
	- **伪首部**包括：源 IP 地址（4 字节）、目的 IP 地址（4 字节）、协议号（1 字节，值为 17 表示 UDP）、UDP 数据报长度（2 字节）。
	- 如果 UDP 数据报的数据部分不是偶数个字节，则在末尾补一个字节 0。
2. **计算 16 位字的和**：
	- 将临时 UDP 数据报视为多个 16 位字的序列。
	- ==**回卷**==：按二进制反码计算这些 16 位字的和。如果最高位有进位，则将进位加到最低位上。
	- 将计算得到的和按位取反，结果即为校验和。
3. **验证校验和**：
	- 接收方使用同样的方法计算 16 位字的和。
	- 将计算得到的和与接收到的校验和相加。
	- 如果结果为全 1（即 0xFFFF），则说明数据无误。

> [!tip]
> UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似，但是 IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和要将**首部和数据部分一起检验**。

> [!example]
> ![[image/传输层-1.png]]

## TCP 协议

TCP 是在不可靠的 IP 层之上实现的可靠数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP 是 TCP/IP 体系中非常复杂的一个协议。

> [!note] TCP 协议特点
> 1. TCP 是面向链接的传输层协议，TCP 连接的是一条逻辑链路。
> 2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是一对一的。
> 3. TCP 提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序。
> 4. TCP 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
> 	- 发送缓存存放：
> 		1. 发送应用程序传送给发送方 TCP 准备发送的数据。
> 		2. TCP 已发送但尚未收到确认的数据。
> 	- 接收方缓存存放：
> 		1. 按序到达但尚未被接收应用程序读取的数据。
> 		2. 不按序到达的数据。
> 5. TCP 是面向字节流的，虽然应用程序和 TCP 的交互是一次一个数据块 (大小不等)，但 TCP 是把应用程序交下来的数据仅视为一连串的无结构的字节流。

### TCP 报文段

![[image/传输层-2.png]]
1. 源端口与目的端口：各占 2B，分别表示发送方和接收方使用的端口号。
2. **序号**(seq)：占 4B，范围为 $0\sim 2^{32}-1$，共有 $2^{32}$ 个序号。TCP 连接中传送的字节流中的==每个字节==都要按顺序编号，序号字段值指的是本报文段所发送的数据的==第一个字节==的序号。*例如，一报文段的序号字段为 301，而携带的数据共有 100B，标明本报文段的数据的最后一个字节的序号是 400，因此下一个报文段的数据序号从 401 开始*。
3. **确认号**(ack 或 ack_seq)：占 4B，若确认号为 $N$，表示序号 $N-1$ 为止的所有数据都已经收到。
4. **数据偏移**(首部长度)：占 4 位，指出 TCP 首部的长度，单位为 4B。因为 4 位二进制能表示的最大值为 15，所以 TCP 首部的最大长度为 60B。
5. 保留：占 6 位，保留为以后使用，目前恒为 0。
6. URG：紧急位 (urgent)，当 URG=1 时，标明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。
7. **ACK**：确认位，当 ACK=1 确认号字段才有效。==只有握手①时，ACK=0，其他报文段 ACK=1==。
8. PSH：推送位 (push)，当 PSH=1 时，报文段应尽快交付应用进程，而不是得到整个缓存都填满后才交付，常用于交互式通信。
9. RST：复位位 (reset)，当 RST=1 时，表示 TCP 连接中出现严重差错，必须释放连接，然后重新建立传输连接。此外，它还可以用于拒绝非法报文段。
10. **SYN**：同步位 (synchronize)，当 SYN=1 时，表示这是一个请求连接或连接接收报文。==只有握手①和握手②中，SYN=1，其他报文的 SYN=0==。
11. **FIN**：终止位 (finish)，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放传输连接。==只有挥手①和挥手③中，FIN=1，其他报文的 FIN=0==。
12. **窗口**(rwnd 或 rcvwnd)：占 2B，窗口值告诉对方接收方还可以接收多少数据，以 1B 为单位。
13. 检验和：同 [[#UDP 检验]]，需要加上一个 12B 的伪首部，然后计算检验和。
14. 紧急指针：占 2B，当 URG=1 时才有意义，代表紧急数据的字节数，即紧急数据的序号。
15. 选项：长度可变，最长可达 40B。当不使用选项时，TCP 首部的长度为 20B。
	- **MSS**：最大报文段长度 (Maximum Segment Size)，TCP 报文段中数据字段的最大长度。
16. 填充：使得整个首部的长度为 4B。

### TCP 连接管理

TCP 是面向连接的协议，因此每个 TCP 连接都有三个阶段：建立连接、数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常进行。

TCP 连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为**客户**(Client)，而被动等待连接建立的应用进程称为**服务器**(Server)。

#### 三次握手

![[image/传输层-4.png]]
1. 客户机的 TCP 首先向服务器的 TCP 发送连接请求报文段。
	- 该报文段中 `SYN=1, ACK=0`。
	- 同时，客户机选择一个初始序号 `seq=x`。
	- TCP 规定，SYN 报文段不能携带数据，但是**要消耗一个序号**。
2. 服务器的 TCP 收到连接请求报文段后，如同一建立连接，则向客户机发回确认，并为该 TCP 连接分配缓存和变量。
	- 该报文段中 `SYN=1, ACK=1`。
	- 同时，服务器选择一个初始序号 `seq=y`，并发送 `ack=x+1` 指明下一个要接收的序号。
	- 该报文段同样是一个 SYN 报文段，因此不能携带数据，但是**要消耗一个序号**。
3. 客户机收到确认报文后，还要向服务器给出确认，并为该 TCP 连接分配缓存和变量。
	- 该报文段中 `SYN=0, ACK=1`。
	- 该报文段可以携带数据，也可以不携带数据。若不携带数据，则不消耗序号。

> [!tip] 牢记 `SYN` 只有在握手①与握手②中为 1，`ACK` 只有在握手①中为 1 即可

> [!note] 时间分析
> 常利用双向传播时延 RTT 来分析握手的时间。例如，从客户机发出请求开始，到客户机可以发送数据，经过了 RTT 的时间。从客户机发出请求开始，到服务器可以向客户机发送数据，经过了 1.5RTT 的时间。

#### 四次挥手

![[image/传输层-5.png]]
1. 客户机打算关闭连接时，向其服务器发送连接释放报文段，并停止发送数据，主动关闭 TCP 连接。
	- 该报文段中 `FIN=1`。
	- FIN 报文段可以携带数据，也可以不携带数据。即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文段后立即发出确认。
	- 该报文段中 `FIN=0`。
	- 由于 FIN 报文段固定多消耗一个序号，因此确认号 `ack` 为上一个报文段以传送过的数据的最后一个字节加 1。
3. 服务器在客户端关闭连接后，还可以继续发送数据。但是客户端无法再发送数据。当服务器已经没有要向客户机发送的数据时，就通知 TCP 释放连接。
	- 该报文段中 `FIN=1`。
	- 该 FIN 报文段同样可以携带数据，且要消耗一个序号。
4. 客户机收到连接释放报文段后，立即发出确认。
	- 该报文段中 `FIN=0`。
	- 由于客户机已经关闭连接，因此该报文段无法发送数据。
	- 在发送确认报文后，客户机需要等待 $2\times\text{MSL}$ 的时间，才能进入 CLOSED 阶段。

> [!note] 时间分析
> 常利用 RTT 与 MSL 来分析==最短==关闭时间。若在客户机提出关闭请求后，服务器没有任何需要发送的数据，即挥手②与挥手③中间的间隔时间趋于 0 时，关闭时间最短。此时：
> - 从客户机提出请求，到客户机关闭的最短时间为 RTT+2MSL
> - 从客户机提出请求，到服务器关闭的最短时间为 1.5RTT

> [!warning] 需要记住每个阶段的名称。建议在考前浏览一遍，留下印象。

### TCP 可靠传输

TCP 在不可靠的 IP 层之上建立了一种可靠数据传输服务。TCP 提供的可靠数据传输服务保证接收方从缓存区读出的字节流与发送方发出的字节流完全一样。TCP 使用了检验、序号、确认和重传等机制来达到这一目的。
1. **序号**：TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流上，而不是报文段上。
	- **TCP 连接传送的数据流中的每个字节都有一个序号**，每个报文段中的序号字段指报文段所发送的数据的第一个字节的序号。
2. **确认**：TCP 首部的确认号是期望收到对方的下一个报文段数据的第一个字节的序号。
	- TCP 默认使用累积确认，即 TCP 只确认数据流中至第一个丢失字节为之的字节。
3. **重传**：在 TCP 每发送一个报文，会为报文设置一个超时计时器。计数器设置的重传时间到期但还没有收到的确认时，就要重传这一报文段。
	- 由于 TCP 的下层是互联网环境，IP 数据报所选择的路由变化很大，所以传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP 采用了自适应算法。该算法记录一个报文段的发出时间，以及收到相应确认的时间，这两个时间之差称为报文段的**往返时间**(Round-Trip Time, RTT)。TCP 维护了 RTT 的一个加权平均往返时间 RTTS，它会随新测量 RTT 样本值的变化而变化。显然，超时计时器设置的**超时重传时间**(Retransmission Time-Out, RTO) 应略大于 RTTS，但是不能太多。
	- 超时重传机制有两种策略：**延迟确认**和**冗余 ACK**。

> [!note] 延迟确认
> 由于 TCP 使用累积确认的策略，因此当连续收到多个报文时，可以只返回一个 ACK。为了尽可能地利用延迟重传的优势，TCP 规定
> - 如果目前有需要发送的数据，则收到报文后，立即进行**捎带确认**。
> - 如果目前没有需要发送的数据，则收到报文后，最多等待 0.5s 再返回一个确认报文。如果在等待期间收到了其他报文，则可以利用累积确认的优势，减少确认的次数。

> [!note] 冗余 ACK 与快重传
> 使用延迟确认虽然可以减少确认的次数，但是在触发超时重传时，会导致需要重传较多的报文，于是提出了**冗余 ACK** 与**快重传机制**。
> - 快重传：接收方每接收到一个报文，则立即返回一个 ACK 报文。
> - 冗余 ACK：冗余 ACK 就是再次确认某个报文段的 ACK，而发送方先前已经收到过该报文段的确认。在使用快重传时，发送方可以在超时事件发生之前通过注意所谓的冗余 ACK 来较好地检测丢包情况。**TCP 规定，当发送方收到对同一个报文段的 3 个冗余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失**。

### TCP 流量控制

**流量控制**的功能就是让发送方的发送速率不要太快，以便让接收方来得及接收。TCP 利用滑动窗口机制来实现流量控制。
- 在发送方与接收方中，都维持一个固定大小的缓冲区，用于暂存发送和接收的数据。
- 在第②次握手中，接收方发送的报文中包含了自己的接收窗口大小。发送方可以根据该窗口大小，发送不超过接收方接收能力的数据。
- 接收方接收数据后，写入缓冲区，并在返回的 ACK 报文段包含剩余的缓冲区大小，发送方再根据这个报文提供的窗口大小进行发送。
- 当发送方的缓冲区中的数据被发送之后，由后来的数据填入。这个缓冲区可以看作 [[数据结构/栈、队列和数组#循环队列|循环队列]]。
- 接收方收到数据后填入缓冲区，当缓冲区填满之后，上交应用层。(只要接收的数据是有序的，就可以上交，不一定要等待缓冲区填满)

> [!note] 零窗口报文
> 在收到对方的报文时，可能此时缓冲区没有空闲空间，接收窗口大小为 0。此时发送方无法发送数据，TCP 为每个连接设有一个**持续计时器**，只要发送方收到对方的零窗口通知，就启动持续计时器。若计时器超时，就发送一个零窗口探测报文段，对方在确认这个报文段的 ACK 报文段中给出现在剩余的窗口值。如果给出的窗口值仍然为 0，则发送方在收到报文段后重新设置计数器。

### TCP 拥塞控制

**拥塞控制**是指防止过多的数据注入网络，保证网络中的路由器或链路不至于过载。出现拥塞时，端点并不了解拥塞发生的细节，对通信的端点来说，拥塞往往表现为通信时延的增加。

发送方在确定发送报文段的速率时，既要考虑接收方的接收能力，又要从全局考虑不要使网络发送拥塞。因此，发送方的发送窗口除了收到接收窗口的限制外，还受到**拥塞窗口**(cwnd) 的限制，发送窗口的大小规定为 `min(rwnd, cwnd)`，即接收窗口与拥塞窗口的最小值。发送方控制拥塞窗口的原则是：
- 只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去，以提高网络的利用率。
- 主要网络出现拥塞，拥塞窗口就减少一些，以缓解网络出现的拥塞。

TCP 进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传、快恢复。通常将它们组合使用：
- **慢开始**：在传输的开始，或者网络发生拥塞事件 (超时重传) 后，将拥塞窗口设置为 1。每经过一个 RTT，就将拥塞窗口翻倍，直到到达**慢开始门限 ssthresh**^[到达门限时截断，例如 `ssthresh=10, cwnd=8`，在一个 RTT 过后，`cwnd=10`，而不是 `cwnd=16`]。
- **拥塞避免**：当拥塞窗口超过 `ssthresh` 时，让拥塞缓慢的增大，具体做法就是每经过一个 RTT，只让拥塞窗口增大 1。
- **快重传**：即前文提到，每收到一个报文就返回一个 ACK。
- **快恢复**：当发送方连续收到 3 个冗余 ACK 时，说明网络*有些拥塞*，此时执行快恢复算法。快恢复算法直接将 `ssthresh` 设置为当前 `cwnd/2`，同时修改 `cwnd`。之后执行拥塞避免算法。

> [!example]- 网络发生超时重传
> ![[image/传输层-7.png]]
> 1. `t=0` 时，慢开始，拥塞窗口从零开始增长，每经过一个 RTT 翻倍。
> 2. `t=4` 时，达到阈值，进行拥塞避免算法，每经过一个 RTT，拥塞窗口加 1。
> 3. `t=12` 时，发生超时重传，网络拥塞，直接将拥塞窗口设置为 1，并将 `ssthresh` 设置为发生拥塞时的 `cwnd/2`，重新执行算法。

> [!example]- 网络发生快重传
> ![[image/传输层-6.png]]
> 1. `t=0` 时，慢开始，拥塞窗口从零开始增长，每经过一个 RTT 翻倍。
> 2. `t=4` 时，达到阈值，进行拥塞避免算法，每经过一个 RTT，拥塞窗口加 1。
> 3. `t=12` 时，连续收到三个冗余 ACK，网络略拥塞，快恢复，直接将 `sshresh` 减半，然后从 `sshresh` 开始执行拥塞避免算法。

---
< [[计算机网络/网络层|网络层]] | [[计算机网络/应用层|应用层]] >
