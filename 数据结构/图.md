---
tags:
  - 数据结构与算法
---

# 图

图 $G$ 是由顶点集 $V$ 和边集 $E$ 组成，记为 $G(V,E)$
- $V(G)$ 表示图 $G$ 中顶点的有限非空集，使用 $V=\left\{ v_{1},v_{2},\cdots,v_{n} \right\}$ 来描述一个图中的所有顶点，使用 $\left| V \right|$ 来代表顶点集的大小；
- $E(G)$ 表示图 $G$ 中顶点之间的关系集合，使用 $E=\left\{ \left( u,v \right)\mid u\in V,v\in V \right\}$ 来描述图中的边，使用 $\left| E \right|$ 来表示图 $G$ 中边的条数；

图可以用于建模复杂的多对多关系，每个实体与多个实体相连。在图论中，图作为主要的研究对象，引申出了一门完整的、严谨的数学体系。我们接下来提到的概念都来自图论。

> [!note]
> 线性表可以是空边，树可以是空树，但是图不能是空图，也就是说，图中不能一个顶点也没有。即，图的顶点集 $V$ 一定非空，但是边集 $E$ 可以为空。

## 关于图的概念与术语

图是一种复杂的数据结构，包含多个相关的概念和术语。在学习图时，我们需要了解以下基础概念：

### 图的基本定义

> [!definition|Definition] 有向图
> - 定义：若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 称为有向图。
> - 描述：在有向图中，使用 $<v, w>$ 表示从顶点 $v$ 指向顶点 $w$ 的有向弧。这里，$v$ 称为弧尾，$w$ 称为弧头，即 $v$ 邻接到 $w$。

> [!definition|Definition] 无向图
> 定义：若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 称为无向图。
> 描述：边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$。可以说 $w$ 和 $v$ 互为邻接点，或者边 $(v, w)$ 依附于 $v$ 和 $w$，也称该边与 $v, w$ 相关联。

其他图的定义
1. 简单图和多重图：如果图中不存在重复边或自环（顶点到自身的边），则称为简单图。在我们讨论中，默认图为简单图。
2. 完全图：在无向完全图中，任意两个顶点之间都存在边；在有向完全图中，任意两个顶点之间都有两条方向相反的弧。
3. 子图：设 $G=(V, E)$ 和 $G'=(V', E')$ 为两个图，如果 $V' \subseteq V$ 且 $E' \subseteq E$，则 $G'$ 是 $G$ 的子图。若 $V(G') = V(G)$，则称 $G'$ 为 $G$ 的生成子图。
4. 稠密图与稀疏图：边数较少的图称为稀疏图，反之为稠密图。一般而言，当 $\left| E \right| < \left| V \right|\log \left| V \right|$ 时，图被认为是稀疏图。
5. 有向树：一个有向图，若仅有一个顶点的入度为 0，其余顶点的入度均为 1，则称为有向树。

> [!note]
> 1. 无向完全图中有 $n(n-1)/2$ 条边。即任意两个顶点之间都有一条边，此时边数为 $C_{n}^{2}$。
> 2. 有向完全图中有 $n(n-1)$ 条边。即任意两个顶点之间都有存在方向相反的边，此时是所有顶点的一个排列，即 $A_{n}^{2}$。

### 图的基本概念

1. 顶点的度
	- 无向图：顶点 $v$ 的度是与其相连的边数，记为 $\text{TD}(v)$。
	- 有向图：
		- 出度：以顶点 $v$ 为起点的边数，记为 $\text{OD}(v)$。
		- 入度：以顶点 $v$ 为终点的边数，记为 $\text{ID}(v)$。
		- 总度：顶点 $v$ 的度为出度与入度之和，即 $\text{TD}(v) = \text{ID}(v) + \text{OD}(v)$。
2. 边的权与网
	- 定义：图中的每条边可以赋予一个具有特定含义的数值，称为权值。带权值的图称为带权图，也称为网。
3. 路径与路径长度
	- 路径：从顶点 $v_p$ 到顶点 $v_q$ 的路径是一个顶点序列 $v_p, v_{i_1}, v_{i_2}, \ldots, v_q$。
	- 路径长度：路径中边的数量。
4. 回路与简单路径
	- 回路（环）：路径的第一个顶点和最后一个顶点相同。
	- 简单路径：路径序列中，顶点不重复出现。
	- 简单回路：回路中，除了第一个和最后一个顶点外，其余顶点不重复。
5. 距离
	- 定义：若从顶点 $u$ 到顶点 $v$ 存在最短路径，则该路径的长度称为 $u$ 到 $v$ 的距离；若不存在路径，距离记为 $\infty$。

> [!note]
> 1. 一个有 $n$ 个顶点和 $n$ 条边的无向图一定是==有环的==。考虑最极端的情况，即 $n$ 个顶点与 $n-1$ 条边形成了一个链，此时无论在什么地方添加一条边，一定会导致形成回路。
> 2. 无向图中全部顶点的度数之和为边数的 2 倍。显然，每一个度对应了一条边，而一条边对应了与其相连的两个顶点的度。
> 3. 有向图中全部顶点的出度与入度之和相同，且等于边数。可以发现，每条有向边只对应了一个顶点的出度，一个顶点的入度，因此出度与入度的和都等于边数，且总度数为边数的 2 倍。

### 图的连通性

1. 无向图的连通性
	- 连通：若无向图中存在从顶点 $v$ 到顶点 $w$ 的路径，则称 $v$ 和 $w$ 连通。
	- 连通图：无向图 $G$ 中任意两个顶点都是连通的，则 $G$ 为连通图，否则为非连通图。
	- 连通分量：无向图中的极大连通子图称为连通分量。
2. 有向图的连通性
	- 强连通：若有向图中存在从顶点 $v$ 到顶点 $w$ 的路径，且存在从 $w$ 到 $v$ 的路径，则称 $v$ 和 $w$ 强连通。
	- 强连通图：有向图 $G$ 中任意两个顶点都是强连通的，则称该图为强连通图。
	- 强连通分量：有向图中的极大强连通子图称为强连通分量。
3. 生成树：包含图中所有顶点的一个极小连通子图，且去掉任何一条边会导致图不连通。
4. 生成森林：在非连通图中，由各连通分量的生成树构成的图称为生成森林。

> [!note]
> 1. 连通分量可以这样理解：连通分量就像是迷宫中的一个个独立的小圈子或者小团体，每个小团体内部的成员都能直接或间接地找到彼此，但是不同的小团体之间没有直接相连的门，也就是说它们彼此是隔离的。

## 图的存储

图的存储必须要完整、准确的反映顶点集和边集的信息，根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响。

### 邻接矩阵

使用邻接矩阵存储，是值用一个一维数组存储图中的顶点信息，用一个二维数组存储图中边的信息。存储顶点之间邻接关系的二维数组称为**邻接矩阵**。

设顶点数为 $n$ 的图 $G=(V,E)$ 的邻接矩阵 $A$ 是 $n\times n$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n}$，则邻接矩阵为
$$
A[i][j]=\begin{cases}
1,&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
$$

> [!note] 带全图的邻接矩阵
> 对于带权图而言，若顶点 $v_{i}$ 与 $v_{j}$ 有边相连，则邻接矩阵中对应项应该存放该边对应的权值。若不相连，则存放 $0$ 或者 $\infty$。
> $$
A[i][j]=\begin{cases}
w_{ij},&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0\text{或}\infty,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
> $$

```cpp
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct{
	VertexType vex[MaxVertexNum];
	EdgeType edge[MaxVertexNum][MaxVertexNum];
	int vexNum, arcNum;
}MGraph;
```

> [!note]
> 1. 在一些简单的应用中，不需要用到顶点的信息，则使用邻接矩阵就可以表示一张图。
> 2. 当邻接矩阵中不需要使用权值时，`EdgeType`可以直接使用枚举类型。
> 3. 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可以采用[[数据结构/栈、队列和数组#对称矩阵|对称矩阵的压缩存储]]。
> 4. 邻接矩阵的空间复杂度为 $O(|V|^{2})$。

> [!example] 基于邻接矩阵的顶点的度的计算
> 1. 对于无向图，邻接矩阵的第 $i$ 行 (列) 非零元素的个数正好是顶点 $i$ 的度 $\text{TD}(v_{i})$
> 2. 对于有向图，邻接矩阵第 $i$ 行非零元素的个数正好是顶点 $i$ 的出度 $\text{OD}(v_{i})$，第 $j$ 列非零元素的个数正好是顶点 $i$ 的入度 $\text{ID}(v_{i})$
> 3. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边，但是要确定图中有多少边，必须按行、列对每个元素进行检测。
> 4. 稠密图适合使用邻接矩阵存储。

> [!tip] 在图论中，可以证明，$A^{n}[i][j]$ 表示从 $i$ 出发到 $j$ 的长度为 $n$ 的路径。

### 邻接表

当一个图为系数图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了[[数据结构/线性表|线性表]]的顺序存储和链式存储方法，大大减少了这些浪费。

在邻接表法中，对 $G$ 的每个顶点 $v_{i}$ 建立了一个单链表，第 $i$ 个单链表中的结点表示从 $v_{i}$ 出发的有向边，这个单链表称为 $v_{i}$ 的边表 (对于有向图则为出边表)。边表的头指针和顶点的数据信息使用顺序存储，称为顶点表。
- 顶点表结点由顶点域存储顶点 $v_{i}$ 的信息，边表头指针域存储指向第一条边的边表结点。
- 边表结点由邻接点域存储与头结点顶点 $v_{i}$ 邻接的顶点编号，指针域指向下一条边的边表结点。

```cpp
#define MaxVertexNum 100
typedef struct ArcNode{
	int adjvex;
	struct ArcNode* nextarc;
	// InfoType info;
}ArcNode;
typedef struct VNode{
	VertexType data;
	ArcNode* firstarc;
}VNode, AdjList[MaxVertexNum];
typedef struct{
	AdjList vertices;
	int vexNum, arcNum;
}ALGraph;
```

若 $G$ 是无向图，则需要的存储空间为 $O(\left| V \right|+2\left| E \right|)$，因为无向边需要分别存储在两个顶点的邻接表中。若 $G$ 是有向图，则需要存储的空间为 $O(\left| V \right|+\left| E \right|)$。

> [!tip] 邻接矩阵与邻接表的对比
> 1. 对于稀疏图，采用邻接表表示将极大的节省存储空间。
> 2. 在邻接表中，给定一个顶点，可以很方便的找出它的所有邻边。在邻接矩阵中，找出一个顶点的邻边需要遍历邻接矩阵的一行，即遍历 $\left| V \right|$ 次。
> 3. 在邻接表中，要确定两个顶点间是否存在边，需要在相应的结点中查找另一个结点，效率很低。在邻接矩阵中，只需要直接查询即可。
> 4. 在无向图的邻接表中，计算某个结点的度数可以通过计算其邻接表中的边数。在有向图的邻接表中，计算某个结点的出度可以直接统计邻接表中的边数，但是计算某个结点的入度就需要遍历整个邻接表。
> 5. 图的邻接表表示不唯一。

### 十字链表

十字链表是==有向图==的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点来表，每个顶点也用一个结点来表示。
- 弧结点：
	- `tailVex`和`headVex`分别存储弧头和弧尾所在的顶点的编号。
	- `hlink`指向弧头所在顶点的下一个指出的弧。
	- `tlink`指向弧尾所在顶点的下一个指入的弧。
	- `info`域存储该弧的数据 (例如权重)。
- 顶点结点：
	- `data`域存储顶点数据。
	- `firstIn`指向以该顶点为弧头的第一个弧结点。
	- `firstOut`指向以该顶点为弧尾的第一个弧结点。

十字链表的空间复杂度为 $O(|V|+|E|)$，即只需要保存所有顶点和所有的边即可。

> [!note] 十字链表的思想
> 当用邻接表来表示有向图时，每个节点仅记录了它发出的所有边（也就是从该节点出发指向其他节点的“箭头”）。这样一来，如果我们想要找出所有指向某个特定节点的边，就需要检查每一个可能指向该节点的其他节点，这无疑会增加计算负担。
>
> 十字链表巧妙地解决了这个问题，它不仅记录了从一个节点出发的所有边，还记录了所有指向该节点的边。简单来说，在每个节点的数据结构中，我们设置了两条链表：一条用于跟踪该节点发出的边（称为**出边链表**），另一条用于追踪指向该节点的边（称为**入边链表**）。
>
> 然而，这样的设计会导致一定的冗余：如果节点 AA 有一条边指向节点 BB，那么这条边会在 AA 的出边链表和 BB 的入边链表中各出现一次，从而导致信息重复。
>
> 为了解决这个冗余问题，十字链表采用了**弧结点**的概念。每个弧结点包含了关于某条边的所有信息，并且被同时包含在起点的出边链表和终点的入边链表中。这样一来，无论何时查看某条边的信息，你只需要访问一个弧结点即可，大大减少了存储空间的需求。
>
> 简而言之，十字链表就像是将原来的出边链表和入边链表巧妙地编织在一起，让每条边的信息都被高效、准确地表示出来。

### 邻接多重表

对于无向图的邻接表存储方式，我们也可以发现每个**出边链表**中存储冗余的数据。邻接多重表同样引入边结点和顶点结点，从而减少数据的冗余。
- 边结点：
	- `i`和`j`：存储边的两个顶点的标号。
	- `iLink`：依附于顶点`i`的下一条边。
	- `jLink`：依附于顶点`j`的下一条边。
	- `info`域存储该边的数据。
- 顶点结点：
	- `data`域存储数据。
	- `firstedge`：与该结点的第一条边相连。

> [!note]
> - 在邻接多重表中删除边，只需要修改指向该边的指针，使其指向该边结点中对应的下一个边结点即可。
>
> - 在邻接多重表中删除顶点，只需要先删除该结点指针域指向的链表中的所有边结点，然后再删除该结点即可。

## 图的基本操作

|              名称              |   操作   | 解释                                                                      |
| :--------------------------: | :----: | :---------------------------------------------------------------------- |
|     `Adjacent(G, x, y)`      |  判断边   | 判断图`G`是否存在边`<x,y>`或者`(x,y)`                                             |
|      `Neighbors(G, x)`       |  求邻居   | 列出图`G`中与结点`x`邻接的边                                                       |
|     `InsertVertex(G, x)`     |  插入顶点  | 在图`G`中插入顶点`x`                                                           |
|     `DeleteVertex(G, x)`     |  删除顶点  | 在图`G`中删除顶点`x`                                                           |
|      `AddEdge(G, x, y)`      |  添加边   | 若边`(x,y)`或者`<x,y>`不存在，则向图`G`中添加该边                                       |
|    `RemoveEdge(G, x, y)`     |  删除边   | 若边`(x,y)`或者`<x,y>`存在，则从图`G`中删除该边                                        |
|    `FirstNeighbor(G, x)`     | 第一个邻接点 | 求图`G`中顶点`x`的第一个邻接点，若有则返回顶点号。若没有，则返回`-1`                                 |
|   `NextNeighbor(G, x, y)`    | 下一个邻接点 | 假设图`G`中顶点`y`是顶点`x`的一个邻接点，返回除`y`外顶点`x`的下一个邻接顶点号。若`y`是`x`的最后一个邻接点，则返回`-1` |
|  `Get_edge_value(G, x, y)`   |  边权值   | 获取图`G`中边`<x,y>`或者`(x,y)`对应的权值                                           |
| `Set_edge_value(G, x, y, v)` | 设置边权值  | 设置图`G`中边`(x,y)`或者`<x,y>`对应的边权值为`v`                                      |

图的结构较为复杂，且对于不同的任务，针对性强。因此这里列出的是图结构常用的基本操作，在实际的实现中，会根据任务的特性，设计相关的算法。

## 图的遍历

图的遍历指从图的某一个顶点出发，按照某种搜索方式沿着图中的边对图的所有顶点访问*一次*。图的遍历比[[数据结构/树与二叉树#树和森林的遍历|树的遍历]]复杂的多，图中的任意一个顶点都可能与其余顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点，因此为了避免同一个顶点被访问多次，在遍历图的过程中需要记录每个已经访问过的顶点。

### 广度优先搜索

广度优先搜索 (Breadth-First-Search, BFS) 类似与二叉树的层序遍历算法。其伪代码如下：
```cpp
bool visited[MAX_VERTEX_NUM];
void BFSTraverse(Graph &G){
	for(int i = 0; i < G.vexNum; i++){
		visited[i] = false;
	}
	Queue Q = new Queue;

	// 对于所有的顶点，进行 BFS 遍历
	// - 如果确定图是连通的，只需要从一个顶点开始就
	// 可以遍历整个图，只需要调用一次BFS
	// - 如果不是连通的，就需要至少对每个连通分量调用一次BFS
	for(int i = 0; i < G.vexNum; i++){
		if(!visited[i]){
			BFS(G, i);
		}
	}
}

void BFS(Graph &G, int i, Queue &Q){
	visit(i);
	visited[i] = true;
	Q.enQueue(i);
	while( !Q.isEmpty() ){
		current = Q.deQueue();
		// 遍历 new_i 的所有邻接顶点
		for(auto j : G.getNeighbors(current)){
			if(visited[j] == false){
				visit(j);
				visited[j] = true;
				EnQueue(Q, j);
			}
		}
	}
}
```

> [!note] BFS 算法性能分析
> 无论是采用邻接表还是邻接矩阵作为存储方式，BFS 算法都需要借助一个辅助队列 $Q$，每个顶点恰好入队和出队一次。因此，在最坏的情况下，空间复杂度主要由队列决定，为 $O(|V|)$。
>
> 遍历图的过程实际上是对每个顶点查找其邻接点的过程，耗费的时间与存储结构有关：
> - **邻接表**：在搜索过程中，每个顶点都会被访问一次。在搜索顶点的邻接点时，需要访问该顶点的整个邻接表，邻接表中的结点数代表与该顶点相连的边的数量。因此，访问所有邻接表的时间复杂度为 $O(|E|)$。综合考虑，总的时间复杂度为 $O(|V| + |E|)$。
> - **邻接矩阵**：在搜索过程中，每个顶点都会被访问一次。在搜索每个顶点的邻接点时，会把邻接矩阵对应行遍历一次以确定哪些顶点是它的邻接点，时间复杂度为 $O(|V|)$。因为这一过程需要对每个顶点执行，所以总的时间复杂度为 $O(|V|^2)$。

> [!example]
> 1. 单源最短路径：通过 BFS 算法可以求解单源最短路径问题，因为广度优先搜索总是按照距离由近到远来遍历图中的每个顶点的。
> 2. 广度优先生成树：在 BFS 遍历图的过程中，我们可以得到一棵遍历树，称为*广度优先生成树*。
> 	- 对于使用邻接矩阵存储的图，由于邻接矩阵是唯一的，因此其广度优先生成树也是唯一的
> 	- 对于使用邻接表存储的图，由于邻接表是不唯一的，因此其广度优先生成树也是不唯一的

### 深度优先搜索

深度优先搜索 (Depth-First-Search, DFS) 类似与[[数据结构/树与二叉树#先序遍历|树的先序遍历]]，该算法总是尽可能深的搜索一个图，直到没有邻接结点为止，在退回到之前的搜索中。其伪代码如下：
```cpp
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph &G){
	for(int i = 0; i < G.vexNum; i++){
		visited[i] = false;
	}
	for(int i = 0; i < G.vexNum; i++){
		if(!visited[i]){
			DFS(G, i);
		}
	}
}

void DFS(Graph &G, int i){
	visit(i);
	visited[i] = true;
	for(auto j : G.getNeighbors(i)){
		if(visited[j] == false){
			DFS(G, j);
		}
	}
}
```

> [!note] DFS 算法性能分析
> DFS（深度优先搜索）是一个递归算法，它使用一个递归工作栈来追踪搜索路径。在最坏的情况下，即图呈现为一条链式结构时，DFS 需要将所有顶点入栈，因此空间复杂度为 $O(|V|)$。
>
> DFS 算法与 BFS 算法的时间复杂度相同，它们的区别仅在遍历的顺序上，因为 BFS 算法使用队列，DFS 算法使用栈。
>
> 在遍历图的过程中，DFS 对每个顶点只访问一次，并通过递归的方式探索每个顶点的所有邻接点，直到无法继续为止。遍历的时间复杂度与存储结构有关：
> - **邻接表**：对于每个顶点，DFS 会访问其所有的邻接点，每个顶点及其邻接点仅被访问一次。因此，总的访问次数为所有顶点的邻接点数量之和，即边的数量 $|E|$。因此，总的时间复杂度为 $O(|V| + |E|)$。
> - **邻接矩阵**：对于每个顶点，DFS 会检查其与所有其他顶点的连接情况，这意味着会遍历邻接矩阵的一整行。由于每个顶点都会被访问一次，并且每次访问都会遍历一行，总的时间复杂度为 $O(|V|^2)$。

> [!warning]
> - 图的邻接矩阵是唯一的，因此基于邻接矩阵遍历得到的 DFS 序列和 BFS 序列是唯一的。
> - 图的邻接表是不唯一的，因此基于邻接表遍历得到的 DFS 序列和 BFS 序列是不唯一的。

> [!example]
> 同样的，深度优先遍历也会产生一棵深度优先生成树 (或者森林)，与 BFS 类似，基于邻接表存储的深度优先生成树不是唯一的，基于邻接矩阵的深度优先生成树是唯一的。

### 图的连通性

图的遍历算法能够用于判断图的连通性。
- 对于无向图来说，如果从任意一个顶点出发，一次遍历就可以访问所有顶点，那么无向图是连通的。
- 对于有向图来说，如果从任意一个顶点出发，能够访问全部顶点，那么有向图是强连通的。(弱连通可以先将有向图转换为无向图)

> [!tip]
> 根据连通和强连通的定义，我们可以很自然的得到判断连通图的算法： 以无向图为例，从任意一个顶点出发，使用一次BFS或DFS遍历整个图。如果遍历结束后所有顶点都被访问过（visited数组全为true），则图是连通的；否则，图不是连通的。
>
> 此外，如果我们从每个未被访问过的顶点出发，使用BFS或DFS进行遍历，并为每个遍历到的新连通分量分配一个不同的编号。这样，每个顶点都会被标记为其所在连通分量的编号。

## 图的应用

### 最小生成树

> [!definition|Definition] 最小生成树
> 一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。
>
> 对于一个**带权连通无向图**$G$，生成树不同，每棵树的权^[树中所有边上的权值之和]也可能不同。权值之和最小的那颗生成树称为 $G$ 的**最小生成树**(Minimum-Spanning-Tree, MST)。

> [!note] 最小生成树的性质
> 1. 若 $G$ 中存在权值相同的边，则 $G$ 的最小生成树不唯一，但是最小生成树的权是唯一的，且是最小的。
> 2. 当图 $G$ 中各边的权值互不相等时，$G$ 的最小生成树是唯一的。
> 3. 若 $G$ 本事就是一颗树 (即$|E|=|V|-1$)，那么 $G$ 的最小生成树就是它本身。
> 4. 最小生成树的边数等于顶点数减 1。

> [!warning] 最小生成树中所有边的权值和最小，但是不能保证任意两个顶点之间的路径的权值和最小，即不能保证是最短路径。

### 最小生成树的构造

最小生成树具有局部最优子结构的性质，即：
> 假设 $G=(V,E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集，若 $(u,v)$ 是一条具有最小权值的边，其中 $u\in U,v\in V-U$，则必存在一颗包含边 $(u,v)$ 的最小生成树。

基于该性质的最小生成树算法主要有`Prim`算法和`Kruskal`算法，它们都是基于贪心算法的策略，实际上是下面算法的不同实现：
```lua
function genericMST(G):
	T = NULL
	while T 不是最小生成树:
		找到一条最小代价边 (u,v) 并且加入 T 后不会产生回路
		将 (u,v) 加入最小生成树
	return T
```

#### Prim算法

Prim 算法的执行非常类似于寻找图的最短路径的 Dijkstra 算法。


### 最短路径

### 拓扑排序

### 关键路径
