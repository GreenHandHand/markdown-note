---
tags:
  - 数据结构与算法
---

# 图

图 $G$ 是由顶点集 $V$ 和边集 $E$ 组成，记为 $G(V,E)$
- $V(G)$ 表示图 $G$ 中顶点的有限非空集，使用 $V=\left\{ v_{1},v_{2},\cdots,v_{n} \right\}$ 来描述一个图中的所有顶点，使用 $\left| V \right|$ 来代表顶点集的大小；
- $E(G)$ 表示图 $G$ 中顶点之间的关系集合，使用 $E=\left\{ \left( u,v \right)\mid u\in V,v\in V \right\}$ 来描述图中的边，使用 $\left| E \right|$ 来表示图 $G$ 中边的条数；

图可以用于建模复杂的多对多关系，每个实体与多个实体相连。在图论中，图作为主要的研究对象，引申出了一门完整的、严谨的数学体系。我们接下来提到的概念都来自图论。

> [!note]
> 线性表可以是空边，树可以是空树，但是图不能是空图，也就是说，图中不能一个顶点也没有。即，图的顶点集 $V$ 一定非空，但是边集 $E$ 可以为空。

## 关于图的概念与术语

图是一种复杂的数据结构，包含多个相关的概念和术语。在学习图时，我们需要了解以下基础概念：

### 图的基本定义

> [!definition|Definition] 有向图
> - 定义：若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 称为有向图。
> - 描述：在有向图中，使用 $<v, w>$ 表示从顶点 $v$ 指向顶点 $w$ 的有向弧。这里，$v$ 称为弧尾，$w$ 称为弧头，即 $v$ 邻接到 $w$。

> [!definition|Definition] 无向图
> 定义：若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 称为无向图。
> 描述：边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$。可以说 $w$ 和 $v$ 互为邻接点，或者边 $(v, w)$ 依附于 $v$ 和 $w$，也称该边与 $v, w$ 相关联。

其他图的定义
1. 简单图和多重图：如果图中不存在重复边或自环（顶点到自身的边），则称为简单图。在我们讨论中，默认图为简单图。
2. 完全图：在无向完全图中，任意两个顶点之间都存在边；在有向完全图中，任意两个顶点之间都有两条方向相反的弧。
3. 子图：设 $G=(V, E)$ 和 $G'=(V', E')$ 为两个图，如果 $V' \subseteq V$ 且 $E' \subseteq E$，则 $G'$ 是 $G$ 的子图。若 $V(G') = V(G)$，则称 $G'$ 为 $G$ 的生成子图。
4. 稠密图与稀疏图：边数较少的图称为稀疏图，反之为稠密图。一般而言，当 $\left| E \right| < \left| V \right|\log \left| V \right|$ 时，图被认为是稀疏图。
5. 有向树：一个有向图，若仅有一个顶点的入度为 0，其余顶点的入度均为 1，则称为有向树。

> [!note]
> 1. 无向完全图中有 $n(n-1)/2$ 条边。即任意两个顶点之间都有一条边，此时边数为 $C_{n}^{2}$。
> 2. 有向完全图中有 $n(n-1)$ 条边。即任意两个顶点之间都有存在方向相反的边，此时是所有顶点的一个排列，即 $A_{n}^{2}$。

### 图的基本概念

1. 顶点的度
	- 无向图：顶点 $v$ 的度是与其相连的边数，记为 $\text{TD}(v)$。
	- 有向图：
		- 出度：以顶点 $v$ 为起点的边数，记为 $\text{OD}(v)$。
		- 入度：以顶点 $v$ 为终点的边数，记为 $\text{ID}(v)$。
		- 总度：顶点 $v$ 的度为出度与入度之和，即 $\text{TD}(v) = \text{ID}(v) + \text{OD}(v)$。
2. 边的权与网
	- 定义：图中的每条边可以赋予一个具有特定含义的数值，称为权值。带权值的图称为带权图，也称为网。
3. 路径与路径长度
	- 路径：从顶点 $v_p$ 到顶点 $v_q$ 的路径是一个顶点序列 $v_p, v_{i_1}, v_{i_2}, \ldots, v_q$。
	- 路径长度：路径中边的数量。
4. 回路与简单路径
	- 回路（环）：路径的第一个顶点和最后一个顶点相同。
	- 简单路径：路径序列中，顶点不重复出现。
	- 简单回路：回路中，除了第一个和最后一个顶点外，其余顶点不重复。
5. 距离
	- 定义：若从顶点 $u$ 到顶点 $v$ 存在最短路径，则该路径的长度称为 $u$ 到 $v$ 的距离；若不存在路径，距离记为 $\infty$。

> [!note]
> 1. 一个有 $n$ 个顶点和 $n$ 条边的无向图一定是==有环的==。考虑最极端的情况，即 $n$ 个顶点与 $n-1$ 条边形成了一个链，此时无论在什么地方添加一条边，一定会导致形成回路。
> 2. 无向图中全部顶点的度数之和为边数的 2 倍。显然，每一个度对应了一条边，而一条边对应了与其相连的两个顶点的度。
> 3. 有向图中全部顶点的出度与入度之和相同，且等于边数。可以发现，每条有向边只对应了一个顶点的出度，一个顶点的入度，因此出度与入度的和都等于边数，且总度数为边数的 2 倍。

### 图的连通性

1. 无向图的连通性
	- 连通：若无向图中存在从顶点 $v$ 到顶点 $w$ 的路径，则称 $v$ 和 $w$ 连通。
	- 连通图：无向图 $G$ 中任意两个顶点都是连通的，则 $G$ 为连通图，否则为非连通图。
	- 连通分量：无向图中的极大连通子图称为连通分量。
2. 有向图的连通性
	- 强连通：若有向图中存在从顶点 $v$ 到顶点 $w$ 的路径，且存在从 $w$ 到 $v$ 的路径，则称 $v$ 和 $w$ 强连通。
	- 强连通图：有向图 $G$ 中任意两个顶点都是强连通的，则称该图为强连通图。
	- 强连通分量：有向图中的极大强连通子图称为强连通分量。
3. 生成树：包含图中所有顶点的一个极小连通子图，且去掉任何一条边会导致图不连通。
4. 生成森林：在非连通图中，由各连通分量的生成树构成的图称为生成森林。

> [!note]
> 1. 连通分量可以这样理解：连通分量就像是迷宫中的一个个独立的小圈子或者小团体，每个小团体内部的成员都能直接或间接地找到彼此，但是不同的小团体之间没有直接相连的门，也就是说它们彼此是隔离的。

## 图的存储

图的存储必须要完整、准确的反映顶点集和边集的信息，根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响。

### 邻接矩阵

使用邻接矩阵存储，是值用一个一维数组存储图中的顶点信息，用一个二维数组存储图中边的信息。存储顶点之间邻接关系的二维数组称为**邻接矩阵**。

设顶点数为 $n$ 的图 $G=(V,E)$ 的邻接矩阵 $A$ 是 $n\times n$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n}$，则邻接矩阵为
$$
A[i][j]=\begin{cases}
1,&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
$$

> [!note] 带全图的邻接矩阵
> 对于带权图而言，若顶点 $v_{i}$ 与 $v_{j}$ 有边相连，则邻接矩阵中对应项应该存放该边对应的权值。若不相连，则存放 $0$ 或者 $\infty$。
> $$
A[i][j]=\begin{cases}
w_{ij},&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0\text{或}\infty,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
> $$

```cpp
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct{
	VertexType vex[MaxVertexNum];
	EdgeType edge[MaxVertexNum][MaxVertexNum];
	int vexNum, arcNum;
}MGraph;
```

> [!note]
> 1. 在一些简单的应用中，不需要用到顶点的信息，则使用邻接矩阵就可以表示一张图。
> 2. 当邻接矩阵中不需要使用权值时，`EdgeType`可以直接使用枚举类型。
> 3. 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可以采用[[数据结构/栈、队列和数组#对称矩阵|对称矩阵的压缩存储]]。
> 4. 邻接矩阵的空间复杂度为 $O(|V|^{2})$。

> [!example] 基于邻接矩阵的顶点的度的计算
> 1. 对于无向图，邻接矩阵的第 $i$ 行 (列) 非零元素的个数正好是顶点 $i$ 的度 $\text{TD}(v_{i})$
> 2. 对于有向图，邻接矩阵第 $i$ 行非零元素的个数正好是顶点 $i$ 的出度 $\text{OD}(v_{i})$，第 $j$ 列非零元素的个数正好是顶点 $i$ 的入度 $\text{ID}(v_{i})$
> 3. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边，但是要确定图中有多少边，必须按行、列对每个元素进行检测。
> 4. 稠密图适合使用邻接矩阵存储。

> [!tip] 在图论中，可以证明，$A^{n}[i][j]$ 表示从 $i$ 出发到 $j$ 的长度为 $n$ 的路径的数量。

### 邻接表

当一个图为系数图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了[[数据结构/线性表|线性表]]的顺序存储和链式存储方法，大大减少了这些浪费。

在邻接表法中，对 $G$ 的每个顶点 $v_{i}$ 建立了一个单链表，第 $i$ 个单链表中的结点表示从 $v_{i}$ 出发的有向边，这个单链表称为 $v_{i}$ 的边表 (对于有向图则为出边表)。边表的头指针和顶点的数据信息使用顺序存储，称为顶点表。
- 顶点表结点由顶点域存储顶点 $v_{i}$ 的信息，边表头指针域存储指向第一条边的边表结点。
- 边表结点由邻接点域存储与头结点顶点 $v_{i}$ 邻接的顶点编号，指针域指向下一条边的边表结点。

```cpp
#define MaxVertexNum 100
typedef struct ArcNode{
	int adjvex;
	struct ArcNode* nextarc;
	// InfoType info;
}ArcNode;
typedef struct VNode{
	VertexType data;
	ArcNode* firstarc;
}VNode, AdjList[MaxVertexNum];
typedef struct{
	AdjList vertices;
	int vexNum, arcNum;
}ALGraph;
```

若 $G$ 是无向图，则需要的存储空间为 $O(\left| V \right|+2\left| E \right|)$，因为无向边需要分别存储在两个顶点的邻接表中。若 $G$ 是有向图，则需要存储的空间为 $O(\left| V \right|+\left| E \right|)$。

> [!tip] 邻接矩阵与邻接表的对比
> 1. 对于稀疏图，采用邻接表表示将极大的节省存储空间。
> 2. 在邻接表中，给定一个顶点，可以很方便的找出它的所有邻边。在邻接矩阵中，找出一个顶点的邻边需要遍历邻接矩阵的一行，即遍历 $\left| V \right|$ 次。
> 3. 在邻接表中，要确定两个顶点间是否存在边，需要在相应的结点中查找另一个结点，效率很低。在邻接矩阵中，只需要直接查询即可。
> 4. 在无向图的邻接表中，计算某个结点的度数可以通过计算其邻接表中的边数。在有向图的邻接表中，计算某个结点的出度可以直接统计邻接表中的边数，但是计算某个结点的入度就需要遍历整个邻接表。
> 5. 图的邻接表表示不唯一。

### 十字链表

十字链表是==有向图==的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点来表，每个顶点也用一个结点来表示。
- 弧结点：
	- `tailVex`和`headVex`分别存储弧头和弧尾所在的顶点的编号。
	- `hlink`指向弧头所在顶点的下一个指出的弧。
	- `tlink`指向弧尾所在顶点的下一个指入的弧。
	- `info`域存储该弧的数据 (例如权重)。
- 顶点结点：
	- `data`域存储顶点数据。
	- `firstIn`指向以该顶点为弧头的第一个弧结点。
	- `firstOut`指向以该顶点为弧尾的第一个弧结点。

十字链表的空间复杂度为 $O(|V|+|E|)$，即只需要保存所有顶点和所有的边即可。

> [!note] 十字链表的思想
> 当用邻接表来表示有向图时，每个节点仅记录了它发出的所有边（也就是从该节点出发指向其他节点的“箭头”）。这样一来，如果我们想要找出所有指向某个特定节点的边，就需要检查每一个可能指向该节点的其他节点，这无疑会增加计算负担。
>
> 十字链表巧妙地解决了这个问题，它不仅记录了从一个节点出发的所有边，还记录了所有指向该节点的边。简单来说，在每个节点的数据结构中，我们设置了两条链表：一条用于跟踪该节点发出的边（称为**出边链表**），另一条用于追踪指向该节点的边（称为**入边链表**）。
>
> 然而，这样的设计会导致一定的冗余：如果节点 AA 有一条边指向节点 BB，那么这条边会在 AA 的出边链表和 BB 的入边链表中各出现一次，从而导致信息重复。
>
> 为了解决这个冗余问题，十字链表采用了**弧结点**的概念。每个弧结点包含了关于某条边的所有信息，并且被同时包含在起点的出边链表和终点的入边链表中。这样一来，无论何时查看某条边的信息，你只需要访问一个弧结点即可，大大减少了存储空间的需求。
>
> 简而言之，十字链表就像是将原来的出边链表和入边链表巧妙地编织在一起，让每条边的信息都被高效、准确地表示出来。

### 邻接多重表

对于无向图的邻接表存储方式，我们也可以发现每个**出边链表**中存储冗余的数据。邻接多重表同样引入边结点和顶点结点，从而减少数据的冗余。
- 边结点：
	- `i`和`j`：存储边的两个顶点的标号。
	- `iLink`：依附于顶点`i`的下一条边。
	- `jLink`：依附于顶点`j`的下一条边。
	- `info`域存储该边的数据。
- 顶点结点：
	- `data`域存储数据。
	- `firstedge`：与该结点的第一条边相连。

> [!note]
> - 在邻接多重表中删除边，只需要修改指向该边的指针，使其指向该边结点中对应的下一个边结点即可。
>
> - 在邻接多重表中删除顶点，只需要先删除该结点指针域指向的链表中的所有边结点，然后再删除该结点即可。

## 图的基本操作

|              名称              |   操作   | 解释                                                                      |
| :--------------------------: | :----: | :---------------------------------------------------------------------- |
|     `Adjacent(G, x, y)`      |  判断边   | 判断图`G`是否存在边`<x,y>`或者`(x,y)`                                             |
|      `Neighbors(G, x)`       |  求邻居   | 列出图`G`中与结点`x`邻接的边                                                       |
|     `InsertVertex(G, x)`     |  插入顶点  | 在图`G`中插入顶点`x`                                                           |
|     `DeleteVertex(G, x)`     |  删除顶点  | 在图`G`中删除顶点`x`                                                           |
|      `AddEdge(G, x, y)`      |  添加边   | 若边`(x,y)`或者`<x,y>`不存在，则向图`G`中添加该边                                       |
|    `RemoveEdge(G, x, y)`     |  删除边   | 若边`(x,y)`或者`<x,y>`存在，则从图`G`中删除该边                                        |
|    `FirstNeighbor(G, x)`     | 第一个邻接点 | 求图`G`中顶点`x`的第一个邻接点，若有则返回顶点号。若没有，则返回`-1`                                 |
|   `NextNeighbor(G, x, y)`    | 下一个邻接点 | 假设图`G`中顶点`y`是顶点`x`的一个邻接点，返回除`y`外顶点`x`的下一个邻接顶点号。若`y`是`x`的最后一个邻接点，则返回`-1` |
|  `Get_edge_value(G, x, y)`   |  边权值   | 获取图`G`中边`<x,y>`或者`(x,y)`对应的权值                                           |
| `Set_edge_value(G, x, y, v)` | 设置边权值  | 设置图`G`中边`(x,y)`或者`<x,y>`对应的边权值为`v`                                      |

图的结构较为复杂，且对于不同的任务，针对性强。因此这里列出的是图结构常用的基本操作，在实际的实现中，会根据任务的特性，设计相关的算法。

## 图的遍历

图的遍历指从图的某一个顶点出发，按照某种搜索方式沿着图中的边对图的所有顶点访问*一次*。图的遍历比[[数据结构/树与二叉树#树和森林的遍历|树的遍历]]复杂的多，图中的任意一个顶点都可能与其余顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点，因此为了避免同一个顶点被访问多次，在遍历图的过程中需要记录每个已经访问过的顶点。

### 广度优先搜索

广度优先搜索 (Breadth-First-Search, BFS) 类似与二叉树的层序遍历算法。其伪代码如下：
```cpp
bool visited[MAX_VERTEX_NUM];
void BFSTraverse(Graph &G){
	for(int i = 0; i < G.vexNum; i++){
		visited[i] = false;
	}
	Queue Q = new Queue;

	// 对于所有的顶点，进行 BFS 遍历
	// - 如果确定图是连通的，只需要从一个顶点开始就
	// 可以遍历整个图，只需要调用一次BFS
	// - 如果不是连通的，就需要至少对每个连通分量调用一次BFS
	for(int i = 0; i < G.vexNum; i++){
		if(!visited[i]){
			BFS(G, i);
		}
	}
}

void BFS(Graph &G, int i, Queue &Q){
	visit(i);
	visited[i] = true;
	Q.enQueue(i);
	while( !Q.isEmpty() ){
		current = Q.deQueue();
		// 遍历 new_i 的所有邻接顶点
		for(auto j : G.getNeighbors(current)){
			if(visited[j] == false){
				visit(j);
				visited[j] = true;
				EnQueue(Q, j);
			}
		}
	}
}
```

> [!note] BFS 算法性能分析
> 无论是采用邻接表还是邻接矩阵作为存储方式，BFS 算法都需要借助一个辅助队列 $Q$，每个顶点恰好入队和出队一次。因此，在最坏的情况下，空间复杂度主要由队列决定，为 $O(|V|)$。
>
> 遍历图的过程实际上是对每个顶点查找其邻接点的过程，耗费的时间与存储结构有关：
> - **邻接表**：在搜索过程中，每个顶点都会被访问一次。在搜索顶点的邻接点时，需要访问该顶点的整个邻接表，邻接表中的结点数代表与该顶点相连的边的数量。因此，访问所有邻接表的时间复杂度为 $O(|E|)$。综合考虑，总的时间复杂度为 $O(|V| + |E|)$。
> - **邻接矩阵**：在搜索过程中，每个顶点都会被访问一次。在搜索每个顶点的邻接点时，会把邻接矩阵对应行遍历一次以确定哪些顶点是它的邻接点，时间复杂度为 $O(|V|)$。因为这一过程需要对每个顶点执行，所以总的时间复杂度为 $O(|V|^2)$。

> [!example]
> 1. 单源最短路径：通过 BFS 算法可以求解单源最短路径问题，因为广度优先搜索总是按照距离由近到远来遍历图中的每个顶点的。
> 2. 广度优先生成树：在 BFS 遍历图的过程中，我们可以得到一棵遍历树，称为*广度优先生成树*。
> 	- 对于使用邻接矩阵存储的图，由于邻接矩阵是唯一的，因此其广度优先生成树也是唯一的
> 	- 对于使用邻接表存储的图，由于邻接表是不唯一的，因此其广度优先生成树也是不唯一的

### 深度优先搜索

深度优先搜索 (Depth-First-Search, DFS) 类似与[[数据结构/树与二叉树#先序遍历|树的先序遍历]]，该算法总是尽可能深的搜索一个图，直到没有邻接结点为止，在退回到之前的搜索中。其伪代码如下：
```cpp
bool visited[MAX_VERTEX_NUM];
void DFSTraverse(Graph &G){
	for(int i = 0; i < G.vexNum; i++){
		visited[i] = false;
	}
	for(int i = 0; i < G.vexNum; i++){
		if(!visited[i]){
			DFS(G, i);
		}
	}
}

void DFS(Graph &G, int i){
	visit(i);
	visited[i] = true;
	for(auto j : G.getNeighbors(i)){
		if(visited[j] == false){
			DFS(G, j);
		}
	}
}
```

> [!note] DFS 算法性能分析
> DFS（深度优先搜索）是一个递归算法，它使用一个递归工作栈来追踪搜索路径。在最坏的情况下，即图呈现为一条链式结构时，DFS 需要将所有顶点入栈，因此空间复杂度为 $O(|V|)$。
>
> DFS 算法与 BFS 算法的时间复杂度相同，它们的区别仅在遍历的顺序上，因为 BFS 算法使用队列，DFS 算法使用栈。
>
> 在遍历图的过程中，DFS 对每个顶点只访问一次，并通过递归的方式探索每个顶点的所有邻接点，直到无法继续为止。遍历的时间复杂度与存储结构有关：
> - **邻接表**：对于每个顶点，DFS 会访问其所有的邻接点，每个顶点及其邻接点仅被访问一次。因此，总的访问次数为所有顶点的邻接点数量之和，即边的数量 $|E|$。因此，总的时间复杂度为 $O(|V| + |E|)$。
> - **邻接矩阵**：对于每个顶点，DFS 会检查其与所有其他顶点的连接情况，这意味着会遍历邻接矩阵的一整行。由于每个顶点都会被访问一次，并且每次访问都会遍历一行，总的时间复杂度为 $O(|V|^2)$。

> [!warning]
> - 图的邻接矩阵是唯一的，因此基于邻接矩阵遍历得到的 DFS 序列和 BFS 序列是唯一的。
> - 图的邻接表是不唯一的，因此基于邻接表遍历得到的 DFS 序列和 BFS 序列是不唯一的。

> [!example]
> 同样的，深度优先遍历也会产生一棵深度优先生成树 (或者森林)，与 BFS 类似，基于邻接表存储的深度优先生成树不是唯一的，基于邻接矩阵的深度优先生成树是唯一的。

### 图的连通性

图的遍历算法能够用于判断图的连通性。
- 对于无向图来说，如果从任意一个顶点出发，一次遍历就可以访问所有顶点，那么无向图是连通的。
- 对于有向图来说，如果从任意一个顶点出发，能够访问全部顶点，那么有向图是强连通的。(弱连通可以先将有向图转换为无向图)

> [!tip]
> 根据连通和强连通的定义，我们可以很自然的得到判断连通图的算法： 以无向图为例，从任意一个顶点出发，使用一次BFS或DFS遍历整个图。如果遍历结束后所有顶点都被访问过（visited数组全为true），则图是连通的；否则，图不是连通的。
>
> 此外，如果我们从每个未被访问过的顶点出发，使用BFS或DFS进行遍历，并为每个遍历到的新连通分量分配一个不同的编号。这样，每个顶点都会被标记为其所在连通分量的编号。

## 图的应用

|      |  Dijkstra  |   Floyd    |    Prim    |   Kruskal    |    DFS     |    BFS     |    拓扑排序    |    关键路径    |
| :--: | :--------: | :--------: | :--------: | :----------: | :--------: | :--------: | :--------: | :--------: |
| 邻接矩阵 | $O(n^{2})$ | $O(n^{3})$ | $O(n^{2})$ |      -       | $O(n^{2})$ | $O(n^{2})$ | $O(n^{2})$ | $O(n^{2})$ |
| 邻接表  |     -      |     -      |     -      | $O(e\log e)$ |  $O(n+e)$  |  $O(n+e)$  |  $O(n+e)$  |  $O(n+e)$  |

### 最小生成树

> [!definition|Definition] 最小生成树
> 一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。
>
> 对于一个**带权连通无向图**$G$，生成树不同，每棵树的权^[树中所有边上的权值之和]也可能不同。权值之和最小的那颗生成树称为 $G$ 的**最小生成树**(Minimum-Spanning-Tree, MST)。

> [!note] 最小生成树的性质
> 1. 若 $G$ 中存在权值相同的边，则 $G$ 的最小生成树不唯一，但是最小生成树的权是唯一的，且是最小的。
> 2. 当图 $G$ 中各边的权值互不相等时，$G$ 的最小生成树是唯一的。
> 3. 若 $G$ 本事就是一颗树 (即$|E|=|V|-1$)，那么 $G$ 的最小生成树就是它本身。
> 4. 最小生成树的边数等于顶点数减 1。

> [!warning] 最小生成树中所有边的权值和最小，但是不能保证任意两个顶点之间的路径的权值和最小，即不能保证是最短路径。

### 最小生成树的构造

最小生成树具有局部最优子结构的性质，即：
> 假设 $G=(V,E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集，若 $(u,v)$ 是一条具有最小权值的边，其中 $u\in U,v\in V-U$，则必存在一颗包含边 $(u,v)$ 的最小生成树。

基于该性质的最小生成树算法主要有`Prim`算法和`Kruskal`算法，它们都是基于贪心算法的策略，实际上是下面算法的不同实现：
```lua unfold
function genericMST(G):
	T = NULL
	while T 不是最小生成树:
		找到一条最小代价边 (u,v) 并且加入 T 后不会产生回路
		将 (u,v) 加入最小生成树
	return T
```

#### Prim算法

Prim 算法的执行非常类似于寻找图的最短路径的 Dijkstra 算法。其步骤为：
1. **初始化**：选择图中的任意一个顶点作为起始顶点，将其加入到最小生成树的顶点集合 $U$ 中。初始时，$U$ 只包含这一个顶点，而剩余的顶点集合 $V(G)−U$ 包含图中的其他所有顶点。
2. **循环构建最小生成树**：重复以下步骤直到 $U$ 包含图中的所有顶点：
	- 对于 $V(G)−U$ 中的每一个顶点，计算它与 $U$ 中顶点之间的边的权重。
	- 从这些边中选取权重最小的一条边，并将这条边的另一端顶点添加到 $U$ 中。
	- 通过这条边及其顶点扩展最小生成树。

```python
def Prim(graph: Graph, s: int = 0):
    vexList = np.zeros(graph.numVex, dtype=bool)
    dist = np.array(graph.arc[s, :])
    prev = np.full(graph.numVex, s)

    vexList[s] = True
    prev[s] = -1
    for _ in range(graph.numVex - 1):
        # 找到距离树最近的结点
        min_dist, new_vex = np.inf, -1
        for vex in range(graph.numVex):
            if not vexList[vex] and min_dist > dist[vex]:
                min_dist = dist[vex]
                new_vex = vex

        # 将其加入树中并更新距离
        vexList[new_vex] = True
        for vex in range(graph.numVex):
            if not vexList[vex] and graph.arc[new_vex][vex] < dist[vex]:
                dist[vex] = graph.arc[new_vex][vex]
                prev[vex] = new_vex
    return dist, prev
```

> [!note] Prim 算法时间复杂度分析
> Prim 算法的时间复杂度为 $O(|V|^{2})$，不依赖于 $|E|$，适合用于求解*稠密图*的最小生成树。

> [!tip] 实现方式
> 在实现方式上，Prim 算法与 [[#Dijkstra 算法]]有异曲同工之处 ，都是利用`dist`数组存储每个结点目前的最小距离，利用`path/prev`数组存储每个结点目前最小距离的前驱结点，然后再遍历过程中先找到最短的结点，利用该结点更新`dist`数组和`path/prev`数组，他们的区别仅仅在于更新的方式不同罢了。

#### Kruskal 算法

Kruskal 算法按照权值递增次序选择合适的边来构造最小生成树。其步骤为：
1. 初始化：初始化边集为空，顶点集为 $V(G)$ 子图，此时每个顶点构成一棵独立的树。
2. 循环：按 $G$ 的边的权值递增顺序依次从 $E\sim E_{T}$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入最小生成树中，否则舍弃，直到有 $n-1$ 条边。
```python
def Kruskal(G){
	# 初始化树的顶点为图的顶点
	T.V = G.V

	# 从小到大选择边，可以使用堆
	# 这里为了方便直接使用排序，只改变时间复杂度的系数
	sortedE = sorted(list(T.E))
	i = 0

	# 使用并查集检查是否连通
	joint_set = JoinSet(T.V)
	while T.numEdge < T.numVex - 1:
		e = sortedE[i]
		# 如果边的两个顶点不在同一个连通分量中
		if joint_set.find(e[0]) != joint_set.find(e[1]):
			T.addEdge(e)
			joint_set.union(e[0], e[1])
		i+=1
	return T	
}
```

> [!note] Kruskal 时间复杂度分析
>在 Kruskal 算法中，最坏情况需要对 $|E|$ 条边各扫描一次。通常采用堆来存放边的集合，此时每次选择最小的权值的边需要 $O(\log_{2}|E|)$ 的时间。
>
>每次采用并查集来判断两个顶点是否属于同一个集合，需要 $O(\alpha(|V|))$ 时间复杂度，由于该时间复杂度增长缓慢，因此可以视为常数复杂度。
>
>于是算法的总时间复杂度为 $O(|E|\log_{2}|E|)$，不依赖于 $|V|$，因此 Kruskal 算法适合于*边稀疏而顶点*多的图。

### 最短路径

[[#广度优先搜索]]查找最短路径是对于无权图而言的，当图是带权图时，广度优先搜索就需要一些修改。

最短路径问题具有最优子结构性质，即
> 两点之间的最短路径也包含了路径上的其他顶点间的最短路径。

最短路径问题一般分为两类：单源最短路径问题和求每对顶点之间的最短路径问题。

#### Dijkstra 算法

Dijkstra 算法设置了一个集合 $S$ 记录已求得的最短路径的顶点，初始时把源点 $v_{0}$ 放入 $S$，集合 $S$ 每并入一个新顶点 $v_{i}$，就更新集合 $S$ 中最短路径的长度。
- `final`：标记各顶点是否已经找到最短路径，是否归入集合 $S$。
- `dist`：记录从源点 $v_{0}$ 到其他各顶点当前的最短路径长度，初始值为从 $v_{0}$ 出发的弧的权值，与 $v_{0}$ 不相连的设置为无穷。
- `path`：`path[i]`表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可以根据其值追溯得到源点 $v_{0}$ 到顶点 $v_{i}$ 的最短路径。

下面我使用 Python 描述了 Dijkstra 算法的步骤。
```python
def Dijkstra(graph: Graph, s: int):
	# 初始化，其中
	# - final[s] 初始化为 True, 其余为 False
	# - dist[s] 初始化为 0，其余为无穷
	# - path[s] 初始化为 -1，其余初始化为 s
    final = np.array([False for _ in range(graph.numVex)])
    dist = np.array([graph.arc[s][i] for i in range(graph.numVex)])
    path = np.array([s for _ in range(graph.numVex)])

    final[s] = True
    path[s] = -1
    for i in range(graph.numVex - 1):
		# 从 dist 中找未遍历，且距离最短的顶点，将其加入最短路径中
        new_vex, min_dist = -1, np.inf
        for vex in range(graph.numVex):
            if not final[vex] and dist[vex] < min_dist:
                new_vex = vex
                min_dist = dist[vex]
        final[new_vex] = True
		# 使用新加入的顶点更新 dist 和 path
        for vex in range(graph.numVex):
            if (
                not final[vex]
                and vex != new_vex
                and dist[vex] > dist[new_vex] + graph.arc[new_vex][vex]
            ):
                dist[vex] = dist[new_vex] + graph.arc[new_vex][vex]
                path[vex] = new_vex
    return dist, path
```

> [!note]
> Dijkstra 算法可以用于无向图和有向图，但是不适合具有负权值边的带权图。Dijkstra 算法的时间复杂度为 $O(|V|^{2})$

#### Floyd 算法

Floyd 算法是动态规划算法，通过引入一个状态变量中转结点的个数，从而实现了递推的计算最短路径。

下面使用 Python 描述了 Floyd 算法的步骤：
```python
def Floyd(graph: Graph):
    dist = graph.arc.copy()
    path = np.full((graph.numVex, graph.numVex), -1)

    for k in range(graph.numVex):
        for i in range(graph.numVex):
            for j in range(graph.numVex):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][j] = k

    return dist, path
```

> [!note]
> - *~~过于抽象，直接背了~~*
> - Floyd 算法可以用于含有负权值的图，但是不能用于含有负权值的有环图。实际上，含有负权值的有环图中可能不存在最短路径。
> - Floyd 算法的时间复杂度为 $O(|V|^{3})$，但是由于使用的动态规划的方法，算法复杂度中的常数部分很小，因此在实际生活中效率也很高。

### 有向无环图表达式

有向无环图就和它的名字一样，不存在环，简称 DAG 图。该图是描述含有公共子表达式的表达式的有效工具，在有向无环图中，不可能出现重复的操作树顶点。

在编译原理的代码优化部分，就是通过 DAG 图来优化数据流的。

### 拓扑排序

> [!definition|AOV网] 若用一个有向无环图表示一个工程，其顶点表示活动，用有向边 $<V_{i},V_{j}>$ 表示活动 $V_{i}$ 必须先于活动 $V_{j}$ 进行这样一种关系，则将这种有向图称为*顶点表示活动网络* (Activity On Vertex Network)，简称*AOV 网* 。

在 AOV 网中，活动 $V_{i}$ 是活动 $V_{j}$ 的直接前驱，$V_{j}$ 是 $V_{i}$ 的直接后继，这种前驱后继具有传递性，且任何活动 $V_{i}$ 不能以它自己作为自己的前驱或者后继。

> [!definition|Definition] 拓扑排序
> 在图论中，有一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：
> 1. 每个顶点出现且只出现一次。
> 2. 若顶点 $A$ 在序列中排在顶点 $B$ 的前面，则在图中不存在从 $B$ 到 $A$ 的路径。

> [!note] 拓扑排序也可以这样定义
> 拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点 $A$ 到顶点 $B$ 的路径，则在排序中 $B$ 出现在 $A$ 的后面。每个 AOV 网都有一个或多个拓扑排序序列。

对 AOV 网进行拓扑排序的算法有很多，这里给出一种简单的：
1. 从 AOV 网中选择一个没有前驱 (入度为 0) 的顶点并输出
2. 从网中删除该顶点和所有以它为起点的有向边
3. 重复 1 和 2 直到当期 AOV 网为空或者当前网中不存在无前驱的顶点为止 (说明图中有环)。

下面使用 Python 描述了拓扑排序算法：
```python
def TopologicalSort(graph: Graph):
    topologicalSortList = []
    stack = []
    inDegree = np.ones(graph.numVex)
    # 计算每个顶点的入度
    for i in range(graph.numVex):
        inDegree[i] = sum(value != np.inf for value in graph.arc[:, i]) - 1
        if inDegree[i] == 0:
            stack.append(i)
            inDegree[i] = -1

    while len(stack) > 0:
        top = stack[-1]
        stack.pop()
        topologicalSortList.append(top)
        # 删除顶点，相当于该顶点指向的顶点的入度-1
        for i in range(graph.numVex):
            if graph.arc[top][i] != np.inf:
                inDegree[i] -= 1

        for i in range(len(inDegree)):
            if inDegree[i] == 0:
                stack.append(i)
                inDegree[i] = -1

    return topologicalSortList
```

> [!note]
> 1. 入度为 0 的顶点，是没有前驱活动或者前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始进行。
> 2. 若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一。若各个顶点已经排在了一个线性有序的序列中，每个顶点之间都有唯一的前驱后继关系，那么拓扑排序是唯一的。

> [!note] 拓扑排序的效率
> 由于输出每个顶点的同时，还要删除以它为起点的边，因此采用邻接表存储时拓扑排序的时间复杂度为 $O(|E|+|V|)$，采用邻接矩阵存储时的时间复杂度为 $O(|V|^{2})$。

除了使用上述的算法外，DFS 算法也可以输出拓扑排序，只需要把输出部分放在 DFS 递归代码之后，那么祖先结点的输出一定是在子孙结点的输出之后，这和拓扑排序的定义一致。

> [!example] 逆拓扑排序
> 拓扑排序算法中总是选择入度为 0 的结点，如果我们总是选择出度为 0 的结点，可以得到逆拓扑排序序列。

### 关键路径

> [!definition|AOE网] 在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销 (例如完成活动的时间)，我们称这种图为*用边表示活动的网络* (Activity On Edge Network)，简称*AOE 网*。

> [!note]
> AOE 网和 AOV 网都有有向无环图，但是 AOE 网络是使用边来表示活动，而 AOV 网是使用顶点来表示活动的。它们的区别实际上仅仅在于 AOE 网络中的边有权值，而 AOV 网络的边没有权值。

AOE 网络具有以下两种性质：
1. 只有在某顶点所代表的事件发生之后，从该顶点出发的各有向边所代表的活动才能开始。
2. 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。

在 AOE 网络中，有且仅有一个入度为 0 的顶点，称为开始顶点 (源点)，它表示整个工程的开始；有且仅有一个出度为 0 的顶点，称为结束顶点 (汇点)，它表示整个工程的结束。

从源点到汇点中，存在多条有向路径，这些路径表示有些活动是可以并行进行的，完成不同路径上的活动所需的事件虽然不同，但是只有所有路径上的活动都已经完成，整个工程才能算作结束。因此，**从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径**，而把关键路径上的活动称为*关键活动**。

> [!note] 完成整个工程的最短时间就是关键路径的长度。

下面给出寻找关键活动涉及到的几个变量：
1. 事件 $v_{k}$ 的最早发生时间 $v_{e(k)}$
2. 事件 $v_{k}$ 的最迟发生时间 $v_{l}(k)$
3. 活动 $a_{i}$ 的最早开始时间 $e(i)$
4. 活动 $a_{i}$ 的最迟开始时间 $l(i)$
5. 一个活动 $a_{i}$ 的最迟开始时间 $l(i)$ 和其最早开始时间 $e(i)$ 的差额 $d(i)=l(i)-e(i)$

只需要将 AOE 网络进行拓扑排序与逆拓扑排序，就可以沿着 AOE 网络计算最早开始时间与最晚开始时间，从而计算 $d(i)$。如果 $d(i)=0$，即 $l(i)=e(i)$ 的活动 $a_{i}$ 是关键活动。
