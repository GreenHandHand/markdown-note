---
tags:
  - 数据结构与算法
---

# 图

图 $G$ 是由顶点集 $V$ 和边集 $E$ 组成，记为 $G(V,E)$
- $V(G)$ 表示图 $G$ 中顶点的有限非空集，使用 $V=\left\{ v_{1},v_{2},\cdots,v_{n} \right\}$ 来描述一个图中的所有顶点，使用 $\left| V \right|$ 来代表顶点集的大小；
- $E(G)$ 表示图 $G$ 中顶点之间的关系集合，使用 $E=\left\{ \left( u,v \right)\mid u\in V,v\in V \right\}$ 来描述图中的边，使用 $\left| E \right|$ 来表示图 $G$ 中边的条数；

图可以用于建模复杂的多对多关系，每个实体与多个实体相连。在图论中，图作为主要的研究对象，引申出了一门完整的、严谨的数学体系。我们接下来提到的概念都来自图论。

> [!note]
> 线性表可以是空边，树可以是空树，但是图不能是空图，也就是说，图中不能一个顶点也没有。即，图的顶点集 $V$ 一定非空，但是边集 $E$ 可以为空。

## 关于图的概念与术语

图是一种复杂的数据结构，包含多个相关的概念和术语。在学习图时，我们需要了解以下基础概念：

### 图的基本定义

> [!definition|Definition] 有向图
> - 定义：若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 称为有向图。
> - 描述：在有向图中，使用 $<v, w>$ 表示从顶点 $v$ 指向顶点 $w$ 的有向弧。这里，$v$ 称为弧尾，$w$ 称为弧头，即 $v$ 邻接到 $w$。

> [!definition|Definition] 无向图
> 定义：若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 称为无向图。
> 描述：边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$。可以说 $w$ 和 $v$ 互为邻接点，或者边 $(v, w)$ 依附于 $v$ 和 $w$，也称该边与 $v, w$ 相关联。

其他图的定义
1. 简单图和多重图：如果图中不存在重复边或自环（顶点到自身的边），则称为简单图。在我们讨论中，默认图为简单图。
2. 完全图：在无向完全图中，任意两个顶点之间都存在边；在有向完全图中，任意两个顶点之间都有两条方向相反的弧。
3. 子图：设 $G=(V, E)$ 和 $G'=(V', E')$ 为两个图，如果 $V' \subseteq V$ 且 $E' \subseteq E$，则 $G'$ 是 $G$ 的子图。若 $V(G') = V(G)$，则称 $G'$ 为 $G$ 的生成子图。
4. 稠密图与稀疏图：边数较少的图称为稀疏图，反之为稠密图。一般而言，当 $\left| E \right| < \left| V \right|\log \left| V \right|$ 时，图被认为是稀疏图。
5. 有向树：一个有向图，若仅有一个顶点的入度为 0，其余顶点的入度均为 1，则称为有向树。

### 图的基本概念

1. 顶点的度
	- 无向图：顶点 $v$ 的度是与其相连的边数，记为 $\text{TD}(v)$。
	- 有向图：
		- 出度：以顶点 $v$ 为起点的边数，记为 $\text{OD}(v)$。
		- 入度：以顶点 $v$ 为终点的边数，记为 $\text{ID}(v)$。
		- 总度：顶点 $v$ 的度为出度与入度之和，即 $\text{TD}(v) = \text{ID}(v) + \text{OD}(v)$。
2. 边的权与网
	- 定义：图中的每条边可以赋予一个具有特定含义的数值，称为权值。带权值的图称为带权图，也称为网。
3. 路径与路径长度
	- 路径：从顶点 $v_p$ 到顶点 $v_q$ 的路径是一个顶点序列 $v_p, v_{i_1}, v_{i_2}, \ldots, v_q$。
	- 路径长度：路径中边的数量。
4. 回路与简单路径
	- 回路（环）：路径的第一个顶点和最后一个顶点相同。
	- 简单路径：路径序列中，顶点不重复出现。
	- 简单回路：回路中，除了第一个和最后一个顶点外，其余顶点不重复。
5. 距离
	- 定义：若从顶点 $u$ 到顶点 $v$ 存在最短路径，则该路径的长度称为 $u$ 到 $v$ 的距离；若不存在路径，距离记为 $\infty$。

### 图的连通性

1. 无向图的连通性
	- 连通：若无向图中存在从顶点 $v$ 到顶点 $w$ 的路径，则称 $v$ 和 $w$ 连通。
	- 连通图：无向图 $G$ 中任意两个顶点都是连通的，则 $G$ 为连通图，否则为非连通图。
	- 连通分量：无向图中的极大连通子图称为连通分量。
2. 有向图的连通性
	- 强连通：若有向图中存在从顶点 $v$ 到顶点 $w$ 的路径，且存在从 $w$ 到 $v$ 的路径，则称 $v$ 和 $w$ 强连通。
	- 强连通图：有向图 $G$ 中任意两个顶点都是强连通的，则称该图为强连通图。
	- 强连通分量：有向图中的极大强连通子图称为强连通分量。
3. 生成树：包含图中所有顶点的一个极小连通子图，且去掉任何一条边会导致图不连通。
4. 生成森林：在非连通图中，由各连通分量的生成树构成的图称为生成森林。

## 图的存储及基本操作

图的存储必须要完整、准确的反映顶点集和边集的信息，根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响。

### 邻接矩阵

使用邻接矩阵存储，是值用一个一维数组存储图中的顶点信息，用一个二维数组存储图中边的信息。存储顶点之间邻接关系的二维数组称为**邻接矩阵**。

设顶点数为 $n$ 的图 $G=(V,E)$ 的邻接矩阵 $A$ 是 $n\times n$ 的，将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n}$，则邻接矩阵为
$$
A[i][j]=\begin{cases}
1,&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
$$

> [!note] 带全图的邻接矩阵
> 对于带权图而言，若顶点 $v_{i}$ 与 $v_{j}$ 有边相连，则邻接矩阵中对应项应该存放该边对应的权值。若不相连，则存放 $0$ 或者 $\infty$。
> $$
A[i][j]=\begin{cases}
w_{ij},&(v_{i}, v_{j})\in V\ \text{或者}\ <v_{i},v_{j}>\in V \\
0\text{或}\infty,&(v_{i}, v_{j})\notin V\ \text{或者}\ <v_{i},v_{j}>\notin V \\
\end{cases}
> $$

```cpp
#define MaxVertexNum 100
typedef char VertexType;
typedef int EdgeType;
typedef struct{
	VertexType vex[MaxVertexNum];
	EdgeType edge[MaxVertexNum][MaxVertexNum];
	int vexNum, arcNum;
}MGraph;
```

> [!note]
> 1. 在一些简单的应用中，不需要用到顶点的信息，则使用邻接矩阵就可以表示一张图。
> 2. 当邻接矩阵中不需要使用权值时，`EdgeType`可以直接使用枚举类型。
> 3. 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可以采用[[数据结构/栈、队列和数组#对称矩阵|对称矩阵的压缩存储]]。
> 4. 邻接矩阵的空间复杂度为 $O(n^{2})$。

> [!example] 基于邻接矩阵的顶点的度的计算
> 1. 对于无向图，邻接矩阵的第 $i$ 行 (列) 非零元素的个数正好是顶点 $i$ 的度 $\text{TD}(v_{i})$
> 2. 对于有向图，邻接矩阵第 $i$ 行非零元素的个数正好是顶点 $i$ 的出度 $\text{OD}(v_{i})$，第 $j$ 列非零元素的个数正好是顶点 $i$ 的入度 $\text{ID}(v_{i})$
> 3. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边，但是要确定图中有多少边，必须按行、列对每个元素进行检测。
> 4. 稠密图适合使用邻接矩阵存储。

> [!tip] 在图论中，可以证明，$A^{n}[i][j]$ 表示从 $i$ 出发到 $j$ 的长度为 $n$ 的路径。

### 邻接表

当一个图为系数图时，使用邻接矩阵法显然会浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这些浪费。

在邻接表法中，对 $G$ 的每个顶点 $v_{i}$ 建立了一个单链表，第 $i$ 个单链表中的结点表示从 $v_{i}$ 出发的有向边，这个单链表称为 $v_{i}$ 的边表 (对于有向图则为出边表)。边表的头指针和顶点的数据信息使用顺序存储，称为顶点表。
- 顶点表结点由顶点域存储顶点 $v_{i}$ 的信息，边表头指针域存储指向第一条边的边表结点。
- 边表结点由邻接点域存储与头结点顶点 $v_{i}$ 邻接的顶点编号，指针域指向下一条边的边表结点。

```cpp
#define MaxVertexNum 100
typedef struct ArcNode{
	int adjvex;
	struct ArcNode* nextarc;
	// InfoType info;
}ArcNode;
typedef struct VNode{
	VertexType data;
	ArcNode* firstarc;
}VNode, AdjList[MaxVertexNum];
typedef struct{
	AdjList vertices;
	int vexNum, arcNum;
}ALGraph;
```

若 $G$ 是无向图，则需要的存储空间为 $O(\left| V \right|+2\left| E \right|)$，因为无向边需要分别存储在两个顶点的邻接表中。若 $G$ 是有向图，则需要存储的空间为 $O(\left| V \right|+\left| E \right|)$。

> [!tip] 邻接矩阵与邻接表的对比
> 1. 对于稀疏图，采用邻接表表示将极大的节省存储空间。
> 2. 在邻接表中，给定一个顶点，可以很方便的找出它的所有邻边。在邻接矩阵中，找出一个顶点的邻边需要遍历邻接矩阵的一行，即遍历 $\left| V \right|$ 次。
> 3. 在邻接表中，要确定两个顶点间是否存在边，需要在相应的结点中查找另一个结点，效率很低。在邻接矩阵中，只需要直接查询即可。
> 4. 在无向图的邻接表中，计算某个结点的度数可以通过计算其邻接表中的边数。在有向图的邻接表中，计算某个结点的出度可以直接统计邻接表中的边数，但是计算某个结点的入度就需要遍历整个邻接表。
> 5. 图的邻接表表示不唯一。

### 十字链表

十字链表是有向图的一种链式存储结构。在十字链表中，有向图的每条弧用一个结点来表，每个顶点也用一个结点来表示。
- 弧结点：
- 顶点结点：
