---
tags:
  - 数据结构与算法
---

# 排序

排序，就是重新排列表中的元素，使表中的元素满足按照关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。

> [!note] 算法的稳定性
> 若待排序表中有两个元素 $R_{i}$ 和 $R_{j}$，其对应的关键字相同，且在排序前 $R_{i}$ 在 $R_{j}$ 前面。若使用某一排序算法排序后，$R_{i}$ 仍然在 $R_{j}$ 的前面，则称该排序算法是**稳定的**，否则这个排序算法是**不稳定的**。

在排序过程中，根据数据元素是否完全放在内存中，可以将排序算法分为两类：
1. 内部排序：指在排序期间元素全部存放在内存中的排序。
2. 外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。*在本节的讨论中，我们默认排序算法的目标为从小到大排序，即非递减序列*。

## 插入排序

插入排序是一种简单直观的方法，基本思想为每次将一个待排序的记录按照其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。

### 直接插入排序

插入排序每次将第 $i$ 个元素插入到前面的 $i-1$ 个有序序列中，其步骤为：
1. 查找`L[i]`在前`L[0...i-1]`个元素中的位置`k`
2. 将`L[k...i-1]`中所有元素向后移动一位
3. 将`L[i]`复制到`L[k]`中
```cpp
void insertSort(vector<int> &table) {
    int size = table.size(), j;
    for (int i = 1; i < size; i++) {
        if (table[i] < table[i - 1]) {
            int temp = table[i];
            // 找到第一个比 temp 小的元素
            for (j = i - 1; j >= 0 && table[j] > temp; j--) {
                table[j + 1] = table[j];
            }
            // 插到该元素的前面
            table[j + 1] = temp;
        }
    }
}

```

> [!note] 直接插入排序算法性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 最差时间复杂度：外层 $O(n)$ 次循环，内层移动元素复杂度为 $O(n)$，综合起来时间复杂度为 $O(n^{2})$。
> 	- 平均时间复杂度：$O(n^{2})$
> - **稳定性**：每次插入元素都是从后往前比较，因此不会出现相对位置变化的情况，直接插入排序算法是稳定的。

> [!tip] 直接插入排序算法适合用于顺序存储和链式存储，且采用链式存储时无需移动元素，但是时间复杂度同样是 $O(n^{2})$。

> [!note]
> 可以看到，直接插入排序的时间复杂度主要在于把比插入值大的元素向后移动，如果待排序表原本就呈现了一种从小到大的趋势，那么插入排序算法就只需要移动较少的元素就可以完成排序，此时效率较高。

### 折半插入排序

从直接插入排序算法中可以看到，每趟插入的过程都进行了两项工作：
1. 从前面的有序子表中找出待插入元素应该被插入的位置
2. 给插入位置腾出空间，将待插入元素复制到表中的插入位置

折半插入排序将查找操作和插入操作分离，先[[数据结构/查找#二分查找|折半查找]]待插入位置，然后统一移动待插入位置之后的所有元素。
```cpp
void binaryInsertSort(vector<int> &table) {
    int size = table.size(), low, high, mid;
    for (int i = 1; i < size; i++) {
        if (table[i - 1] > table[i]) {
            int temp = table[i];
            // 二分查找找到temp的位置
            low = 0, high = i;
            while (low <= high) {
                mid = (low + high) / 2;
                if (table[mid] < temp) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            for (int j = i - 1; j >= low; j--) {
                table[j + 1] = table[j];
            }
            table[low] = temp;
        }
    }
}

```

> [!note] 折半查找的性能分析
> **空间效率**：仅使用了常数级的额外空间，空间复杂度为 $O(1)$
> **时间效率**：相较于简单插入排序，折半查找仅仅减少了比较操作的次数，但是时间复杂度仍然为 $O(n^{2})$

### 希尔排序

希尔排序又称为缩小增量排序，是基于插入排序改进得来。其基本思想为：先将待排序表分割为若干形如`L[i, i+d, i+2d, ..., i+kd]`特殊子表，即把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素呈现基本有序时，再对全体记录进行一次直接插入排序。

希尔排序算法的步骤描述为：
1. 取一个小于`n`的增量`d`，把表中的全部记录划分为`d`组，即距离为`d`的倍数的元素放在一组中，对每一组内进行插入排序。
2. 减小增量`d`，重复上述过程直到`d=1`时，相当于进行直接插入排序，此时数组有序。
```cpp
void shellSort(std::vector<int> &table) {
    int size = table.size(), j;
    for (int d = size / 2; d >= 1; d /= 2) {
        for (int i = d; i < size; i += d) {
            if (table[i] < table[i - d]) {
                int temp = table[i];
                for (j = i - d; j >= 0 && table[j] > temp; j -= d) {
                    table[j + d] = table[j];
                }
                table[j + d] = temp;
            }
        }
    }
}

```

> [!note] 希尔排序的性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及到数学上尚未解决的难题，因此其时间复杂度分析较为困难。当 $n$ 在某个特定的范围内时，希尔排序的时间复杂度约 $O(n^{1.3})$。
> 	- 在最坏的情况下，希尔排序的时间复杂度为 $O(n^{2})$。
> - **稳定性**：当相同的关键字记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是不稳定的。

## 交换排序

交换排序就是根据序列中两个关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，这里主要介绍最著名的冒泡排序和快速排序。

### 冒泡排序

冒泡排序的基本思想是：从后往前 (从前往后) 两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。每一趟冒泡其实就是把关键字小的元素如同气泡一般逐渐上浮到水面的过程。在下一趟冒泡时，前一趟冒泡确定的最小元素不再参与比较，这样最多进行 $n-1$ 趟冒泡就能把所有元素排好序。
```cpp
void bubbleSort(vector<int> &table){
	int temp, flag;
	for(int i = 0; i < n; i++){
		flag = 0;
		for(int j = n - 1; j >= i; j--){
			if(table[i] > table[j]){
				temp = table[i];
				table[i] = table[j];
				table[j] = temp;
				flag = 1;
			}
		}
		// 如果没有发生交换，说明有序
		if(!flag){
			break;
		}
	}
}
```

> [!note] 冒泡排序的性能分析
> **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> **时间效率**：当初始序列有序时，显然第一次冒泡排序后直接跳出循环，此时比较次数为 $n-1$，移动次数为 $0$，即最好的情况下时间复杂度为 $O(n)$。当序列为逆序时，需要进行 $n-1$ 趟冒泡，第 $i$ 趟需要进行 $n-i$ 次关键词比较，而且每次交换操作都需要进行 3 次元素交换。这种情况下，比较次数为 $n(n-1)/2$，移动次数为 $3n(n-1)/2$。因此最坏时间复杂度为 $O(n^{2})$，平均时间复杂度为 $O(n^{2})$。
> **稳定性**：冒泡排序算法是一种稳定的排序算法。
> **适用性**：冒泡排序适合用于顺序存储和链式存储的线性表。

> [!tip] 不同于插入排序算法，冒泡排序过程中产生的有序子序列是全局有序的。

### 快速排序

快速排序算法的基本思想是基于分治法的：在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴[^枢轴]，通过一趟排序将待排序表划分为独立的两个部分`L[1...k-1]`和`L[k+1...n]`，使得`L[1...k-1]`中的所有元素都小于`pivot`，`L[k+1...n]`中的所有元素都大于或等于`pivot`，则`pivot`放在了其最终位置`L(k)`上，这个过程称为一次划分。然后分别递归的对划分出的两个子表重复上述过程，直到每个表中只有一个元素或者为空为止，即所有的元素都放在了其最终位置上。

快速排序算法的核心是划分，即任选一个元素作为枢轴元素，然后将表划分为大于枢轴元素和小于枢轴元素两部分，其步骤为：
1. 将`pivot`放在表的`low`的位置，即将其与`low`上的元素交换。(一般我们选取表的第一个元素，因此不许需要这一步)
2. 设定两个指针分别指向表的两端，这里使用为`high`与`low`。
3. 从`high`开始往前遍历，找到一个比`pivot`小的元素，该元素应该被放到`pivot`的左边，即将其赋值到`low`上，此时`high`指针空闲。
4. 从`low`开始往后遍历，找到一个比`pivot`大的元素，该元素应该被放到`pivot`的右边，即将其赋值到`high`上，此时`low`指针空闲。
5. 重复 2,3 直到`high==low`，此时`high`与`low`指向的位置就是`pivot`所在的位置，将`pivot`保存到`high`上。
6. 返回`pivot`的位置。

快速排序流程如下：
```cpp
int partition(vector<int>& table, int low, int high){
	int pivot = table[low];
	while(low<high){
		while(low < high && table[high--] > pivot);
		swap(table[low], table[high]);
		while(low < high && table[low++] < pivot);
		swap(table[low, table[high]]);
	}
	table[low] = pivot;
	return low;
}

void _quickSort(vector<int>& table, int low, int high){
	if(low < high){
		int pivotPos = partition(table, low, high);
		_quickSort(table, low, pivotPos - 1);
		_quickSort(table, pivotPos + 1, high);
	}
}

void quickSrot(vector<int>& table){
	_quickSort(table, 0, table.size());
}
```

> [!note] 快速排序的效率分析
>
> **空间效率**：
> - 快速排序采用递归方式进行排序，因此需要使用递归工作栈来保存每一层递归调用所需的信息。
> - 每层递归只需要常数级别的额外空间，因此空间复杂度取决于递归的深度。
> - 在最好的情况下，每次划分都能将数组大致平分为两部分，此时的空间复杂度为 $O(\log_{2}n)$。
> - 在最坏的情况下，即数组已经完全有序或逆序时，每次划分都会产生一个大小为 $n-1$ 和一个大小为 $0$ 的子数组，导致递归深度为 $O(n)$。
> - 平均情况下，快速排序的空间复杂度为 $O(\log_{2}n)$。
>
> **时间效率**：
> - 快速排序的时间效率取决于划分的对称性。
> - 在最坏的情况下，每次划分产生的子数组严重不对称（一个子数组大小为 $n-1$，另一个为 $0$），这通常发生在初始数组几乎有序或逆序时，此时时间复杂度为 $O(n^{2})$。
> - 在最理想的情况下，每次划分都能将数组均匀分为两个大小不超过 $n/2$ 的子数组，这时时间复杂度为 $O(n\log_{2}n)$。
> - 实际上，快速排序在平均情况下的运行时间与最佳情况非常接近，这使得它成为所有内部排序算法中性能最优的选择之一。
>
> **稳定性**：
> - 在划分过程中，如果右端区间中有两个关键字相同的记录，且它们都小于基准值，那么在交换到左端区间后，它们的相对顺序可能会改变。
> - 因此，快速排序是一种不稳定的排序算法。
>
> **适用性**：
> - 快速排序适用于顺序存储的线性表。

> [!tip] 优化
> 如果我们总是选择第一个元素作为枢轴元素，则快速排序的效率很低。我们可以通过修改选择枢轴的方式来更好的表现，例如，每次都随机选择一个元素作为枢轴，或者选择中间的元素。

## 选择排序

选择排序的基本思想是每一趟再后面 $n-i+1$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到 $n-1$ 趟做完，待排序元素只剩下一个，就不用再选。选择排序算法中，堆排序算法较为著名。

### 简单选择排序

简单排序算法就是选择排序最朴素的实现，假设排序表为`L[1...n]`，第 $i$ 趟排序即从`L[i...n]`中找出最小的元素与`L[i]`交换。
```cpp
void selectSort(vector<int>& table){
	int min, temp;
	for(int i = 0; i < table.size(); i++){
		min = i;
		for(int j = i + 1; j < table.size(); j++){
			if(table[j] < table[min]) min = j;
		}
		if(min!=i){
			temp = table[min];
			table[min] = table[i];
			table[i] = temp;
		}
	}
}
```

> [!note] 简单选择排序的性能分析
> - **空间效率**：仅使用了常数个辅助单元，所以空间的效率为 $O(1)$。
> - **时间效率**：在简单排序算法的过程中，元素的移动次数很少，不会超过 $3(n-1)$ 次，最少为 0 次，此时对应的表已经有序。但是元素间比较的次数与序列的初始状态无关，始终是 $n(n-1)/2$ 次，因此时间复杂度始终是 $O(n^{2})$。
> - **稳定性**：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与含有相同关键字的元素顺序颠倒，因此简单选择排序是不稳定的。
> - **适用性**：简单选择排序适用于顺从存储、链式存储的线性表，以及关键字较少的情况。

### 堆排序

> [!definition|Definition] 堆
> $n$ 个关键字序列`L[1...n]`称为堆，当且仅当该序列满足：
> 1. `L[i]>=L[2i]`且`L[i]>=L[2i+1]`，称为大根堆
> 2. `L[i]<=L[2i]`且`L[i]<=L[2i+1]`，称为小根堆

> [!note] 堆与二叉树
> 从堆的定义可以看出，如果将一个线性表视为完全二叉树，那么
> - 大根堆就是每个结点中的关键字不小于其孩子结点的完全二叉树。
> - 小根堆就是每个结点中的关键字不大于其孩子结点的完全二叉树.

升序序列的堆排序基于大根堆，其基本步骤如下：
1. 将排序表建立为一个大根堆
2. 从大根堆中选择最大的元素，即第一个元素，将其与最后一个待排序元素交换
3. 待排序表长度减 1，然后重新维护待排序表为大根堆，具体操作为将新交换的元素下坠，使得待排序表符合大根堆的性质。

在建立大根堆的算法如下：
1. 从表的第 $\lfloor n/2 \rfloor$ 个元素开始，向前遍历 (即从完全二叉树的最后一个非叶结点开始，遍历所有的非叶结点)
2. 从 $2i$ 与 $2i+1$ 中选择比 $i$ 结点大的元素，将其与 $i$ 交换 (将 $i$ 为根的子树转换为大根堆)
3. 遍历直到第一个结点，大根堆建立完毕 (遍历直到根结点)

```cpp
void buildMaxHeap(vector<int>& table){
	for(int i = table.size() / 2; i >= 0; i--){
		heapAdjust(table, i);
	}
}

void heapAdjust(vector<int>& table, int k, int len){
	int temp = table[k];
	for(int i = 2*k+1; i <= len; i = 2*i + 1){
		// 左孩子小于右孩子
		if(i < len && table[i] < table[i+1]){
			i++;
		}
		if(table[k] < table[i]){
			table[k] = table[i];
			k = i;
		}
	}
	table[k] = temp;
}

void heapSort(vector<int>& table){
	buildMaxHeap(table);
	for(int i = table.size(); i > 1; i--){
		swap(A[i], A[0]);
		HeapAdjust(table, 0, i-1);
	}
}
```

> [!warning] 下标
> 完全二叉树中，根结点的下标为 1，但是在数组中，第一个元素的下标为 0，如果使用从零开始的数组，那么需要注意孩子结点下标的计算方法为：
> - 左孩子：$L_{i}=2i+1$
> - 右孩子：$R_{i}=2i+2$

> [!note] 堆排序的效率分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：建堆的时间为 $O(n)$，之后有 $n-1$ 次向下调整，每次调整的时间为树的高度，即 $O(\log_{2}n)$，所以在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n\log_{2}n)$。
> - **稳定性**：在进行筛选时有可能将相同关键字调整到前面，而将前面的关键字固定到后面，因此堆排序算法是一种不稳定的排序算法。
> - **适用性**：对排序仅适用于顺序存储的线性表。
