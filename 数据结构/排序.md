---
tags:
  - 数据结构与算法
---

# 排序

排序，就是重新排列表中的元素，使表中的元素满足按照关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。

> [!note] 算法的稳定性
> 若待排序表中有两个元素 $R_{i}$ 和 $R_{j}$，其对应的关键字相同，且在排序前 $R_{i}$ 在 $R_{j}$ 前面。若使用某一排序算法排序后，$R_{i}$ 仍然在 $R_{j}$ 的前面，则称该排序算法是**稳定的**，否则这个排序算法是**不稳定的**。

在排序过程中，根据数据元素是否完全放在内存中，可以将排序算法分为两类：
1. 内部排序：指在排序期间元素全部存放在内存中的排序。
2. 外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。*在本节的讨论中，我们默认排序算法的目标为从小到大排序，即非递减序列*。

## 插入排序

插入排序是一种简单直观的方法，基本思想为每次将一个待排序的记录按照其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。

### 直接插入排序

插入排序每次将第 $i$ 个元素插入到前面的 $i-1$ 个有序序列中，其步骤为：
1. 查找`L[i]`在前`L[0...i-1]`个元素中的位置`k`
2. 将`L[k...i-1]`中所有元素向后移动一位
3. 将`L[i]`复制到`L[k]`中
```cpp
void insertSort(vector<int> &table) {
    int size = table.size(), j;
    for (int i = 1; i < size; i++) {
        if (table[i] < table[i - 1]) {
            int temp = table[i];
            // 找到第一个比 temp 小的元素
            for (j = i - 1; j >= 0 && table[j] > temp; j--) {
                table[j + 1] = table[j];
            }
            // 插到该元素的前面
            table[j + 1] = temp;
        }
    }
}

```

> [!note] 直接插入排序算法性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 最差时间复杂度：外层 $O(n)$ 次循环，内层移动元素复杂度为 $O(n)$，综合起来时间复杂度为 $O(n^{2})$。
> 	- 平均时间复杂度：$O(n^{2})$
> - **稳定性**：每次插入元素都是从后往前比较，因此不会出现相对位置变化的情况，直接插入排序算法是稳定的。

> [!tip] 直接插入排序算法适合用于顺序存储和链式存储，且采用链式存储时无需移动元素，但是时间复杂度同样是 $O(n^{2})$。

> [!note]
> 可以看到，直接插入排序的时间复杂度主要在于把比插入值大的元素向后移动，如果待排序表原本就呈现了一种从小到大的趋势，那么插入排序算法就只需要移动较少的元素就可以完成排序，此时效率较高。

### 折半插入排序

从直接插入排序算法中可以看到，每趟插入的过程都进行了两项工作：
1. 从前面的有序子表中找出待插入元素应该被插入的位置
2. 给插入位置腾出空间，将待插入元素复制到表中的插入位置

折半插入排序将查找操作和插入操作分离，先[[数据结构/查找#二分查找|折半查找]]待插入位置，然后统一移动待插入位置之后的所有元素。
```cpp
void binaryInsertSort(vector<int> &table) {
    int size = table.size(), low, high, mid;
    for (int i = 1; i < size; i++) {
        if (table[i - 1] > table[i]) {
            int temp = table[i];
            // 二分查找找到temp的位置
            low = 0, high = i;
            while (low <= high) {
                mid = (low + high) / 2;
                if (table[mid] < temp) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            for (int j = i - 1; j >= low; j--) {
                table[j + 1] = table[j];
            }
            table[low] = temp;
        }
    }
}

```

> [!note] 折半查找的性能分析
> **空间效率**：仅使用了常数级的额外空间，空间复杂度为 $O(1)$
> **时间效率**：相较于简单插入排序，折半查找仅仅减少了比较操作的次数，但是时间复杂度仍然为 $O(n^{2})$

### 希尔排序

希尔排序又称为缩小增量排序，是基于插入排序改进得来。其基本思想为：先将待排序表分割为若干形如`L[i, i+d, i+2d, ..., i+kd]`特殊子表，即把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素呈现基本有序时，再对全体记录进行一次直接插入排序。

希尔排序算法的步骤描述为：
1. 取一个小于`n`的增量`d`，把表中的全部记录划分为`d`组，即距离为`d`的倍数的元素放在一组中，对每一组内进行插入排序。
2. 减小增量`d`，重复上述过程直到`d=1`时，相当于进行直接插入排序，此时数组有序。
```cpp
void shellSort(std::vector<int> &table) {
    int size = table.size(), j;
    for (int d = size / 2; d >= 1; d /= 2) {
        for (int i = d; i < size; i += d) {
            if (table[i] < table[i - d]) {
                int temp = table[i];
                for (j = i - d; j >= 0 && table[j] > temp; j -= d) {
                    table[j + d] = table[j];
                }
                table[j + d] = temp;
            }
        }
    }
}

```

> [!note] 希尔排序的性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及到数学上尚未解决的难题，因此其时间复杂度分析较为困难。当 $n$ 在某个特定的范围内时，希尔排序的时间复杂度约 $O(n^{1.3})$。
> 	- 在最坏的情况下，希尔排序的时间复杂度为 $O(n^{2})$。
> - **稳定性**：当相同的关键字记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是不稳定的。

## 交换排序

交换排序就是根据序列中两个关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，这里主要介绍最著名的冒泡排序和快速排序。

### 冒泡排序

### 快速排序
