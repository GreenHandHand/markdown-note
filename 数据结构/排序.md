---
tags:
  - 数据结构与算法
---

# 排序

排序，就是重新排列表中的元素，使表中的元素满足按照关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。

> [!note] 算法的稳定性
> 若待排序表中有两个元素 $R_{i}$ 和 $R_{j}$，其对应的关键字相同，且在排序前 $R_{i}$ 在 $R_{j}$ 前面。若使用某一排序算法排序后，$R_{i}$ 仍然在 $R_{j}$ 的前面，则称该排序算法是**稳定的**，否则这个排序算法是**不稳定的**。

在排序过程中，根据数据元素是否完全放在内存中，可以将排序算法分为两类：
1. 内部排序：指在排序期间元素全部存放在内存中的排序。
2. 外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。*在本节的讨论中，我们默认排序算法的目标为从小到大排序，即非递减序列*。

## 插入排序

插入排序是一种简单直观的方法，基本思想为每次将一个待排序的记录按照其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。

### 直接插入排序

插入排序每次将第 $i$ 个元素插入到前面的 $i-1$ 个有序序列中，其步骤为：
1. 查找`L[i]`在前`L[0...i-1]`个元素中的位置`k`
2. 将`L[k...i-1]`中所有元素向后移动一位
3. 将`L[i]`复制到`L[k]`中
```cpp
void insertSort(vector<int> &table) {
    int size = table.size(), j;
    for (int i = 1; i < size; i++) {
        if (table[i] < table[i - 1]) {
            int temp = table[i];
            // 找到第一个比 temp 小的元素
            for (j = i - 1; j >= 0 && table[j] > temp; j--) {
                table[j + 1] = table[j];
            }
            // 插到该元素的前面
            table[j + 1] = temp;
        }
    }
}

```

> [!note] 直接插入排序算法性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 最差时间复杂度：外层 $O(n)$ 次循环，内层移动元素复杂度为 $O(n)$，综合起来时间复杂度为 $O(n^{2})$。
> 	- 平均时间复杂度：$O(n^{2})$
> - **稳定性**：每次插入元素都是从后往前比较，因此不会出现相对位置变化的情况，直接插入排序算法是稳定的。

> [!tip] 直接插入排序算法适合用于顺序存储和链式存储，且采用链式存储时无需移动元素，但是时间复杂度同样是 $O(n^{2})$。

> [!note]
> 可以看到，直接插入排序的时间复杂度主要在于把比插入值大的元素向后移动，如果待排序表原本就呈现了一种从小到大的趋势，那么插入排序算法就只需要移动较少的元素就可以完成排序，此时效率较高。

### 折半插入排序

从直接插入排序算法中可以看到，每趟插入的过程都进行了两项工作：
1. 从前面的有序子表中找出待插入元素应该被插入的位置
2. 给插入位置腾出空间，将待插入元素复制到表中的插入位置

折半插入排序将查找操作和插入操作分离，先[[数据结构/查找#二分查找|折半查找]]待插入位置，然后统一移动待插入位置之后的所有元素。
```cpp
void binaryInsertSort(vector<int> &table) {
    int size = table.size(), low, high, mid;
    for (int i = 1; i < size; i++) {
        if (table[i - 1] > table[i]) {
            int temp = table[i];
            // 二分查找找到temp的位置
            low = 0, high = i;
            while (low <= high) {
                mid = (low + high) / 2;
                if (table[mid] < temp) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            for (int j = i - 1; j >= low; j--) {
                table[j + 1] = table[j];
            }
            table[low] = temp;
        }
    }
}

```

> [!note] 折半查找的性能分析
> **空间效率**：仅使用了常数级的额外空间，空间复杂度为 $O(1)$
> **时间效率**：相较于简单插入排序，折半查找仅仅减少了比较操作的次数，但是时间复杂度仍然为 $O(n^{2})$

### 希尔排序

希尔排序又称为缩小增量排序，是基于插入排序改进得来。其基本思想为：先将待排序表分割为若干形如`L[i, i+d, i+2d, ..., i+kd]`特殊子表，即把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素呈现基本有序时，再对全体记录进行一次直接插入排序。

希尔排序算法的步骤描述为：
1. 取一个小于`n`的增量`d`，把表中的全部记录划分为`d`组，即距离为`d`的倍数的元素放在一组中，对每一组内进行插入排序。
2. 减小增量`d`，重复上述过程直到`d=1`时，相当于进行直接插入排序，此时数组有序。
```cpp
void shellSort(std::vector<int> &table) {
    int size = table.size(), j;
    for (int d = size / 2; d >= 1; d /= 2) {
        for (int i = d; i < size; i += d) {
            if (table[i] < table[i - d]) {
                int temp = table[i];
                for (j = i - d; j >= 0 && table[j] > temp; j -= d) {
                    table[j + d] = table[j];
                }
                table[j + d] = temp;
            }
        }
    }
}

```

> [!note] 希尔排序的性能分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：
> 	- 因为希尔排序的时间复杂度依赖于增量序列的函数，这涉及到数学上尚未解决的难题，因此其时间复杂度分析较为困难。当 $n$ 在某个特定的范围内时，希尔排序的时间复杂度约 $O(n^{1.3})$。
> 	- 在最坏的情况下，希尔排序的时间复杂度为 $O(n^{2})$。
> - **稳定性**：当相同的关键字记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是不稳定的。

## 交换排序

交换排序就是根据序列中两个关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，这里主要介绍最著名的冒泡排序和快速排序。

### 冒泡排序

冒泡排序的基本思想是：从后往前 (从前往后) 两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。每一趟冒泡其实就是把关键字小的元素如同气泡一般逐渐上浮到水面的过程。在下一趟冒泡时，前一趟冒泡确定的最小元素不再参与比较，这样最多进行 $n-1$ 趟冒泡就能把所有元素排好序。
```cpp
void bubbleSort(vector<int> &table){
	int temp, flag;
	for(int i = 0; i < n; i++){
		flag = 0;
		for(int j = n - 1; j >= i; j--){
			if(table[i] > table[j]){
				temp = table[i];
				table[i] = table[j];
				table[j] = temp;
				flag = 1;
			}
		}
		// 如果没有发生交换，说明有序
		if(!flag){
			break;
		}
	}
}
```

> [!note] 冒泡排序的性能分析
> **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> **时间效率**：当初始序列有序时，显然第一次冒泡排序后直接跳出循环，此时比较次数为 $n-1$，移动次数为 $0$，即最好的情况下时间复杂度为 $O(n)$。当序列为逆序时，需要进行 $n-1$ 趟冒泡，第 $i$ 趟需要进行 $n-i$ 次关键词比较，而且每次交换操作都需要进行 3 次元素交换。这种情况下，比较次数为 $n(n-1)/2$，移动次数为 $3n(n-1)/2$。因此最坏时间复杂度为 $O(n^{2})$，平均时间复杂度为 $O(n^{2})$。
> **稳定性**：冒泡排序算法是一种稳定的排序算法。
> **适用性**：冒泡排序适合用于顺序存储和链式存储的线性表。

> [!tip] 不同于插入排序算法，冒泡排序过程中产生的有序子序列是全局有序的。

### 快速排序

快速排序算法的基本思想是基于分治法的：在待排序表`L[1...n]`中任取一个元素`pivot`作为枢轴[^枢轴]，通过一趟排序将待排序表划分为独立的两个部分`L[1...k-1]`和`L[k+1...n]`，使得`L[1...k-1]`中的所有元素都小于`pivot`，`L[k+1...n]`中的所有元素都大于或等于`pivot`，则`pivot`放在了其最终位置`L(k)`上，这个过程称为一次划分。然后分别递归的对划分出的两个子表重复上述过程，直到每个表中只有一个元素或者为空为止，即所有的元素都放在了其最终位置上。

快速排序算法的核心是划分，即任选一个元素作为枢轴元素，然后将表划分为大于枢轴元素和小于枢轴元素两部分，其步骤为：
1. 将`pivot`放在表的`low`的位置，即将其与`low`上的元素交换。(一般我们选取表的第一个元素，因此不许需要这一步)
2. 设定两个指针分别指向表的两端，这里使用为`high`与`low`。
3. 从`high`开始往前遍历，找到一个比`pivot`小的元素，该元素应该被放到`pivot`的左边，即将其赋值到`low`上，此时`high`指针空闲。
4. 从`low`开始往后遍历，找到一个比`pivot`大的元素，该元素应该被放到`pivot`的右边，即将其赋值到`high`上，此时`low`指针空闲。
5. 重复 2,3 直到`high==low`，此时`high`与`low`指向的位置就是`pivot`所在的位置，将`pivot`保存到`high`上。
6. 返回`pivot`的位置。

快速排序流程如下：
```cpp
int partition(vector<int>& table, int low, int high){
	int pivot = table[low];
	while(low<high){
		while(low < high && table[high--] > pivot);
		swap(table[low], table[high]);
		while(low < high && table[low++] < pivot);
		swap(table[low, table[high]]);
	}
	table[low] = pivot;
	return low;
}

void _quickSort(vector<int>& table, int low, int high){
	if(low < high){
		int pivotPos = partition(table, low, high);
		_quickSort(table, low, pivotPos - 1);
		_quickSort(table, pivotPos + 1, high);
	}
}

void quickSrot(vector<int>& table){
	_quickSort(table, 0, table.size());
}
```

> [!note] 快速排序的效率分析
>
> **空间效率**：
> - 快速排序采用递归方式进行排序，因此需要使用递归工作栈来保存每一层递归调用所需的信息。
> - 每层递归只需要常数级别的额外空间，因此空间复杂度取决于递归的深度。
> - 在最好的情况下，每次划分都能将数组大致平分为两部分，此时的空间复杂度为 $O(\log_{2}n)$。
> - 在最坏的情况下，即数组已经完全有序或逆序时，每次划分都会产生一个大小为 $n-1$ 和一个大小为 $0$ 的子数组，导致递归深度为 $O(n)$。
> - 平均情况下，快速排序的空间复杂度为 $O(\log_{2}n)$。
>
> **时间效率**：
> - 快速排序的时间效率取决于划分的对称性。
> - 在最坏的情况下，每次划分产生的子数组严重不对称（一个子数组大小为 $n-1$，另一个为 $0$），这通常发生在初始数组几乎有序或逆序时，此时时间复杂度为 $O(n^{2})$。
> - 在最理想的情况下，每次划分都能将数组均匀分为两个大小不超过 $n/2$ 的子数组，这时时间复杂度为 $O(n\log_{2}n)$。
> - 实际上，快速排序在平均情况下的运行时间与最佳情况非常接近，这使得它成为所有内部排序算法中性能最优的选择之一。
>
> **稳定性**：
> - 在划分过程中，如果右端区间中有两个关键字相同的记录，且它们都小于基准值，那么在交换到左端区间后，它们的相对顺序可能会改变。
> - 因此，快速排序是一种不稳定的排序算法。
>
> **适用性**：
> - 快速排序适用于顺序存储的线性表。

> [!tip] 优化
> 如果我们总是选择第一个元素作为枢轴元素，则快速排序的效率很低。我们可以通过修改选择枢轴的方式来更好的表现，例如，每次都随机选择一个元素作为枢轴，或者选择中间的元素。

## 选择排序

选择排序的基本思想是每一趟再后面 $n-i+1$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到 $n-1$ 趟做完，待排序元素只剩下一个，就不用再选。选择排序算法中，堆排序算法较为著名。

### 简单选择排序

简单排序算法就是选择排序最朴素的实现，假设排序表为`L[1...n]`，第 $i$ 趟排序即从`L[i...n]`中找出最小的元素与`L[i]`交换。
```cpp
// 选择排序
void selectSort(vector<int> &table) {
    int size = table.size(), min, temp;
    for (int i = 0; i < size - 1; i++) {
        min = i;
        for (int j = i + 1; j < size; j++)
            if (table[j] < table[min])
                min = j;
        if (min != i) {
            temp = table[i];
            table[i] = table[min];
            table[min] = temp;
        }
    }
}

```

> [!note] 简单选择排序的性能分析
> - **空间效率**：仅使用了常数个辅助单元，所以空间的效率为 $O(1)$。
> - **时间效率**：在简单排序算法的过程中，元素的移动次数很少，不会超过 $3(n-1)$ 次，最少为 0 次，此时对应的表已经有序。但是元素间比较的次数与序列的初始状态无关，始终是 $n(n-1)/2$ 次，因此时间复杂度始终是 $O(n^{2})$。
> - **稳定性**：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与含有相同关键字的元素顺序颠倒，因此简单选择排序是不稳定的。
> - **适用性**：简单选择排序适用于顺从存储、链式存储的线性表，以及关键字较少的情况。

### 堆排序

> [!definition|Definition] 堆
> $n$ 个关键字序列`L[1...n]`称为堆，当且仅当该序列满足：
> 1. `L[i]>=L[2i]`且`L[i]>=L[2i+1]`，称为大根堆
> 2. `L[i]<=L[2i]`且`L[i]<=L[2i+1]`，称为小根堆

> [!note] 堆与二叉树
> 从堆的定义可以看出，如果将一个线性表视为完全二叉树，那么
> - 大根堆就是每个结点中的关键字不小于其孩子结点的完全二叉树。
> - 小根堆就是每个结点中的关键字不大于其孩子结点的完全二叉树.

升序序列的堆排序基于大根堆，其基本步骤如下：
1. 将排序表建立为一个大根堆
2. 从大根堆中选择最大的元素，即第一个元素，将其与最后一个待排序元素交换
3. 待排序表长度减 1，然后重新维护待排序表为大根堆，具体操作为将新交换的元素下坠，使得待排序表符合大根堆的性质。

在建立大根堆的算法如下：
1. 从表的第 $\lfloor n/2 \rfloor$ 个元素开始，向前遍历 (即从完全二叉树的最后一个非叶结点开始，遍历所有的非叶结点)
2. 从 $2i$ 与 $2i+1$ 中选择比 $i$ 结点大的元素，将其与 $i$ 交换 (将 $i$ 为根的子树转换为大根堆)
3. 遍历直到第一个结点，大根堆建立完毕 (遍历直到根结点)

```cpp
void heapAdjust(vector<int> &table, int k, int size) {
    int temp = table[k];
    for (int i = 2 * k + 1; i <= size; i = 2 * i + 1) {
        if (i < size && table[i] < table[i + 1])
            i++;
        if (temp < table[i]) {
            table[k] = table[i];
            k = i;
        }
    }
    table[k] = temp;
}

void buildMaxHeap(vector<int> &table) {
    int size = table.size();
    for (int i = size / 2; i >= 0; i--) {
        heapAdjust(table, i, size);
    }
}

// 堆排序
void heapSort(vector<int> &table) {
    int size = table.size(), temp;
    buildMaxHeap(table);
    for (int i = size - 1; i > 0; i--) {
        temp = table[0];
        table[0] = table[i];
        table[i] = temp;
        heapAdjust(table, 0, i - 1);
    }
}
```

> [!warning] 下标
> 完全二叉树中，根结点的下标为 1，但是在数组中，第一个元素的下标为 0，如果使用从零开始的数组，那么需要注意孩子结点下标的计算方法为：
> - 左孩子：$L_{i}=2i+1$
> - 右孩子：$R_{i}=2i+2$

> [!note] 堆排序的效率分析
> - **空间效率**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$。
> - **时间效率**：建堆的时间为 $O(n)$，之后有 $n-1$ 次向下调整，每次调整的时间为树的高度，即 $O(\log_{2}n)$，所以在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n\log_{2}n)$。
> - **稳定性**：在进行筛选时有可能将相同关键字调整到前面，而将前面的关键字固定到后面，因此堆排序算法是一种不稳定的排序算法。
> - **适用性**：对排序仅适用于顺序存储的线性表。

> [!note] 堆的操作
> 这里对堆这种数据结构作为补充，堆一般使用顺序表作为存储结构。
> - 插入：向堆中插入元素时，先将元素加入顺序表中的最后一个元素，然后递归的对这个元素的父结点进行下降操作，直到子树满足堆的性质。
> - 删除：删除结点时，使用顺序表中的最后一个元素替代被删除的元素，然后对该元素进行下降操作。

## 其他内部排序

### 归并排序

> [!definition|归并] 将两个或者两个以上的有序表合成一个新的有序表。

归并排序算法通过归并操作，将一个长度为 $n$ 的待排序的表视为 $n$ 个有序的子表，然后进行归并操作，递归直到整个表有序。其中，每次归并相邻的两个表的归并算法称为二路归并排序算法。

归并算法的核心就是归并操作，其步骤为：
1. 使用`low`，`mid`和`high`指针将表待排序子表分为`L[low...mid]`和`L[mid+1...high]`两部分，对这两个部分进行归并。设置一个外部数组`LT`用于存放临时数据。
2. 将子表`L`中的数据复制到`LT`中。
3. 从`LT`的两个待归并表的开头开始 (即`low`与`mid+1`)，对比关键词的大小，每次都将较小的值存入`L`的对应位置。
4. 若其中一个表存储完，则另一个表剩余的部分全部存储`L`子表的后端。

```cpp
void merge(vector<int> &table, int low, int mid, int high,
           vector<int> &aux) {
    int i, j, k;
    for (k = low; k <= high; k++) {
        aux[k] = table[k];
    }
    for (i = low, j = mid + 1, k = low; i <= mid && j <= high; k++) {
        if (aux[i] <= aux[j]) {
            table[k] = aux[i++];
        } else {
            table[k] = aux[j++];
        }
    }
    while (i <= mid)
        table[k++] = aux[i++];
    while (j <= high)
        table[k++] = aux[j++];
}

void _mergeSort(vector<int> &table, int low, int high,
                vector<int> &aux) {
    if (low < high) {
        int mid = (low + high) / 2;
        _mergeSort(table, low, mid, aux);
        _mergeSort(table, mid + 1, high, aux);
        merge(table, low, mid, high, aux);
    }
}

// 归并排序
void mergeSort(vector<int> &table) {
    vector<int> aux(table.size());
    _mergeSort(table, 0, table.size() - 1, aux);
}

```

> [!note] 二路归并排序的效率分析
> - **空间效率**：`Merge`操作中，复杂空间刚好为 $O(n)$，而递归子树的最大深度为 $O(\log n)$，因此二路归并排序的空间复杂度为 $O(n)$。
> - **时间效率**：每趟归并的时间复杂度为 $O(n)$，一共需要 $\lceil \log_{2}n \rceil$ 次归并，因此算法的时间复杂度为 $O(n\log_{2}n)$。
> - **稳定性**：`Merge`操作不会改变相同关键字的相对次序，因此二路归并排序是一种稳定的排序算法。
> - **适用性**：归并排序适合用于顺序存储和链式存储的线性表。

> [!tip] 多路归并排序
> 在二路归并排序算法中，我们得到的排序树是一棵倒着的二叉树，树的最大高度为 $\lceil \log_{2}n \rceil$。而在 $k$ 路归并排序时，我们得到的排序树是一颗 $k$ 叉树，因而树的最大高度为 $\lceil \log_{k}n \rceil$。
>
> 使用多路归并排序算法时，虽然树的递归深度变低了，但是每次归并的操作变复杂了。例如，使用三路归并算法时，我们需要归并三张表，每个元素需要比较至少 2 次，此时归并一次的时间约为二路归并的两倍。因此多路归并算法具有更大的常数部分。

### 基数排序

基数排序算法是一种很特别的算法，它不基于比较和移动，而是基于关键字各位的大小进行排序。基数排序主要应用与多关键字数据的排序，例如数据库中的项目。

假设长度为 $n$ 的线性表中每个结点 $a_{j}$ 的关键字由 $d$ 元组 $(k_{j}^{d-1},k_{j}^{d-2},\cdots,k_{j}^{1},k_{j}^{0})$ 组成，其中每个关键字可能的取值为 $r^{d-1},r^{d-2},\cdots,r^{1},r^{0}$，则基数排序算法的过程为：
将关键字按照权重从低到高排列为 $i=0,1,\cdots,d$，依次进行分配和收集：
1. 分配：开始时，设置 $r$ 个空队列`Q[0...r-1]`，依次考查线性表中每个结点第`j`个关键字，将其加入对应的队列中。
2. 收集：把`Q[0...r-1]`个队列依次首位相接，得到新的结点序列，从而组成新的线性表。

```cpp
// 获取 num 的第 d 位数字, 如果没有则返回 -1
int digitAt(int num, int d) {
    int res = num / pow(10, d - 1);
    if (res == 0)
        return -1;
    return res % 10;
}
// 基数排序, 针对正整数实现
// 时间复杂度: O(dn), d 为最大数字的位数
void radixSort(vector<int> &table) {
    // 10 个队列, -1 ~ 9, q[i + 1] 存放第 i 位为 i, q[0] 存放没有第 i 位的数
    queue<int> q[11];
    // 如果所有数都没有第 d 位, 则退出
    int flag = 0, size = table.size(), digit;
    for (int d = 1;; d++) {
        // 分配
        flag = 0;
        for (int i = 0; i < size; i++) {
            digit = digitAt(table[i], d);
            if (!flag && digit != -1)
                flag = 1;
            q[digit + 1].push(table[i]);
        }
        if (!flag)
            break;

        // 收集
        for (int i = 0, k = 0; i < 11; i++) {
            while (!q[i].empty()) {
                table[k++] = q[i].front();
                q[i].pop();
            }
        }
    }
}
```

> [!note] 基数排序的效率分析
> - **空间效率**：一趟排序需要的辅助空间为 $r^{n}$，所以基数排序的空间复杂度为 $O(r)$。
> - **时间效率**：基数排序需要进行 $d$ 趟收集和分配操作，一趟收集操作需要遍历所有关键字，时间复杂度为 $O(n)$，一趟收集操作需要合并 $r$ 个队列，时间复杂度为 $O(r)$，因此基数排序的时间复杂度为 $O(d(n+r))$，它与序列的初始状态无关。
> - **稳定性**：每一趟收集分配都是先进先出，不会交换相同关键字的位置，因此基数排序是一种稳定的排序算法。
> - **适用性**：基数排序适合于顺序存储和链式存储的线性表。

## 外部排序

前面介绍的排序算法都是在内存中进行的，称为内部排序。

外部排序指的是大文件的排序，即待排序的记录存储在外存中，待排序文件无法一次性装入内存，需要在内存和外存之间进行多次数据交换，以达到排序整个文件的目的。

文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读、写的。因为磁盘读写的操作所需的时间远远超过了在内存中进行运算的时间，因此在外部排序过程中时间代价主要考虑访问磁盘的次数，即 IO 次数。

### 归并排序算法

**外部排序通常采取==归并排序==算法**，它主要包括两个阶段：

1. **生成归并段**：
   - 根据内存缓冲区大小 $l$，将外存上的文件分割成若干长度为 $l$ 的子文件。
   - 利用内部排序算法对这些子文件进行排序，并将排序后的有序子文件写回外存。
   - 这些排序后的子文件被称为**归并段**或**顺串**。

2. **归并归并段**：
   - 对这些归并段进行逐步归并，使归并段逐渐变大，直到整个文件变得有序。
   - 归并过程如下：
     1. 从 $l$ 个相邻的归并段中读取第一个磁盘块，放入内存缓冲区。
     2. 对这 $l$ 个内存缓冲区进行归并，并将归并结果保存在输出缓冲区中。
        - 如果输出缓冲区满，则将其中的内容按顺序写回磁盘。
        - 如果内存缓冲区为空，则从对应的归并段中读取下一个磁盘块。

> [!warning]
> 在归并的过程中，如果内存缓冲区为空，则必须立即停止向输出缓冲区写入，并先读取下一个磁盘块。
> 通过这样的操作，可以保证每次归并都是基于比较每个子序列的最小元素进行的。

> [!example]-
> 这里给出外部排序的一个完整的流程。
> 1. 划分归并段。假设内存缓冲区大小为 4，一次可以读入 4 个磁盘块。在这一步中，我们将整个磁盘划分为 $n/4$ 个归并段，依次读入并进行内部排序，然后写入外存。该步骤中每个磁盘块都要被读写一次。
> 	- 从内存中读入归并段![[image/排序-1.png#inline|从内存中读入归并段]]
> 	- 进行内部排序后写回外存![[image/排序-2.png#inline|进行内部排序后写回外存]]
> 2. 对归并段进行归并。
> 	- 读取对应的归并段![[image/排序-3.png#inline|读取对应的归并段]]
> 	- 进行归并，结果保存在输出缓冲区![[image/排序-4.png#inline|归并]]
> 	- 如果输出缓冲区满，则写入磁盘块![[image/排序-5.png#inline|写入磁盘块]]
> 	- 如果输入缓冲区空，立即读取对应归并段的下一个磁盘块![[image/排序-6.png#inilne|输入缓冲区空，读取下一个磁盘块]]

> [!note] 外部排序的时间消耗
> 外部排序的时间 = 内部排序时间 + 外存信息读写时间 + 内部归并的时间
> 显然，外存信息读写的时间远远大于内部排序和内部归并的时间，因此应着重减少 I/O 次数。

一般而言，对于 $r$ 个初始归并段，进行 $k$ 路平衡归并：
- 第一趟可以将 $r$ 个初始归并段归并为 $\lceil r/k \rceil$ 个归并段。
- 之后每趟归并将 $m$ 个归并段归并为 $\lceil m/k \rceil$ 个归并段，直至最终形成一个大的归并段。
- 树的高度-1 = $\lceil \log_{k}r \rceil$ = 归并趟数 $S$。
- 可见，通过增大归并路数 $k$ 或者减少初始归并段个数 $r$，可以减少归并趟数 $S$，进而减少读写磁盘的次数，从而提高外部排序的速度。

### 多路平衡归并与败者树

### 置换-选择排序

### 最佳归并树
