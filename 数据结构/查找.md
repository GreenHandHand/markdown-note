---
tags:
  - 数据结构与算法
---

# 查找

> [!definition|Definition] 查找
> 在数据集合中寻找满足某种条件的数据元素的过程称为*查找*。查找的结果分为两种：
> 1. 查找成功，即在数据集合中找到了满足条件的数据元素；
> 2. 查找失败。

> [!note] 关于查找的一些术语
> 1. 查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，对于查找表的常见操作有*查询符合条件的数据元素*和*插入、删除数据元素*。
> 2. 静态查找表：若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应的是动态查找表。
> 	- 静态查找表：顺序查找，折半查找，散列查找等
> 	- 动态查找表：二叉排序树、散列查找
> 3. 关键字：数据元素中唯一标识元素的某个数据项的值，基于关键字的查找，查找的结果应该是唯一的。
> 4. 平均查找长度：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字比较次数的平均值。平均查找长度是衡量算的效率最主要的指标。

> [!example] 平均查找长度的数学定义
> 平均查找长度的数学定义为：
> $$
\text{ASL}=\sum_{i=1}^{n}P_{i}C_{i}
> $$
> 其中 $n$ 为查找表长度，$P_{i}$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_{i}=1/n$，$C_{i}$ 是找到第 $i$ 个数据元素所需要进行的比较次数。

## 顺序查找

顺序查找又称为线性查找，即顺序扫描表中的每一个元素，直到找到目标关键字。

```cpp title:添加哨兵的线性查找
int searchSeq(int table[], int size, TYPE key){
	// 设置哨兵, 我们假设这里不会出现数组越界的情况
	table[size] = key;
	int i;

	for(i = 0; table[i] != key; i++);
	return i == size ? i : -1;
}
```

> [!tip] 哨兵
> 顺序查找结果简单，哨兵是一种对于查找的优化。在顺序查找的过程中，为了节省一些不必要的判断，我们将顺序表的一头设置为哨兵元素 (设置为查找目标)，然后从另一头开始扫描。在扫描过程中，退出条件为当前元素是否是查找目标。
>
> 通过设置哨兵，我们就可以避免大量的判断数组越界的判断语句，只需要在最后判断找到的目标究竟是先前设置的哨兵，还是查找到的目标。

> [!note] 线性查找的平均查找长度
> 对于有 $n$ 个元素的表，给定值`key`与表中的第 $i$ 个元素相等时，需要进行 $i$ 次关键字比较，查找成功时，平均查找长度为
> $$
\text{ASL}_\text{成功}=\sum_{i=1}^{n}P_{i}i
> $$
> 当每个元素的查找概率相等时，即 $P_{i}=1/n$，此时数学期望为
> $$
\text{ASL}_\text{成功}=\sum_{i=1}^{n}P_{i}i=\frac{n+1}{2}
> $$
> 查找不成功时，关键字的比较次数显然为 $n+1$ 次 ($n$ 个元素与一个哨兵)。

顺序查找实现简单，且泛用性强，对数据没有要求；但是当 $n$ 比较大时，平均查找长度大，效率低。因此顺序查找在数据量小的情况下比较常用，但是对于数据量大的情况，我们需要其他的方法。

> [!example]- 有序线性表的顺序查找
> 如果已知线性表是有序的，那么在扫描到比大于关键字的元素时还没有找到，那么就可以直接返回查找是失败的信息了。*~~实际上我觉得这个内容没有存在的必要，对于有序的数据我们一般不用属性查找，但是这个内容还是有应用场景的，例如链表中的查找。~~*

## 二分查找

二分查找又称为折半查找，仅用于有序的顺序表。二分查找的思想是将给定的`key`值每次都与表中间的元素进行比较，由于表是有序的，因此每次查找都能够淘汰一半的待查找元素。
```cpp title:二分查找
int binarySearch(int table[], int size, int key){
	int low=0, high=size-1, mid;
	while(low <= high){
		mid = (low + high) / 2;
		if(table[mid] < key){
			high = mid - 1;
		}else if(table[mid] > key){
			low = mid + 1;
		}else{
			return mid;
		}
	}
	return -1;
}
```

> [!warning] 
> 1. 二分查找中，既可以向下取整，也可以向上取整，但是整个算法的取整方式必须相同。
> 2. 算法中更新方式使用`high=mid-1`与`low=mid+1`，如果使用`high=mid`或者`low=mid`进行更新，算法虽然也可以通过不断缩小区间从而找到目标值，但是可能会出现死循环的情况：  
>	- 考虑向下取整，此时`high=r+1`，`low=r-1`，
>	- 计算`mid=r`，如果此时程序使用`low=mid`进行更新，计算新的`mid=(r+1+r)/2`得到结果为 `mid=r`，此时陷入死循环。
