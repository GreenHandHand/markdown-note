---
tags:
  - 数据结构与算法
---

# 查找

> [!definition|Definition] 查找
> 在数据集合中寻找满足某种条件的数据元素的过程称为*查找*。查找的结果分为两种：
> 1. 查找成功，即在数据集合中找到了满足条件的数据元素；
> 2. 查找失败。

> [!note] 关于查找的一些术语
> 1. 查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素组成，对于查找表的常见操作有*查询符合条件的数据元素*和*插入、删除数据元素*。
> 2. 静态查找表：若一个查找表的操作只涉及查找操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应的是动态查找表。
> 	- 静态查找表：顺序查找，折半查找，散列查找等
> 	- 动态查找表：二叉排序树、散列查找
> 3. 关键字：数据元素中唯一标识元素的某个数据项的值，基于关键字的查找，查找的结果应该是唯一的。
> 4. 平均查找长度：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字比较次数的平均值。平均查找长度是衡量算的效率最主要的指标。

> [!example] 平均查找长度的数学定义
> 平均查找长度的数学定义为：
> $$
\text{ASL}=\sum_{i=1}^{n}P_{i}C_{i}
> $$
> 其中 $n$ 为查找表长度，$P_{i}$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_{i}=1/n$，$C_{i}$ 是找到第 $i$ 个数据元素所需要进行的比较次数。


## 基本查找方法

顺序查找、二分查找和分块查找方法是用于线性表的查找方法，它们不需要改变数据的组织方式，并且实现简单。

### 顺序查找

顺序查找又称为线性查找，即顺序扫描表中的每一个元素，直到找到目标关键字。

```cpp title:添加哨兵的线性查找
int searchSeq(int table[], int size, TYPE key){
	// 设置哨兵, 我们假设这里不会出现数组越界的情况
	table[size] = key;
	int i;

	for(i = 0; table[i] != key; i++);
	return i == size ? i : -1;
}
```

> [!tip] 哨兵
> 顺序查找结果简单，哨兵是一种对于查找的优化。在顺序查找的过程中，为了节省一些不必要的判断，我们将顺序表的一头设置为哨兵元素 (设置为查找目标)，然后从另一头开始扫描。在扫描过程中，退出条件为当前元素是否是查找目标。
>
> 通过设置哨兵，我们就可以避免大量的判断数组越界的判断语句，只需要在最后判断找到的目标究竟是先前设置的哨兵，还是查找到的目标。

> [!note] 线性查找的平均查找长度
> 对于有 $n$ 个元素的表，给定值`key`与表中的第 $i$ 个元素相等时，需要进行 $i$ 次关键字比较，查找成功时，平均查找长度为
> $$
\text{ASL}_\text{成功}=\sum_{i=1}^{n}P_{i}i
> $$
> 当每个元素的查找概率相等时，即 $P_{i}=1/n$，此时数学期望为
> $$
\text{ASL}_\text{成功}=\sum_{i=1}^{n}P_{i}i=\frac{n+1}{2}
> $$
> 查找不成功时，关键字的比较次数显然为 $n+1$ 次 ($n$ 个元素与一个哨兵)。

顺序查找实现简单，且泛用性强，对数据没有要求；但是当 $n$ 比较大时，平均查找长度大，效率低。因此顺序查找在数据量小的情况下比较常用，但是对于数据量大的情况，我们需要其他的方法。

> [!example]- 有序线性表的顺序查找
> 如果已知线性表是有序的，那么在扫描到比大于关键字的元素时还没有找到，那么就可以直接返回查找是失败的信息了。*~~实际上我觉得这个内容没有存在的必要，对于有序的数据我们一般不用属性查找，但是这个内容还是有应用场景的，例如链表中的查找。~~*

### 二分查找

二分查找又称为折半查找，仅用于有序的顺序表。二分查找的思想是将给定的`key`值每次都与表中间的元素进行比较，由于表是有序的，因此每次查找都能够淘汰一半的待查找元素。
```cpp title:二分查找
int binarySearch(int table[], int size, int key){
	int low=0, high=size-1, mid;
	while(low <= high){
		mid = (low + high) / 2;
		if(table[mid] < key){
			high = mid - 1;
		}else if(table[mid] > key){
			low = mid + 1;
		}else{
			return mid;
		}
	}
	return -1;
}
```

> [!warning] 
> 1. 二分查找中，既可以向下取整，也可以向上取整，但是整个算法的取整方式必须相同。
> 2. 算法中更新方式使用`high=mid-1`与`low=mid+1`，如果使用`high=mid`或者`low=mid`进行更新，算法虽然也可以通过不断缩小区间从而找到目标值，但是可能会出现死循环的情况：  
>	- 考虑向下取整，此时`high=r+1`，`low=r-1`，
>	- 计算`mid=(r+1+r-1)/2=r`
>	- 如果此时程序使用`low=mid`进行更新，计算新的`mid=(r+1+r)/2`得到结果为 `mid=r`，此时陷入死循环。

**判定树**：二分查找的查找过程可以用一颗树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值表示该记录的关键字值。树的叶节点都是方形的，用一个区间表示查找失败的区间。从判定树的定义可以看出来，二分查找的过程就是从树中找到一个根结点的过程，如果没有根节点对应，即找到了叶节点，说明查找失败。
![[image/查找-1.png|inline]]
若有序序列有 $n$ 个元素，则其对应的判定树有 $n$ 个圆形结点 (根节点)，$n+1$ 个叶节点。显然，二分查找的判定树是一颗平衡二叉树。

> [!note] 二分查找的平均查找长度
> 从判定树可以看出，二分查找的最大比较次数不会超过树的高度。假设有序表中的元素个数为 $n$，需要查找的关键字的位置为 $i$，可以得到其对应的判定树的高度 $h_{i}$ 满足 $h_{i}=\lceil \log_{2}n_{i} \rceil$。在等概率查找时，查找成功的平均查找长度为：
> $$
\begin{aligned}
\text{ASL}_\text{成功}&=\frac{1}{n}\sum_{i=1}^{n}h_{i}=\frac{1}{n}\sum_{i=1}^{n}\lceil \log_{2}n_{i} \rceil \\&=\frac{1}{n}\log_{2}(1+2\times 2+\cdots+h\times 2^{h-1})\\&=\frac{n+1}{n}\log_{2}(n+1)-1\approx \log_{2}(n+1)-1
\end{aligned}
> $$
> 也就是二分查找的时间复杂度为 $O(\log_{2}n)$。

二分查找的实现简单，且查找速度快 (基本是最快的一种方法了)，但是对于数据的要求高，需要我们时刻维护一个有序的数据表，这个操作的代价过于高了，因此二分查找一般适合用于数据变化频率小的场景。

### 分块查找

分块查找又称为索引顺序查找，它吸收了顺序查找与二分查找的优点，既有动态结构，又适合快速查找。分块查找将查找表分为若干子块，块的元素可以是无序的，但是块间的元素需要是有序的，即**第一个块中最大的关键字小于第二个块中最小的关键字**。基于这个性质，我们可以为每个块建立一个索引表，表中记录每个块的最大值 (最小值) 与各个块第一个元素的地址 (最后一个块)，索引表按照块的关键字大小排序。

分块查找的过程为：
1. 在索引表中找到待查记录所在的块，可以使用顺序查找或者二分查找
2. 在对应的索引块内顺序查找

> [!note] 分块查找的平均查找长度
> 分块查找的平均查找长度为索引查找和块内查找的平均长度之和。假设将长度为 $n$ 的查找表均匀的分为 $b$ 块，每个块由 $s$ 个记录，在等概率的情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为
> $$
> \text{ASL}=L_{1}+L_{s}=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^{2}+2s+n}{2s}
> $$
> 若 $s=\sqrt{ n }$，则平均查找长度取得最小值 $\sqrt{ n }+1$。

## 树形查找

### 二叉排序树

从[[#二分查找]]中我们可以发现，有序的树形结构有利于查找元素。二叉排序树就是一种基于树形结构，有利于查找、插入和删除数据的实现。

> [!definition|Definition] 二叉排序树
> 二叉排序树是具有下面特性的二叉树：
> 1. 若左子树非空，则左子树上所有结点的值均小于根节点的值。
> 2. 若右子树非空，则右子树上所有结点的值均大于根节点的值。
> 3. 左、右子树也分布是一颗二叉排序树。

> [!tip] 
> 根据二叉排序树的定义，我们可以得到**左子树结点的值 < 根结点的值 < 右子树结点的值**，因此对二叉排序树使用*中序遍历*，可以得到一个递增的有序序列。

#### 查找

二叉排序树的查找是从根节点开始，沿着某个分支逐层向下比较的过程。即每次查找都与根节点比较，如果`key`大于根结点，则查找右子树。如果`key`小于根节点，则查找左子树。

#### 插入

二叉排序树可以在查找的同时插入树中不存在的关键字值