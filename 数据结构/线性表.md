---
tags:
  - 数据结构与算法
---
# 线性表

线性表是基础的数据结构，是具有相同数据类型的 $n$ 个数据元素的有限序列，其中 $n$ 为表长。当 $n=0$ 时线性表是一个空表，若使用 $L$ 命名线性表，则其一般表示以为
$$
L=(a_{1}, a_{2}, \dots, a_{i}, a_{i+1}, \dots, a_{n})
$$
线性表的特点如下：
- 表中的元素个数有限
- 表中元素具有逻辑上的顺序性，表中元素有其先后次序
- 表中元素都是数据元素，每个元素都是单个元素
- 表中元素的数据类型都相同，占用的存储空间大小都相同
- 表中元素具有抽象性

> [!note] 一些重要的术语
> - 表长、空表：线性表中的元素的数量称为表长，特别的，表长为零时线性表为空表
> - 表头、表尾：线性表的第一个元素和最后一个元素
> - 前驱、后继：线性表中一个元素前面的元素和后面的元素
> - 位序：从抽象层面看，数据元素的位序从 1 开始。在实际中，为了较少编译器的工作，常从 0 开始计算

## 基本操作

|           名称            |   操作   |               解释                |
| :---------------------: | :----: | :-----------------------------: |
|     `InitList(&L)`      |  初始化表  |            构造一个空的线性表            |
|       `Length(L)`       |  求表长   |    返回线性表 L 的长度，即 L 中数据元素的个数     |
|   `LocateElem(L, e)`    | 按值查找操作 |       在表 L 中查找具有给定关键字值的元素       |
|     `GetElem(L, i)`     | 按位查找元素 |      获取表 L 中第 i 个位置上的元素的值       |
| `ListInsert(&L, i, e)`  |  插入操作  |     在表 L 中第 i 个位置上插入指定元素 e      |
| `ListDelete(&e, i, &e)` |  删除操作  | 删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值 |
|     `PrintList(L)`      |  输出操作  |       按前后顺序输出线性表 L 的所有元素值       |
|       `Empty(L)`        |  判空操作  |   若 L 为空表，则返回 true，否则返回 False   |
|    `DestroyList(&L)`    |  销毁操作  |      销毁线性表，并释放线性表 L 所占用的空间      |
## 顺序表

线性表的**顺序存储方式**。用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素物理位置上也相邻。

> [!warning] 需要注意：线性表元素位序下标从 1 开始，而数组中元素的下标从 0 开始。

顺序表的主要优点：
- 可以进行随机存取，取值的时间复杂度为 $O(1)$
- 存储密度高，每个结点只存储数据元素

顺序表的缺点：
- 元素的插入和删除需要移动大量的元素，插入操作平均需要移动 $\dfrac{n}{2}$ 个元素，删除操作平均需要移动 $\dfrac{n-1}{2}$ 个元素
- 顺序存储分配需要一段连续的存储空间，不够灵活

## 链表

线性表的**链式存储方式**。基于每个元素中存储的指针的指向，常用的链表实现有单链表、双链表和循环链表。

### 单链表

单链表中，每个链表结点除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。其中 data 为数据域，存放数据元素；next 为指针域，存放其后继结点的地址。
```cpp
typedef struct LNode{
	ElemType data;
	struct LNode* next;
}LNode, *LinkList;
```

> [!note] 头结点
> 在定义单链表时，第一个结点通常不存储数据，用于记录表长等数据。引入头结点，可以带来两个优点：
> 1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。
> 2. 无论链表是否为空，其头指针都是指向头结点的非空指针，因此空表的处理和非空链表的处理也就得到了统一。

> [!Tip]- 前插操作
> 前插操作是指在某结点的前面插入一个新的结点，后插操作与之定义相反。在单链表中，使用的均为后插操作。我们无法通过一个结点直接得到其前驱结点，只能通过从开始结点开始重新遍历到其前驱结点，时间复杂度为 $O(n)$。
>
>但是对于插入结点操作，我们可以采用另一个种方式来将前插操作转换为后插操作。即将新结点插入当前结点的后面，然后交换它们的数据域。
>
>对于删除操作，我们也可以通过同样的思路删除直接删除一个给定结点。对于给定结点，将其后继的值赋值给该结点，然后删除后继结点，效果等价与删除当前结点。

### 双链表

单链表结点中只有一个指向其后继结点的指针，使得单链表只能从前往后遍历，访问一个结点前驱的时间复杂度为 $O(n)$。为了克服单链表的这个缺点，引入了双链表。
```cpp
typedef struct DNode{
	ElemType data;
	struct DNode *prior, *next;
}DNode, *DLinkList;
```
双链表在单链表结点中增加了一个指向其前驱的指针，因此双链表的按值查找与按位查找的操作与单链表相同。但是双链表在插入和删除操作的实现上有较大的区别，需要同时修改 prior 与 next，并且保证<u>修改过程中不断链</u>。

> [!note] 对于链表修改过程中复杂的指针指向关系，建议绘制示意图来理清思路。

### 循环链表

循环链表也可以实现为循环单链表和循环双链表。这里以循环单链表为例，循环双链表可以使用相同的方式推广。

循环单链表与单链表的区别在于，表中最后一个结点的指针不是 NULL，而是指向头结点，从而整个链表形成一个环。

在循环单链表中，表尾结点的 next 指向 L 的头结点，故表中没有指向 NULL 的结点。此时循环单链表的判空条件不是头结点的指针是否为空，而是等于头指针 L。

> [!note] 循环单链表相较于单链表的优势
> 循环单链表可以从表中的任意一个结点开始遍历整个链表。有时，对于单链表仅设置指向尾部的指针，而不是指向头部的指针，因为指向头部的指针在表尾插入元素的时间复杂度为 $O(n)$，而指向尾部的指针在表尾和表头插入元素的时间复杂度均为 $O(1)$。
> 
> 虽然带有指针的循环链表可以很方便的在尾部添加元素，但是删除尾部结点的时间复杂度为 $O(n)$，因为我们无法直接得到尾部结点的前驱结点。

> [!tip] 含有尾指针的循环链表的特殊处理
> 在循环链表中，由于包含了尾指针，因此在尾部进行处理时需要判断尾部是否改变。例如，当含有尾指针的循环单链表进行删除操作时，要判断删除的结点是否为尾结点。如果删除的是尾结点，那么需要将尾指针进行修改。
### 静态链表

静态链表是使用数组来描述线性表的链式存储方式。每个结点中也有数据域和指针域，但是使用数组来模拟。这里的指针是结点在数组中的相对地址 (数组下标)，又称为游标。
```cpp
#define MAX_SIZE 50
typedef struct{
	ElemType data;
	int next;
}SLinkList[MAX_SIZE];
```

> [!note] 和顺序表一样，静态链表也要预先分配一块连续的内存空间。

## 顺序表与链表的比较

|   比较内容    |         顺序表         |          链表          |
| :-------: | :-----------------: | :------------------: |
|   存取方式    |        随机存取         |         顺序存取         |
| 逻辑结构与物理结构 |    逻辑结构相邻，物理结构相邻    |   逻辑结构相邻，物理结构不一定相邻   |
|   按值查找    |       $O(n)$        |        $O(n)$        |
|   按位查找    |       $O(1)$        |        $O(n)$        |
|    插入     | 查找 $O(1)$，插入 $O(n)$ | 查找 $O(n)$，插入 $O(1)$  |
|    删除     | 查找 $O(1)$，删除 $O(n)$ | 查找 $O(n)$，删除 $O(1)$  |
|   空间分配    |   需要连续空间，且需要预先分配    | 只在需要空间时申请，只要有空间就可以分配 |

选择数据结构的参考：
1. 基于存储考虑：难以估计线性表的长度或者存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但是链表的存储密度较低。
2. 基于运算考虑：频繁访问数据元素，考虑顺序表。对于插入、删除操作频繁的线性表，考虑链表。

> [!note] 为什么插入操作中链表更加高效？
> 在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不可以忽视的；
>  	
> 在链表中进行插入、删除操作时，虽然也要找插入位置，但是操作主要是比较操作，从这个角度考虑，后者更优。