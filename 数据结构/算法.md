---
tags:
  - 数据结构与算法
---
# 算法

算法 (algorithm) 是对特定问题求解步骤的一种描述，是求解问题的步骤。

> [!quote] 数据结构、算法与程序的关系
> 程序=数据结构+算法

数据结构是算法的核心，算法是基于数据结构进行的各种操作。常用的数据结构包括了 [[数据结构/线性表|线性表]]， [[数据结构/栈、队列和数组|栈、队列和数组]]， [[数据结构/树与二叉树|树与二叉树]]，[[数据结构/图|图]] 等。

算法的特性：
- 有穷性：算法必须是有穷的，*程序可以是无穷的*。
- 确定性：对于相同的输入，只能得到相同的输出。算法必须是无歧义的。
- 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
- 输入：一个算法有**零个或者多个**输入。
- 输出：一个算法有**一个或者多个**输出。

> [!note] “好”算法应当具有的属性
> - 正确性：好算法能够正确的解决问题。
> - 可读性：好算法具有良好的可读性。
> - 健壮性：输入非法数据，好算法可以适当地做出反应或者进行处理，而不会产生莫名其妙的结果。
> - 高效率与低存储需求：低时间复杂度、低空间复杂度。

## 效率的度量

算法的效率的度量是通过时间复杂度和空间复杂度来描述的。

### 时间复杂度

时间复杂度用于评价一个算法的时间开销。算法中所有语句的频度之和记为 $T(n)$，它是该算法规模 $n$ 的函数。算法中的基本运算的频度与 $T(n)$ 同数量级，因此通常将算法中基本运算的执行次数的数量级作为算法的时间复杂度，记为
$$
T(n)=O(f(n))
$$
其中 $O$ 表示 $T(n)$ 的数量级，该方法称为大 O 表示法。在算法中，时间复杂度与算法相关，且不唯一。
- **最坏时间复杂度**：在最坏的情况下，算法的时间复杂度。
- **平均时间复杂度**：所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
- 最好时间复杂度：在最好的情况下，算法的时间复杂度。

一般总是考虑最坏时间复杂度，保证算法的运行时间不会太长，但是平均时间复杂度在现实中也有使用。

> [!note] $O$ 函数的严格数学定义：
> 若 $T(n)$ 和 $f(n)$ 是定义在正整数集合上的两个函数，则存在正常数 $C$ 和 $n_{0}$，使得当 $n\geq n_{0}$ 时，都满足 $0\leq T(n)\leq Cf(n)$。

#### 时间复杂度的计算

这里给出两条显而易见的运算规则。
- 加法规则：$O(f(n))+O(g(n))=O(max(f(n), g(n)))$
- 乘法规则：$O(f(n))\times O(g(n)) = O(f(n)\times g(n))$

计算时，通常根据代码块的内容来判断时间复杂度。常用的时间复杂度从低到高排列为：
$$
O(1) < O(\log_{2}n)<O(n)< O(n\log_{2}n) < O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$
在数学上，$O$ 表示在 $n\to\infty$ 时最高阶的无穷大。

常见的代码块的时间复杂度如下：
- 顺序执行代码：$O(1)$
- 执行 $n$ 次的循环：$O(n)$
- 嵌套循环，其中每个训练的执行次数为 $n_{i}$：$O\left( \prod_{i=1}^n n_{i} \right)$
- 嵌套循环，但是其中有一个内层循环使用用了外层循环的循环变量，则需要把这两个循环合并计算
- 执行 $n$ 次的循环中，每次执行循环都使得指示变量翻倍：$O(\log_{2}n)$

最后，对于一些难以用经验判断代码复杂度的情况，我们需要计算其中基本计算的数量，将其写为一个函数，然后再通过大 O 表示法进行化简。

### 空间复杂度

空间复杂度计算方式同空间复杂度，但是更加简单。我们同样使用大 O 表示法表示空间复杂度。在实际的计算中，我们计算每个代码块中申请内存的数量随着问题规模的增长而增长的速度。

对于一般的情况，我们直接计算申请内存部分的运行次数即可。

特别的，对于**递归函数**，每次递归执行函数都会申请一个新的函数空间，并申请函数需要的变量。因此递归函数需要计算**递归深度**，并将其乘上函数中的空间申请，才能计算其空间复杂度。

---
|  [[数据结构/线性表|线性表]] >