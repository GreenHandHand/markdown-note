---
tags:
  - 数据结构与算法
---
# 树与二叉树

树是 $n(n\geqslant)$ 个结点的有限集，当 $n=0$ 时，称为空树。在任意一棵非空树中应满足：
1. 有且仅有一个特定的称为根的结点。
2. 当 $n>1$ 时，其余结点可分为 $m(m>0)$ 个互不相交的有限集 $T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并且称为根的子树。

显然，树的定义是递归的，即在树的定义中又用到了其自身。**树是一种递归的数据结构**。树作为逻辑结构，同时也是一种分层结构，具有以下两个特点：
1. 树的根结点没有前驱。除根结点以外的结点只有一个前驱。
2. 树中所有结点都可以由零个或多个后继。

树适用于表示具有层次结构的数据。树中的某个结点最多和上一层的一个结点有直接关系。

> [!note] 关于树的基本术语
> 1. 祖先、子孙、双亲、孩子、兄弟和堂兄弟 (考虑结点 K)：
> 	- 祖先：从根结点 A 到结点 K 的唯一路径上的其他结点。
> 	- 子孙：以 K 为根结点的子树中的所有结点 (不包括 K)。
> 	- 双亲：K 结点的父结点。
> 	- 孩子：与 K 结点直接相连的子结点。
> 	- 堂兄弟：双亲在同一层的结点互为堂兄弟。
> 2. 结点的度和数的度：
> 	- 结点的度：结点的孩子的个数
> 	- 树的度：树中结点的最大度数
> 3. 分支结点和叶结点：
> 	- 分支结点：度大于 0 的结点 (有孩子的结点，又称为非终端结点)
> 	- 叶结点：度为 0 的结点(没有孩子的结点，又称为终端结点)
> 4. 结点的深度、高度和层次：
> 	- 结点的层次：从树根开始定义，根结点为第 1 层，它的孩子结点为第二层，以此类推。
> 	- 结点的深度：结点所在的层次。
> 	- 树的高度 (深度)：结点中的最大层次
> 	- 结点的高度：以该结点为根结点的子树的高度
> 5. 有序树和无序树：
> 	- 有序树：树中从左到右的结点是有顺序的，不能互换 (列表 list)
> 	- 无序树：树中的孩子结点没有顺序，可以互换 (集合 set)
> 6. 路径和路径长度：
> 	- 路径：树中两个结点之间经过的结点序列
> 	- 路径长度：路径经过的边的数量
> 7. 森林：森林是 $m(m\geqslant)$ 棵互不相交的数的集合。森林的概念与数的概念十分接近，只要把树的根结点去掉就成了森林。反之，只要给 $m$ 个根结点加上一个父结点，森林就变成了树。

## 树的性质

树具有如下最基本的性质：
1. 树的结点数 $n$ 等于所有结点的度数之和加 1。
2. 度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点 $(i\geqslant 1)$。
3. 高度为 $h$ 的 $m$ 叉树至多有 $(m^{h}-1)/(m-1)$ 个结点。
4. 度为 $m$、具有 $n$ 个结点的树最小高度 $h$ 为 $\left[ \log_{m}(n(m-1)+1) \right]$。
5. 度为 $m$、具有 $n$ 个结点的树的最大高度 $h$ 为 $n-m+1$。

## 二叉树

二叉树是一种特殊的树型结构，其特点是每个结点至多只有两棵子树，并且二叉树有左右子树之分，其次序不能颠倒。

> [!note] 二叉树与度为 2 的有序树的区别
> 1. 度为 2 的有序树至少有 3 个结点，而二叉树可以为空
> 2. 度为 2 的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子无需区分左右。但是二叉树必须确定其孩子的左右次序。

> [!example] 几种特殊的二叉树
> 1. 满二叉树。一棵高度为 $h$，且有 $2^h-1$ 个结点的二叉树称为满二叉树，即二叉树中的每一层都还有最多的结点。满二叉树的结点都集中在二叉树的最下层，并且除了叶结点之外，度都为 2。
> 	- 可以对满二叉树按层编号，约定编号从根结点 (1) 起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则双亲的编号为 $\lfloor \dfrac{i}{2} \rfloor$，若有左孩子，则左孩子为 $2i$；若有右孩子，则右孩子为 $2i+1$
> 2. 完全二叉树。高度为 $h$，有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度相同的满二叉树中编号为 $1\to n$ 的结点一一对应时，称为完全二叉树。
> 	- 若 $i\leqslant \lfloor \dfrac{n}{2} \rfloor$，则结点 $i$ 为分支结点，否则为叶结点。
> 	- 叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。
> 	- 若有度为 1 的结点，最多只能有一个，且该结点只有左孩子而无右孩子。
> 	- 按层编号后，一旦出现某个结点 (编号为 i) 为叶结点或者之后左孩子，则编号大于 $i$ 的结点均为叶结点
> 	- 若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子。若 $n$ 为偶数，则编号最大的分支结点 $\dfrac{n}{2}$ 只有左孩子而没有右孩子，其余分支结点左右孩子都有。
> 3. 二叉排序树。左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字。左子树和右子树又各是一棵二叉排序树。
> 4. 平衡二叉树。树中任意一个结点的左子树和右子树的高度之差的绝对值不超过 1。
> 5. 正则二叉树。树中每个分支结点都有 2 个孩子，即树中只有度为 0 或 2 的结点。

> [!note] 二叉树的性质
> 1. **非空二叉树上的叶结点数等于度为 2 的结点数加 1**，即 $n_{0}=n_{2}+1$。
> 2. 非空二叉树的第 $k$ 层最多右 $2^{k-1}$ 个结点 ($k\geqslant 1$)。
> 3. 高度为 $h$ 的二叉树至多有 $2^{h}-1$ 个结点 ($k\geqslant 1$)。
> 4. 对完全二叉树从上到下、从左到右顺序依次编号 $1,2,\cdots,n$，则有以下关系
> 	- 若 $i\leqslant \lfloor \dfrac{n}{2} \rfloor$，则结点 $i$ 为分支结点，否则为叶结点，即最后一个分支结点的编号为 $\lfloor \dfrac{n}{2} \rfloor$。
> 	- 叶结点只可能在层次最大的两层上出现。
> 	- 若有度为 1 的结点，则只可能有一个，且该结点有左孩子而无右孩子，其编号为 $\lfloor \dfrac{n}{2} \rfloor$。
> 	- 按层序编号后，一旦出现某结点(如结点 $i$)为叶结点或只有左孩子的情况，则编号大于 $i$ 的结点均为叶结点。
> 	- 若 $n$ 为奇数，则每个分支结点都有左、右孩子；若 $n$ 为偶数，则编号最大的分支结点只有左孩子，没有右孩子。其余分支结点都有左右孩子。
> 	- 当 $i>1$ 时，结点 $i$ 的双亲结点的编号为 $\lfloor \dfrac{i}{2} \rfloor$。
> 	- 结点 $i$ 所在的层次 (深度) 为 $\lfloor \log_{2}i \rfloor+1$。
> 5. 具有 $n$ 个结点的完全二叉树的高度为 $\lceil \log_{2}(n+1) \rceil$ 或 $\lfloor \log_{2}n \rfloor+1$。

### 二叉树的存储结构

> [!note] 树的顺序存储结构
> 二叉树的顺序存储结构是指用一组连续的存储单元依次自上而下、自左而右存储完全二叉树上的结点元素，即将完全二叉树编号为 $i$ 的元素存储到 $i-1$ 个分量上。
> 
> 根据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的编号可以唯一地反映结点之间的逻辑关系。这样既能最大的节省存储空间，又能利用数组元素的下标值确定结点在二叉树的位置，以及结点之间的关系。
> 
> 但是对于一般的二叉树，使用顺序存储结构会导致数组中大量的元素为空，最坏的情况下，一个高度为 $h$ 的单结点二叉树需要占据 $2^{h}-1$ 个存储单元。

二叉树一般采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构包含数据域、指针域。
```cpp
typedef struct BiTNode{
	ElemType data;
	struct BiTNode *lchild, *rchild;
	// 对于需要频繁访问父节点的场景，添加指向父节点的指针可以极大的提高效率
	// struct BiTNode *parent; 
}BiTNode, *BiTree;
```
容易验证，在含有 $n$ 个结点的二叉链表中，含有 $n+1$ 个空链域。利用这些空链域，可以组成**线索链表**。

### 二叉树的遍历

二叉树的遍历指按某种搜索路径访问树中的每个结点，使得每个结点被访问一次，而且只访问一次。二叉树的遍历算法一般使用递归实现，根据递归调用的先后顺序，可以分为前序遍历、中序遍历、后序遍历三种顺序。

#### 先序遍历

按照下面的顺序访问二叉树：
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

```cpp
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T); // 在继续遍历之前，先访问该结点的数据
		PreOrder(T->lchild);
		PreOrder(T->cchild);
	}
}
```

#### 中序遍历

按照下面的顺序访问二叉树：
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

```cpp
void InOrder(BiTree T){
	if (T!=NULL){
		InOrder(T->lchild);
		visit(T); // 先遍历左子树，然后在访问根结点
		InOrder(T->rchild);
	}
}
```

#### 后序遍历

按照下面的顺序访问二叉树：
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点

```cpp
void PostOrder(BiTree T){
	if(T != NULL){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```

> [!note]
> 在二叉树的三种遍历方法，遍历左右子树的顺序都是相同的，差别只在于访问根结点的顺序。不管采用什么遍历方法，每个结点都只访问一次，因此时间复杂度为 $O(n)$。在递归遍历中，递归工作栈的栈深度恰好为树的深度，因此在最坏的情况下，$n$ 个结点的二叉树的空间复杂度为 $O(n)$。

#### 转换为非递归算法

上面介绍的算法非常直观的展示了不同二叉树遍历的区别，但是使用递归的实现方式对资源的消耗较大，这里介绍非递归的实现方式。

```cpp
void PreOrder(BiTree T){
	Stack S;
	BiTree p = T;
	while( p || !S.empty() ){
		if(p){
			visit(p);
			S.push(p);
			p = p->lchild;
		}else{
			p = S.pop();
			p = p->rchild;
		}
	}
}

void InOrder(BiTree T){
	Stack S;
	BiTree p = T;
	while( p || !S.empty() ){
		if(p){
			S.push(p);
			p = p->lchild;
		}else{
			p = S.pop();
			visit(p);
			p = p->rchild;
		}
	}
}

void PostOrder(BiTree T){
	Stack S;
	BiTree p = T;
	while( p || !S.empty() ){
		if(p){
			S.push(p);
		}else{
			p = S.top();
			if( p->rchild && p->rchild != r )
				p = p->rchild;
			else{
				pop(S, p);
				visit(p);
				r = p;
				p = NULL;
			}
		}
	}
}
```

#### 层次遍历

层次遍历即按层遍历，按照完全二叉树的排序的方向遍历二叉树。我们可以借助队列先进先出的特性，先遍历父节点，再遍历子节点。
```cpp
void LevelOrder(BiTree T){
	Queue Q;
	Q.enQueue(T);
	while( !Q.empty() ){
		BiTree p = Q.deQueue();
		visit(p);
		if(p->lchild) Q.enQueue(p->lchild);
		if(p->rchild) Q.enQueue(p->rchild);
	}
}
```

> [!note] 由遍历序列构造二叉树
> 对于一个给定的二叉树，其先序遍历、中序遍历、后序遍历和层次遍历的顺序都是确定的。
> - 只给出四种顺序中的任意一种，无法确定二叉树的结构
> - **给出中序遍历序列和其他的任何一种，可以唯一确定一棵二叉树**

### 线索二叉树

> [!definition|Definition] Here is the title, which should be place after the prefix text and spacing 2 space. This should be bold.
> Here is the definition content. Hopefully this should be neat and clear. You can add something to make here more clear and beautiful.

