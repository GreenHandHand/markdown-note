---
tags:
  - Rust
---

# 无畏并发

安全且高效地处理并发编程是 Rust 的另一个主要目标。**并发编程** (*Concurrent programming*)，代表程序的不同部分相互独立地执行，而**并行编程** (*parallel programming*) 代表程序不同部分同时执行，这两个概念随着计算机越来越多的利用多处理器的优势而显得愈发重要。由于历史原因，在此类上下文中编程一直是困难且容易出错的：Rust 希望能改变这一现状。

## 多线程

因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：
- [[操作系统/操作系统基本原理概论#异步|竞态条件]] (Race conditions): 多个线程以不一致的顺序访问数据或资源。
- [[操作系统/进程管理#死锁|死锁]] (Deadlocks): 两个线程互相等待对方资源，导致两者都无法运行。
- 只会发生在特定情况，且难以重现和修复的 bug。

Rust 尝试减轻使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，同时其所要求的代码结构也不同于运行于单线程的程序。

### 创建线程

Rust 中使用 `std::thread` 进行线程操作，并提供了一些线程的常用操作。
- 使用 `thread::spawn(fn)` 创建一个线程，其中 `fn` 是一个实现了 `FnOnce` 的 [[Rust/函数式特性#Fn trait|函数]]。该函数返回一个 `JoinHandle` 类型，负责管理这个线程的资源。
- 使用 `JoinHandle.join()` 方法来阻塞一个线程，直到对应的线程执行完毕。该方法返回一个 `Result` 对象。

```rust
use std::thread;
use std::time::Duration;

fn main() {
	// 创建了一个线程
	let handle = thread::spawn(|| {
		for i in 0..10 {
			println!("Thread says {i}.");
            thread::sleep(Duration::from_secs(1));
		}
	});

	handle.join().unwarp();
}
```

> [!note] `join` 方法的返回值
> 对于某些错误，线程可能直接终止，此时会链式调用主线程的 `panic!` 并退出执行。如果子线程发生了 `panic!` 且没有终止程序，那么就会返回一个 `Err` 并附带终止信息。

### 传递资源

`move` 修饰的闭包经常用于 `thread::spawn` 创建的线程中。考虑下面的情景：

```rust
use std::thread;

fn main() {
	let v = !vec[1, 2, 3];
	let handle = thread::spawn(|| {
		println!("{v:?}"); // 编译器推断为 &v
	}); // Error!
	
	drop(v); // 由于线程是异步执行的
			 // 这里有两种可能性，但是编译器不知道是哪一种
	handle.join().unwarp();
}
```

如果 Rust 允许这段代码运行，则新建线程可能会立刻被转移到后台并完全没有机会运行。新建线程内部有一个 `v` 的引用，当执行 `drop` 函数后，`v` 将被丢弃，此时闭包中的引用就变成了悬垂引用。

正确的方式是显示地声明闭包是所有权捕获的，即使用 `move` 关键词修饰。

```rust
use std::thread;

fn main() {
	let v = !vec[1, 2, 3];
	let handle = thread::spawn(move || {
		println!("{v:?}"); // 移动所有权
	});
	
	// drop(v); // v 的所有权被移动，这里无法再使用 v
	handle.join().unwarp();
}
```

> [!tip]
> `move` 关键字覆盖了 Rust 默认保守的借用，但它不允许我们违反所有权规则。

## 消息传递

[[操作系统/进程管理#消息传递|消息传递]] (*message passing*) 是一种确保安全并发的沟通方式。为了实现消息传递并发，Rust 标准库提供了一个**信道**^[信道是一个通用编程概念，表示数据从一个线程发送到另一个线程。]（*channel*）实现。

信道有两个组成部分：**发送端** (*transmitter*) 和**接收端** (*receiver*)。当发送端或接收端任一被丢弃时可以认为信道被**关闭** (*closed*) 了。我们使用 `std::sync::mpsc` 中的方法来创建一个信道。其中 `mpsc` 是 *multiple producer, single consumer* 的缩写，表示 [[[操作系统/进程管理#生产者消费者问题|多生产者，单消费者]]。

Rust 中一个简单的信道的例子如下：

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        // 我们将 tx 转移到线程中以实现发送消息
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

> [!note] 由于历史原因，我们使用 `tx` 表示发送端，使用 `rx` 表示发送端。
> - 对于 `tx`，我们可以通过 `clone()` 方法来创建多个生产者，并通过 `send()` 方法发送消息。
> - 对于 `rx`，我们可以通过 `recv()` 方法接收消息。

> [!note] `send` 的返回值
> `send` 返回一个 `Result`
> - 如果发送成功，则返回一个 `Ok(())`。
> - 如果发送失败 (例如接收方已经被丢弃了)，返回一个 `Err` 并返回错误。

> [!note] 接收消息
> Rust 中使用三种方式接收消息：
> - `recv()`：阻塞进程直到接收到消息，返回 `Result`。当发送方关闭，则返回一个 `Err` 表示不会再有值到来。
> - `try_recv()`：不会立即阻塞，而是直接返回一个 `Result`，如果有消息，则返回一个 `Ok` 并包含对应的值；如果没有消息，则返回一个 `Err` 表示此时没有任何消息。
> - 迭代器：我们还可以将 `rx` 视为一个迭代器，这将不断调用 `recv()` 方法直到得到一个 `Err`。

> [!tip] 我们的并发错误会造成一个编译时错误。
> `send` 函数获取其参数的所有权并移动这个值归接收端所有。这可以防止在发送后意外地再次使用这个值；所有权系统检查一切是否合乎规则。

## 共享内存

[[操作系统/进程管理#共享存储|共享内存]] 是另一种线程通信的方式。Rust 中通过互斥锁来实现安全访问。

### 互斥锁

**互斥器**（*mutex*）是互相排斥（*mutual exclusion*）的缩写，因为在同一时刻，它只允许一个线程访问数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的**锁**（*lock*）来表明其希望访问数据。锁是一个数据结构，作为互斥器的一部分，它记录谁有数据的专属访问权。因此我们讲，互斥器通过锁系统**保护**（*guarding*）其数据。

> [!tip] 在 Rust 中，得益于所有权机制，我们不可能在锁的获取与释放上出错。

`Mutex<T>` 使用 `new` 创建一个带有锁的变量。我们可以通过 `lock()` 方法获得一个锁中的变量，该方法是一个原子操作，将变量上锁。当一个变量被上锁时，其他对该变量调用 `lock` 方法会被阻塞到锁被释放。

> [!note]
> `lock()` 方法返回一个 `Result`，当一个线程获得了锁，但是还没释放就 `panic` 退出了，此时其他线程调用 `lock()` 方法会得到一个 `Err`。

> [!tip]
> 实际上，`Mutex` 是一个智能指针，调用其 `lock()` 方法会返回一个 `MutexGuard` 的智能指针，该指针实现了 `Deref` 来获取其中的值。它也实现了 `Drop` 方法，在离开作用域时会自动释放锁。

### 多线程共享互斥锁

在 [[Rust/智能指针|智能指针]] 中，我们使用 `Rc<T>` 来实现。